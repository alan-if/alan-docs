= Hints And Tips

This chapter will give you some ideas about how the various features of Alan may be used to implement common features in an adventure game. These are only suggestions and you are, of course, welcome to invent your own, but these are probably some ideas that can get you started.

Using the import mechanism of the Alan language (see <<Import>>) you can reuse snippets that you invent in multiple games or works. By building such a library you don't have to reinvent the same thing every time.

A very easy way to get a lot of functionality, and learn about using the language, is to use the Alan standard library. You you can download it from the Alan Home Pages. It implements many of the things described below, and loads of other handy things for you to use directly. For details on how to use that library, refer to its documentation.



[NOTE]
================================================================================
The following examples, hints and tips does _not_ use any library, only plain vanilla Alan code.
================================================================================






== Use of Attributes

Attributes are primarily used for holding status information about the instance to which it belongs. This allows, for example, a water bottle to contain three levels of water.

[source,alan]
--------------------------------------------------------------------------------
The bottle IsA object
  Has level 3.
  Verb drink
    Does
    If level Of bottle > 0 Then
      "You take sip from the bottle."
      Decrease level OF bottle.
    Else
      "There is no more water in the bottle."
    End If.
  End Verb drink.
End The bottle.
--------------------------------------------------------------------------------

Another example is the broken mirror.

[source,alan]
--------------------------------------------------------------------------------
The mirror IsA object
  Is Not broken.
  Verb break
    Does
      Make mirror broken.
  End Verb break.
End The mirror.
--------------------------------------------------------------------------------

The appropriate verbs defined in the instances may then modify the attributes and thus update the status information.

Attributes defined for a whole class of instances also allow an extra dimension of classification of the instances. If the following declaration is made


[source,alan]
--------------------------------------------------------------------------------
Add To Every object
  Not takeable.
--------------------------------------------------------------------------------

then all objects receive the attribute "`takeable`" and unless the attribute is specifically redeclared for a particular instance they will not be take-able. Note however that the semantic meaning (what actually happens, such as preventing the "`taking`") of "`takeable`" must be implemented e.g. in the verb "`take`":

[source,alan]
--------------------------------------------------------------------------------
Verb take
  Check Object Is takeable
    Else "You can't take the $o."
  Does
    Locate Object In inventory.
End Verb take.
--------------------------------------------------------------------------------

In the same way restrictions concerning what is possible to eat, drink, open etc. may be implemented. This use of attributes to classify instances is "`action-oriented`", i.e. they imply that a particular action (verb) is applicable to the instance.

An alternate approach is to use attributes to classify instances after their characteristics. Consider:

[source,alan]
--------------------------------------------------------------------------------
Verb take
  Check o Is Not heavy
    Else "That is much too heavy."
  And o Is Not animal
    Else "$+1 moves quickly away, just far enough
          for you not to reach it."
  Does
    Locate o In hero.
    "You take" Say The o. "."
End Verb take.
--------------------------------------------------------------------------------


With this approach you need to keep track of which properties a particular verb will accept or require. This could be extended one step further, having verbs check actual dimensions, such as weight or size, instead.

An while we are talking about classification, the Alan 3 class concept can help. Often a classification can be made, clearly and succinctly, by defining a sub-class, for which every property pertaining to that type of instances can be collected. Often, the need for an attribute disappears.

Further more, you don't need to define a syntax for a single parameter verb if it only accepts instances from a particular class. Consider the following definitions:

[source,alan]
--------------------------------------------------------------------------------
Every vehicle IsA object
End Every vehicle.

Every car IsA vehicle
  Verb drive
    Does "Yoooohooooo!"
  End Verb.
End Every car.

Every bus IsA vehicle
End Every bus.

The car1 IsA car At l
End The car1.

The bus1 IsA bus At l
End The bus1.
--------------------------------------------------------------------------------


Without any syntax definition what so ever, Alan will supply a default syntax for the drive verb which restricts the use of it to only instances of car:


[EXAMPLE,role="gametranscript"]
================================================================================
&gt; look

There is a car1 and a bus1 here.

&gt; drive bus1 +
You can't do that.

&gt; drive car1 +
Yoooohooooo!
================================================================================



So the class mechanism not only allows for another way to classify your instances, but also makes it much easier to get player input handled correctly.



== Descriptions

Attributes come in handy when presenting information about instances to the player. The attributes can be tested in `If`-statements to modify the ``Description``s and possibly even the short description in the `Mentioned` sections.

For example:

[source,alan]
--------------------------------------------------------------------------------
The mirror IsA object
  Is Not broken.
  Description
    "On the wall there is a beautiful mirror with an
     elaborate golden frame."
    If mirror Is broken Then
      "Some moron has broken the glass in it."
    End If.
  Verb break
    Does
      Make mirror broken.
  End Verb break.
End The mirror.
--------------------------------------------------------------------------------


If you also use this feature with the short descriptions will make the adventure feel a bit more consistent.

[source,alan]
--------------------------------------------------------------------------------
The bottle IsA object
  Has level 3.
  Article ""
  Mentioned
    If level Of bottle > 0 Then
      "a bottle of water"
    Else
      "an empty bottle"
    End IF.
End The bottle.
--------------------------------------------------------------------------------



If the bottle had level 0 and was in the hero's container, this would result in


[EXAMPLE,role="gametranscript"]
================================================================================
&gt; inventory +
You are carrying an empty bottle.
================================================================================





== Common Verbs

As your library of adventures grow you will find that some verbs are often needed, and always function the same way. Examples are "`take`", "`drop`", "`invent`", "`look`", "`quit`" and so on. It is advisable to put them in a file which may then be imported into your games. See <<Import>> about the import mechanism. The files may then containing these common verbs as well as their syntax definitions and any synonyms. Attributes needed for these particular verbs could also be placed in a default attribute declaration in this file.

All your adventures may then import this file (or files), making these features immediately accessible when you start a new adventure. All that this takes is some thought as to what names to use for the attributes as discussed in <<Use of Attributes>>.

And of course there is already an extensive library available from the Alan website, http://www.alanif.se/[www.alanif.se^]. It also includes a lot of other features common to most adventure games.



== Distant Events

An effect of the feature that output is not visible unless the hero is present, is that the description of an event might not always be presented to the player.

[source,alan]
--------------------------------------------------------------------------------
Event explosion
  "A gigantic explosion fills the whole room with smoke
   and dust. Your ears ring from the loud noise. After
   a while cracks start to show in the ceiling,
   widening fast, stones and debris falling in
   increasing size and numbers until finally the
   complete roof falls down from the heavy explosion."
  Make Location destroyed.
End Event.
--------------------------------------------------------------------------------

If the hero isn't at the location where the event is executed, he will never know anything about what has happened. The solution is to create an event that goes of where the hero is.

--------------------------------------------------------------------------------
Event distant_explosion
  "Somewhere far away you can hear an explosion."
End Event.
...
If Hero Nearby Then
  Schedule distant_explosion At Hero After 0.
...
--------------------------------------------------------------------------------




== Doors

A common feature in adventure games is the closed door. Here's one way implement it:

[source,alan]
--------------------------------------------------------------------------------
The treasury_door IsA object At hallway
  Name treasury door
  Is Not open.
  Verb open
    Does
      Make treasury_door open.
      Make hallway_door open.
  End Verb open.
End The treasury_door.

The hallway IsA location
  Exit east To treasury
    Check treasury_door Is open
      Else "The door to the treasury is closed."
  End Exit.
End The hallway.

The hallway_door IsA object At treasury
  Name hallway door
  Is Not open.
  Verb open
    Does
      Make treasury_door open.
      Make hallway_door open.
  End Verb open.
End The hallway_door.

The treasury IsA location
  Exit west TO hallway
    Check hallway_door Is open
      Else "The door to the hallway is closed."
  End Exit.
End The treasury.
--------------------------------------------------------------------------------


Note that we need two doors, one at each location, but they are synchronised by always making them both opened or closed at the same time. The check in the ``Exit``s makes sure that the hero cannot pass through a closed door.



== Questions and Answers

Sometimes it may be necessary to ask the player for an answer to some question. One example is if you want to confirm an action. The following example delineates one simple way to do this, which could be adopted for various circumstances.

[source,alan]
--------------------------------------------------------------------------------
The hero IsA actor
  Is Not quitting.
End The hero.

Syntax
  'quit' = 'quit'.
  yes = yes.

Synonyms
  y = yes.
  q = 'quit'.

Verb 'quit'
  Does "Do you really want to give up?
        Type 'yes' to quit, or to carry on just
        type your next command."
  Make hero quitting.
  Schedule unquit After 1.
End Verb 'quit'.

Verb yes
  Check hero Is quitting
    Else "That does not seem to answer any question."
  Does Quit.
End Verb yes.

Event unquit
  Make hero Not quitting.
End Event unquit.
--------------------------------------------------------------------------------




== Actors

Actors are vital components to make a story dynamic. They move around and act according to their scripts. To make the player aware of the other actor's actions they need to be described. This must be done so that the player always get the correct perspective on the actions of the actors.

A way to ensure this is to rely on the fact that output statements are not shown unless the hero is at the location where the output is taking place. This means that for every actor action, especially movement, you need to first describe the actions, then let the actor perform them and, finally, possibly describe the effects.

An example is the movement of an actor from one location to another. In this case the step could look something like

[source,alan]
--------------------------------------------------------------------------------
"Charlie Chaplin goes down the stairs to the hallway."
Locate charlie_chaplin At hallway.
"Charlie Chaplin comes down the stairs and
 leaves the house through the front door."
Locate charlie_chaplin At outside_house.
"Charlie Chaplin comes out from the nearest house."
--------------------------------------------------------------------------------

An actor is described, for example, when a location is entered or as the result of a *Look,* in the same way as objects are. This means that a good idea is to include the description of an actor's activities in the description of him. One way to do this would be to use attributes to keep track of the actors state and test these in the description clause.

[source,alan]
--------------------------------------------------------------------------------
The george IsA actor
  Name George Formby
  Is
    Not cleaning_windows.
    Not tuning.
  Description
    If george Is cleaning_windows Then
      "George Formby is here cleaning windows."
    ElsIf george Is tuning Then
      "George Formby is tuning his ukelele."
    Else
      "George Formby is here."
    End If.
...
--------------------------------------------------------------------------------

Although quite feasible, this is a bit tedious. As, at least a part of, the state is indicated by the script the actor is executing, this could be used to avoid the potentially large `If`-chain. The optional descriptions tied to each script will be executed instead of the main description when the actor is following that script. So this would allow us to simplify to:

[source,alan]
--------------------------------------------------------------------------------
The george IsA actor
  Name George Formby
  Description
    "George Formby is here."
  Script cleaning.
    Description
      "George Formby is here cleaning windows."
    Step
      ...
  Script tuning.
    Description
      "George Formby is tuning his ukelele."
    Step
      ...
...
--------------------------------------------------------------------------------

This makes it easier to keep track of what an actor is doing. Another hint here is to describe the change in an actor's activities at the same time as executing the `Use` statement, like

Event start_cleaning +
Use Script cleaning For george. +
"All of a sudden, George starts to clean the windows." +
End Event.

This makes the descriptions of changes to be shown when it takes place and the description of the actor is always consistent. You can, of course, still have attributes describing the actor's state to customize the description of the actor on an even more detailed level, but it generally suffices to describe an actor in terms of what script he is executing.



== Vehicles

The current version of Alan does not support actors being inside containers or inside other actors, which could be a straight forward way to implement vehicles. However, as the reader/player does not need to know how the output is generated we can use a location and a row of events to substitute for the vehicle.

Let's start with the geography:

[source,alan]
--------------------------------------------------------------------------------
The garage IsA location
End The garage.

The parking_lot IsA location Name 'Large Parking Lot'
End The parking_lot.
--------------------------------------------------------------------------------

Then we need the actual car:

[source,alan]
--------------------------------------------------------------------------------
The car IsA object Name little red sporty ferrari Name car
  At garage
  Is Not running.
  Has position 0.

  Verb enter
    Does
      Locate hero At inside_car.
  End Verb enter.

End The car.
--------------------------------------------------------------------------------

We also need a description of the inside of it. We will use another location for this:

[source,alan]
--------------------------------------------------------------------------------
The inside_car IsA location Name 'Inside the Ferrari'
  Description
    "This sporty little red vehicle can really take you
     places..."
  Exit out TO inside_car
    Check car Is Not running
      Else "I think you should stop the car before getting
            out..."
    Does
      Depending On position Of car
        = 0 Then Locate hero At garage.
        = 1 Then Locate hero At parking_lot.
        --- Etc.
    End Depend.
  End Exit.

  Verb drive
    Check car Is Not running
      Else "You are already driving it!"
    Does
      Make car running.
      If car At garage Then Schedule drive_to_parking After 0.
      Else Schedule drive_to_garage After 0.
      End If.
  End Verb drive.

  Verb park
    Check car Is running
      Else "You are not driving it!"
    Does
      "You slow to a stop and turn the engine off."
      Make car Not running.
      Cancel drive_to_parking. Cancel drive_to_garage.
  End Verb park.

End The inside_car.
--------------------------------------------------------------------------------


We must make sure that the player can just say "`drive`" and "`park`" by defining the syntax for those single word commands:

[source,alan]
--------------------------------------------------------------------------------
Syntax drive = drive.
Syntax park = park.
--------------------------------------------------------------------------------

You can also see from the code above that there are (at least) two events that need to be defined too. They handle the movement of the car from one place to another:

[source,alan]
--------------------------------------------------------------------------------
Event drive_to_parking
  "You drive out from your garage and approach a large
   parking lot."
  Set position Of car To 1.
  Locate car At parking_lot.
  Schedule drive_to_garage After 1.
End Event drive_to_parking.

Event drive_to_garage
  "You drive out from the parking lot and approach your own
   garage."
  Set position Of car To 0.
  Locate car At garage.
  Schedule drive_to_parking After 1.
End Event drive_to_garage.
--------------------------------------------------------------------------------

The main idea is that the player/reader is inside the car, and the events are executed at this location thus emulating movement.

There is a multitude of solutions for this problem. One possibility is to exchange the car object for an actor and the events for script steps. However, in this solution the car object is not where the hero is (`inside_car`) so the output from the scripts for the car will not automatically be shown to the player. There are (at least) two different ways to deal with this (one involving attributes, the other involving an extra object), but the solutions are left as an exercise to the reader!

As Alan allows nesting locations (locating a location at another as if it was an object or actor), yet another solution would be to actually move the car location between the garage and the parking lot.

Sincere thanks go to Walt (sandsquish@aol.com) for inspiring communication that brought this example to life.



== Floating Objects

Floating objects is a term used for objects that are available everywhere, or at least at many places. Usually they are available wherever the hero is, and we want to avoid creating duplicate objects, so in a way we make them float along with the hero, or some other actor, instead.



=== Body Parts

One example of floating objects is the various parts of the hero's body.

To create floating objects you can use a particular feature of entities, namely the fact that they are always located where the hero is. Such an entity can of course have the container property to allow it to contain a number of other instances.

So to have the hero's body parts available wherever the hero goes you can use:

[source,alan]
--------------------------------------------------------------------------------
The body_parts IsA entity
  Container
End The body_parts.

The right_arm IsA object Name right arm In body_parts ...
The head IsA object Name head In body_parts ...
--------------------------------------------------------------------------------


Using entity containers is also a simple way to create other compartments on the hero, such as a belt.

[source,alan]
--------------------------------------------------------------------------------
The belt IsA entity
  Container
    Header
      If Count In hero > 0 Then "and"
      Else "but" End If.
        "in your belt you have"
      Else
        ""
End The belt.
--------------------------------------------------------------------------------

You can combine that with the following definitions of the hero and the 'invent' verb:

[source,alan]
--------------------------------------------------------------------------------
The hero IsA actor
  Container
    Header "You are carrying"
    Else "You are empty-handed"
      If Count In belt = 0 Then "." End If.
End The hero.

Verb invent
  Does
    List hero.
    List belt.
End Verb invent.
--------------------------------------------------------------------------------

And the following output could result:

[EXAMPLE,role="gametranscript"]
================================================================================
&gt; invent +
You are empty-handed but in your belt you have a knife.
================================================================================



[NOTE]
================================================================================
The example use the count aggregate to see if the other container is empty or not, and select appropriate output depending on that.
================================================================================



=== Outdoors and Indoors

Another example of floating objects are semi-abstract objects like the air, the ground and walls. Some of these also have the extra complexity that they should be available only under certain conditions.

Of course, you would not want outdoor things to be available when you are indoors. To solve this, simply create yet another container object where we can store the outdoor things when they should not be accessible and place it where the hero can never be. Now we only need to make sure that the objects are transferred between the two storages:

[source,alan]
--------------------------------------------------------------------------------
The outdoor_things IsA entity
  Container
End The outdoor_things.

The outdoor_things_storage IsA object At limbo
  Container
End The outdoor_things_storage.

The air IsA object In outdoor_things_storage ...
The sky IsA object In outdoor_things_storage ...

When location Of hero Is outdoors =>
  Empty outdoor_things_storage In outdoor_things.
When location Of hero Is Not outdoors =>
  Empty outdoor_things In outdoor_things_storage.
--------------------------------------------------------------------------------


You need to add the boolean attribute `outdoors` to every location to the make the rules work, of course.

And VoilÃ , every time the hero arrives at an outdoor location he will find the air and the sky. And every time he enters a location that has the attribute `outdoors` set to false he will not find them available.

Well, perhaps he would like to have the air available indoors too, but that is left as an exercise for the reader!


[NOTE]
================================================================================
An alternative to the location attribute, is to use classes. Define an outdoor_location class and an indoor_location class. Then inherit as appropriate, and the rules could instead look like:
================================================================================



[source,alan]
--------------------------------------------------------------------------------
When location Of hero IsA outdoors_location => ...
When location Of hero IsA indoors_location => ...
--------------------------------------------------------------------------------



=== Nested Locations as a Solution

Yet another option would be to make use of the nested locations feature. Put all your outdoor locations in a outdoor location where the outdoor_storage entity is also present (this is just a hint):

[source,alan]
--------------------------------------------------------------------------------
The outdoor_region IsA location
End The outdoor_region.

The park IsA location At outdoor_region
End The park.
--------------------------------------------------------------------------------


Then the outdoor items can stay at this "`region`" location, no need for rules or extra containers.



== Darkness and Light Sources

A very common puzzle in old time adventures (so much so that it has possibly been exploited beyond its potential) is the problem of dark locations and finding a source of light.

Darkness and light sources can be implemented in Alan in different ways. Again we basically have the choice between attributes and classes. The solutions are both general and rather similar so we will have a look at the solution using attributes and leave the other solution to the reader. (A good exercise to really understand the Alan class concept, so please take a stab at it. If you want to have a look at one solution, you can study the Alan standard library, which uses classes to implement light sources.)

First we need an attribute that all objects have. We know we only need to consider objects because light sources need to be transported by the player, so they can not just be anywhere, like entities.

[source,alan]
--------------------------------------------------------------------------------
Add To Every object
  Is
    Not lightsource.
End Add To.
--------------------------------------------------------------------------------


This ensures that all objects have the boolean (true/false valued) attribute `lightsource` with the default not being a light source. Any object that provides light need to explicitly state that they are instead. For some instances this attribute might change value dynamically, e.g. when the lamp is lit and extinguished.

Locations then must declare themselves as lit or not:

[source,alan]
--------------------------------------------------------------------------------
Add To Every location
  Is lit.
End Add To.
--------------------------------------------------------------------------------

Here we assume most locations are lit, dark locations need to declare themselves `Not lit`.

We can now count the number of instances at the current location having the attribute `lightsource` set and if there are one or more there is some light provided. So, the `look` verb could be reworked to:

[source,alan]
--------------------------------------------------------------------------------
Verb 'look'
  Check Current Location Is lit
    Or Count IsA object, Is lightsource, Here > 0
  Else
    "You cannot see anything without any light."
  Does
    Look.
End Verb.
--------------------------------------------------------------------------------


The check of the `look` verb now checks the current locations need for light and then counts instances of object, that are light sources and present, to see if there is light.

Of course, we must also modify the dark locations so that they don't display their descriptions upon entrance. This is easy to do using another addition to every location, a description check, similar to the check in the `look` verb:

[source,alan]
--------------------------------------------------------------------------------
Add To Every location
  Description
  Check Current Location Is lit
    Or Count IsA object, Is lightsource, Here > 0
  Else
    "You cannot see anything without any light."
End Add To.
--------------------------------------------------------------------------------





== Distant & Imaginary Objects

Sometimes you need to make it possible for the player to refer to things either far away, that are not really objects or that may be at many places at once. Examples of these are a distant mountain that may be examined through a set of binoculars, the melody in "`whistle the melody`", and water or walls. One way of handling this is to use entities, since they are "`everywhere`". But sometimes you need better control over when they are available and when not.



=== A Mountain

For objects that need to be visible from a distance, the easiest method is to introduce a '`shadow object`'. This is a second object acting on behalf of, or representing, the distant object at the locations where it should be possible to refer to it. For example:

[source,alan]
--------------------------------------------------------------------------------
The hills IsA location
  :
End The hills.

The mountain IsA object At hills
  :
End The mountain.

The scenic_vista IsA location Name Scenic Vista
End The scenic_vista.

The shadow_mountain IsA object AT scenic_vista
  Name distant mountain
  Description
    "Far in the distance you can see the Pebbly
     Mountain raising towards the sky."
End The shadow_mountain.
--------------------------------------------------------------------------------



This would allow for example at scenic_vista:


[EXAMPLE,role="gametranscript"]
================================================================================
*Scenic Vista.* +
Far in the distance you can see the Pebbly Mountain raising +
towards the sky. +

&gt; look at mountain through the binoculars +
...
================================================================================



If the mountain must be visible and possible to manipulate from a number of locations, you might implement one shadow object for each location, but this might become a bit tedious if they are many. If they are identical you can use a simple rule like the following:

[source,alan]
--------------------------------------------------------------------------------
When hero At scenic_vista Or hero At hill_road =>
  Locate shadow_mountain At hero.
--------------------------------------------------------------------------------

This will ensure that whenever the hero moves to any of the places from where the mountain is visible, the `shadow_mountain` is sure to follow. However, as the rules are executed _after_ the hero already has moved, a better strategy might be to make the `shadow_mountain` '`silent`', i.e. to have no description. Instead, the description of it should then be embedded in the description of the adjacent locations. Yet, another possibility would be to move the pseudo-object around using statements in the exits, like

[source,alan]
--------------------------------------------------------------------------------
The scenic_vista IsA location Name Scenic Vista
  Exit east To path
    Does
      Locate shadow_mountain At path.
  End Exit east.
End The scenic_vista.
--------------------------------------------------------------------------------

Regardless of which of these strategies you chose, you need to take care that the shadow object is not present when the real object is. In this particular case, it should not be moved to the hills.



=== The Melody

To allow the player to 'whistle the melody' for example, there are two different tactics that can be applied. One choice is to make the melody an `entity` (or some subclass thereof that you have defined), because, as we have seen, those can be manipulated from everywhere:

[source,alan]
--------------------------------------------------------------------------------
The melody IsA entity ...
Syntax 'whistle' = 'whistle' (m) ...
--------------------------------------------------------------------------------

The other route would be to make it an actual `object`. In this case the syntax for the whistle verb would need to indicate omnipotence, meaning that the player can refer to instances (even those inheriting from `object`) to be used as parameters even from afar.

[source,alan]
--------------------------------------------------------------------------------
The melody IsA object ...
Syntax 'whistle' = 'whistle' (m)! ...
--------------------------------------------------------------------------------

The melody then does not have to be reachable, near or even be at any location at all, for the player to be able to refer to it.

In both cases you would most likely need to restrict the parameters for the syntax so that the player can't 'whistle the chair'. Which of the two strategies you would chose greatly depends on things like:

* are there many things that this applies to (many 'melodies', perhaps)?
* should the player be able to manipulate this instance in other ways?
* do you need many different entities for various purposes?


== Using Events as Functions

................................................................................
<to be supplied>
................................................................................



== Structure

A good thing to do when designing an interactive fiction story is to separate the geography from the story. In Alan, you can use the import facility to structure your Alan source. One approach could be to place the description of each location in a separate file together with any objects that could be considered part of the scenery or at least is not only a tool in a puzzle. These files can then be included in a '`map`' file, which in turn is included by the top-level file.

The story line can be divided into files too, one for each `scene`. A scene being comments describing the important things that are suppose to happen, any prerequisites and objects, events, rules etc. which are specific for this part of the story.

This strategy will both give you a better structure of your adventure as well as help you design a better story, much like the storyboarding technique used in making movies or plays.



== Debugging

Occasionally your Alan code is flawed and you really can't understand what is actually happening. To aid in discovering which part of your code is run when, the interpreter Arun incorporates some features for debugging. There are a few debugging switches available when starting the interpreter from the command line:


// FIXME: Find a way to style option on the left in bold.
................................................................................
-c       Log the commands input by the player
-l       Log a complete transcript of the game
-t<n>    Enable trace mode (<n> = level 1,2,3 or 4)
-d       Start the* debugger
................................................................................


[NOTE]
================================================================================
None of the above switches can be used unless the adventure was compiled with the debug option set (see <<Options>>).
================================================================================



=== Command Logs and Game Transcripts

For various purposes, such as debugging, an actual log of the player commands can be handy. Such a log is created if the option `-c` is given to the interpreter when starting a game. The log files are created in the directory, which was current when the interpreter was started, the name of the log file will begin with the game name and have the extension *.log*.

A command log can on some systems be used as input to the interpreter, and thus automate the execution of the exact player experience.

You can only activate one of the logs in a single session.



=== Interpreter and Instruction Trace

Trace mode can also act as an aid in debugging. Level 1 will print information about every invocation of the instruction interpreter, making it easier to see which parts of the code are being executed.

Trace level 2, single instruction trace, will also trace every single Acode instruction. The Acode is based on a stack machine but single instruction trace will not show all stack operations. Level 3 shows the execution of these also. Level 4 dumps the content of the stack for every instruction.



=== Debug mode

Finally, and usually most useful, there is the debug mode. If the interpreter is started with this option, it will execute the start up sequence and then prompt for a debug command with


// FIXME: The actual prompt is "adbg>" !!!!
abug>
[EXAMPLE,role="gametranscript"]
================================================================================
abug&gt;
================================================================================



=== Using the Debugger

Abug may also be entered during the execution of an adventure. To do this you issue the single player command (type it at the game prompt)


[EXAMPLE,role="gametranscript"]
================================================================================
&gt; debug
================================================================================



The game must have been compiled with the debug option or the command will be sent to the game which probably does not recognize it.

Typing a question mark or '`help`' in response to the debug prompt will give a brief listing of the commands available in Abug:


// FIXME: Current ADBG Help has changed slightly.
................................................................................
break [file:[n]]   -- set breakpoint at source line [n] in [file]
delete [file:[n]]  -- delete breakpoint at source line [n] in [file]
files              -- list source files
events             -- show events
classes            -- show class hierarchy
instances [n]      -- show instance(s)
objects [n]        -- show instance(s) that are objects
actors [n]         -- show instance(s) that are actors
locations [n]      -- show instances that are locations
trace ('source'|'section'|'instruction'|'push'|'stack')
                   -- toggle various traces
next               -- execute to next source line
go                 -- go another player turn
exit               -- exit debug mode and return to game, enter again using 'debug' as input
x                  -- d:o
quit               -- quit game
................................................................................


[NOTE]
================================================================================
Any command may be abbreviated as long as it is unambiguous. Typing 'b' for 'break' will work, for example.
================================================================================



The display commands, `actors`, `locations`, `objects` and `events`, may optionally be followed by a number. Abug will then display detailed information about the entity requested, such as values of attributes, its present location etc. Currently there is no way to modify anything using Abug.

You can run the adventure to the next source line by using the `next` command. If the source file is available, the interpreter will also show the source line.

Breakpoints can be set on a source line. Enter the `break` command followed by the number of the source line. Alan allows the source to be separated into multiple files, so the interpreter always indicate which file the source line is in, e.g. when hitting a breakpoint or stepping to the next source line. When setting a breakpoint the current file is always assumed. You can currently set a breakpoint in another source file by preceding the line number with the file name delimited by a colon.

Breakpoints can be deleted. The `delete` command without a line number will remove any breakpoint at the current line. You can specify which breakpoint to delete by giving the line number (and optionally the file name).


[NOTE]
================================================================================
The debugger knows on which source lines it is possible to place a breakpoint. If you attempt to put a breakpoint at some line where it is not possible, it will attempt to place one a line which is numerically higher but as close a possible. This will sometimes cause a breakpoint to be placed in a context that will not be what you expected.
================================================================================



The trace command and its options corresponds to the types of traces described in the section on <<Command Logs and Game Transcripts,_Command Logs and Game Transcripts_>> above.

Wherever different output styles are available, e.g. in GLK based interpreters like WinArun, the Alan debugger tries to use them to distinguish the debugger output from the output of your game by using the pre-formatted style (see the section on styles in <<Output Statements>>).

// FIXME: The transcript styling mentioned in the next paragraph isn't applied
//        in the actual transcript of the book; will need to work out manually
//        what should be what.

The following is a short excerpt from a debugging session (user input in italics, game input/output in bold face):


// FIXME: Styles for player input, etc.
................................................................................
<Arun, Adventure Interpreter version 3.0beta1 (2010-12-19 16:26:05)>

<Version of 'saviour.a3c' is 3.0beta1>

<Hmm, this is a little-endian machine, fixing byte ordering.... OK.>

<Hi! This is Alan interactive fiction interpreter Arun, version

3.0beta1 !>

adbg> _n_

adbg: Stepping to saviour.alan:1346

<01346>: "$pWelcome to the game of SAVIOUR!$pIn this game your mission

adbg> _n_

Welcome to the game of SAVIOUR!

<<Game output deleted for breivity>>

adbg: Stepping to saviour.alan:1354

<01354>: Show 'logo.png'.

adbg> _n_

adbg: Stepping to saviour.alan:1355

<01355>: "$iVisit the Alan Home Pages at:"

adbg> _break 1357_

Line 1357 not available, breakpoint instead set at saviour.alan:1358

<01358>: Visits 2.

adbg> _g_

Visit the Alan Home Pages at:

http://www.alanif.se

adbg: Breakpoint hit at saviour.alan:1358

<01358>: Visits 2.

adbg> _n_

Outside The Tall Building

adbg: Stepping to saviour.alan:318

<00318>: "To the north is a tall ancient building with a large entrance.

adbg> _n_

To the north is a tall ancient building with a large entrance. On the top there is a clock tower. Most of the windows in the building are broken, and a sign with three oval objects are hanging lose from the wall.

*> _north_*

adbg: Stepping to saviour.alan:325

<00325>: Score 5.

adbg> _?_

Alan 3.0beta1 -- Adventure Language System (2010-12-19 16:26)

ADBG Commands (can be abbreviated):

help -- this help

? -- d:o

break [file:[n]] -- set breakpoint at source line [n] in [file]

delete [file:[n]] -- delete breakpoint at source line [n] in [file]

files -- list source files

events -- show events

classes -- show class hierarchy

instances [n] -- show instance(s)

objects [n] -- show instance(s) that are objects

actors [n] -- show instance(s) that are actors

locations [n] -- show instances that are locations

trace ('source'|'section'|'instruction'|'push'|'stack')

-- toggle various traces

next -- execute to next source line

go -- go another player turn

exit -- exit to game, enter 'debug' to get back

x -- d:o

quit -- quit game

adbg> _trace section_

Section trace on.

adbg> _n_

<EXIT north[1] from Outside The Tall Building[4], Moving:>

<ENTERED in class entity[1] is empty>

<ENTERED in class location[2] is empty>

<ENTERED in instance Hall[5] is empty>

Hall

adbg: Stepping to saviour.alan:332

<00332>: "Inside the entrance is a hallway full of dust and pieces of

adbg> _instances_

Instances:

1: #nowhere

2: pseudowords (container), at #nowhere [1]

3: nowhere

4: Outside The Tall Building

5: Hall

6: door, at Hall [5]

7: Stairs

8: cellar

9: rats, at cellar [8]

10: store

11: spool of computer tape, at store [10]

12: First Floor

13: old book, at First Floor [12]

<<list abbreviated>>

adbg> _instance 13_

The old book [13] IsA object[4]

Location: at First Floor [12]

Attributes:

Takeable[2] = 1

Readable[3] = 1

openable[4] = 0

startable[5] = 0

examinable[6] = 1

adbg> _g_

Inside the entrance is a hallway full of dust and pieces of the

ceiling has fallen to the floor. At the west end is a staircase, and to the south is the exit. To the east is a folding door. It is closed.

*> _west_*

<EXIT west[3] from Hall[5], Moving:>

<ENTERED in class entity[1] is empty>

<ENTERED in class location[2] is empty>

<ENTERED in instance Stairs[7] is empty>

Stairs

You are at the landing of an old staircase. It seem steady enough to walk in, but be careful if you are going to use it. There is a passage leading up, and another leading down into a dark cellar. To the east is the hallway. A strange smell emerges from below.

*> _up_*

<EXIT up[5] from Stairs[7], Moving:>

<ENTERED in class entity[1] is empty>

<ENTERED in class location[2] is empty>

<ENTERED in instance First Floor[12] is empty>

First Floor

The landing on the first floor is as dirty as all the others. Meters and meters of old cables are laying around, leading into a room to the east. The stairs leads up and down. They still seem alright. Through the dirty windows the barren field outside the building can be seen. Almost completely covered by dust, there is an old book laying on the floor here.

*> _take book and read it_*

<VERB 21, in parameter object(#1)=old book[13], inherited from object[4], CHECK:>

<VERB 21, in parameter object(#1)=old book[13], inherited from object[4], DOES:>

Taken.

<VERB 5, in parameter object(#1)=old book[13], inherited from object[4], CHECK:>

<VERB 5, in parameter object(#1)=old book[13], DOES:>

As you carefully try to open the book it falls apart into dust and falls

to the floor through your fingers.

*> _debug_*

adbg> instance 13

The old book [13] IsA object[4]

Location: at nowhere [3]

Attributes:

Takeable[2] = 1

Readable[3] = 1

openable[4] = 0

startable[5] = 0

examinable[6] = 1

adbg> _trace instruction_

Single instruction trace on.

adbg> _n_

*> _north_*

++++++++++++++++++++++++++++++++++++++++++++++++++

1dbd: PRINT 10037, 22 "You can't go that way."

1dbe: RETURN

--------------------------------------------------

*> _west_*

++++++++++++++++++++++++++++++++++++++++++++++++++

1dbd: PRINT 10037, 22 "You can't go that way."

1dbe: RETURN

--------------------------------------------------

*> _east_*

<EXIT east[2] from First Floor[12], Moving:>

<ENTERED in class entity[1] is empty>

<ENTERED in class location[2] is empty>

<ENTERED in instance office[14] is empty>

++++++++++++++++++++++++++++++++++++++++++++++++++

e82: LINE 0, 0

e85: PRINT 3479, 6 "Office"

e86: RETURN

--------------------------------------------------

++++++++++++++++++++++++++++++++++++++++++++++++++

e89: LINE 0, 598

adbg: Stepping to saviour.alan:598

<00598>: "In front of you is a deserted office area. Desks and chairs

adbg> _g_

e8c: PRINT 3485, 404 "In front of you is a deserted office area. Desks and chairs are piled up in one corner. The ventilation system has partly fallen to the floor, tearing part of the ceiling down with it. Under the twisted tubing a couple of old coffee makers are crushed to pieces. One shelf, having some kind of lettering, no longer readable, is thrown to one side, and another is still standing in a corner, full of dust."

e8d: RETURN

--------------------------------------------------

++++++++++++++++++++++++++++++++++++++++++++++++++

ec3: LINE 0, 616

ec6: ATTRIBUTE 15, 17 =0

ec7: NOT FALSE =TRUE

ec8: IF TRUE

ecb: LINE 0, 617

ece: PRINT 3711, 43 " There is a ladder laying on the floor here."

ecf: ELSE

:

ee1: RETURN

--------------------------------------------------

*> _look_*

<VERB 19, GLOBAL, DOES:>

++++++++++++++++++++++++++++++++++++++++++++++++++

71c: LINE 0, 199

71d: LOOK

++++++++++++++++++++++++++++++++++++++++++++++++++

e82: LINE 0, 0

e85: PRINT 3479, 6 "Office"

e86: RETURN

--------------------------------------------------

++++++++++++++++++++++++++++++++++++++++++++++++++

e89: LINE 0, 598

e8c: PRINT 3485, 404 "In front of you is a deserted office area. Desks and chairs are piled up in one corner. The ventilation system has partly fallen to the floor, tearing part of the ceiling down with it. Under the twisted tubing a couple of old coffee makers are crushed to pieces. One shelf, having some kind of lettering, no longer readable, is thrown to one side, and another is still standing in a corner, full of dust."

e8d: RETURN

--------------------------------------------------

++++++++++++++++++++++++++++++++++++++++++++++++++

ec3: LINE 0, 616

ec6: ATTRIBUTE 15, 17 =0

ec7: NOT FALSE =TRUE

ec8: IF TRUE

ecb: LINE 0, 617

ece: PRINT 3711, 43 " There is a ladder laying on the floor here."

ecf: ELSE

:

ee1: RETURN

--------------------------------------------------

71e: RETURN

--------------------------------------------------

*> _q_*
................................................................................


In the instruction trace, lines of '`+`' characters indicates the start of interpretation, thus they can be present inside other single step traces (like the `Look` in the example above). Lines of dashes, indicates the return from one such level of interpretation.

