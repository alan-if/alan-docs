// *****************************************************************************
// *                                                                           *
// *                          3. Language Reference                            *
// *                                                                           *
// *****************************************************************************

// =============================================================================
// CUSTOM SUBSTITUTIONS-ATTRIBUTES DEFINITIONS
// =============================================================================
// These custom attributes are used for special characters substitutions in
// tables, as a workaround for the problems with the Asciidoctor-fop PDF
// backend, which is not able to represent certain characters as expected:
//
//    {darr}  --> Downwards arrow
//    {vdots} --> Vertical ellipsis
//
// =================
// HTML Backend Only
// =================
ifdef::backend-html5[]
// WIDE-HEADED DOWNWARDS MEDIUM BARB ARROW (U+1F873): 'ðŸ¡³'
:darr: &#x1F873;
// VERTICAL ELLIPSIS (U+22EE): 'â‹®'
:vdots: &#x22EE;
endif::[]
// ==================
// All Other Backends
// ==================
ifndef::backend-html5[]
// Downwards Arrow (U+02193): 'â†“'
:darr: &#x02193;
:vdots: :
endif::[]
// -----------------------------------------------------------------------------

= Language Reference

This chapter describes the Alan language in detail.
Within each section, grammar rules are used to precisely define allowed formats.
A description of how these rules should be interpreted can be found in <<Language Grammar>>.


== General Rules

The Alan language is divided into syntactic components of different kinds.
Each component may be composed of text and/or other components.
A component is terminated by a period or full stop (`.`).
This indicates that that component is complete.
Some components start with a keyword or initial phrase, such as `Description` or `Exit east To kitchen`.
If it is to be followed by further components, such as statements or output strings, that keyword or phrase should normally _not_ be followed by a period, but by its continuing components.
For example:

[source,alan]
--------------------------------------------------------------------------------
Exit east to Kitchen.
--------------------------------------------------------------------------------

But:

[source,alan]
--------------------------------------------------------------------------------
Exit east To Kitchen
  Check kitchenDoor Is open
  ...
End Exit.
--------------------------------------------------------------------------------


Note that the first is terminated, but the second example is continued with a `Check`, and not terminated until the `End Exit`.



== An Adventure

An adventure starts with an (optional) set of (((OPTION))) ``Option``s (see <<Options>>) followed by a set of declarations.
(((BNF, rules of, adventure)))

[source,bnf]
--------------------------------------------------------------------------------
adventure = {option} {declaration} start_section
--------------------------------------------------------------------------------

According to the rules it is actually possible to have no declarations at all (as indicated by the curly braces) but there would be no adventure without a single location, right?
So, in practice you'll need at least one declaration.

The declarations constitute the major part of the adventure.
The declarations can be declared in any order and repeated freely, and are of many different possible types.
(((BNF, rules of, declaration)))

[source,bnf]
--------------------------------------------------------------------------------
declaration = import
            | class
            | instance
            | addition
            | syntax
            | verb
            | rule
            | synonyms
            | event
            | messages
            | prompt
--------------------------------------------------------------------------------

The adventure source text must end with a (((START, section))) `Start` section.
(((BNF, rules of, START section)))

[source,bnf]
--------------------------------------------------------------------------------
start_section = 'START' where '.' statements
--------------------------------------------------------------------------------

It indicates where the hero is when the game starts but can also be used to set things up, welcome the player and so on.
The `Start` section is mandatory.

[source,alan]
--------------------------------------------------------------------------------
Start At bedroom.
  Schedule alarm_clock After 2.
    "Slowly you come to your senses, your numb limbs
     starting to feel the blood flowing through them..."
--------------------------------------------------------------------------------

You can look up the meaning of the rules "*WHERE*" and "`statement`" elsewhere in this chapter.



== Options

``Option``s (((OPTION))) define things concerning the overall behaviour of the generated Alan adventure.
As is implied they are optional and are only required if you need to change the value of an option from its default setting.
An option follows the grammar:
(((BNF, rules of, OPTION)))

[source,bnf]
--------------------------------------------------------------------------------
options = 'OPTIONS' {option}

option = id '.'
       | id id '.'
       | id integer '.'
--------------------------------------------------------------------------------


The example below illustrate how options may be written, following the above rules.

[source,alan]
--------------------------------------------------------------------------------
Options
    Debug.
    Language Swedish.
    No Pack.
    Width 128.
--------------------------------------------------------------------------------

The available options are:

[[table-of-options]]
.Adventure Settings via OPTION
[cols="<20m,<40d,<40d",options="header"]
|===============================================================================
| Option name | Possible values | Default value

| Language
| `English`, `Swedish`, ``German``footnote:[Other non-English languages may be supported in the future depending on demand.]
| `English`

| Width
| 24-255
| 80footnote:[Width and Length are always overridden by the actual terminal or window size, if that can be determined, dependent on the interpreter used. If not, the value of the option is used.]

| Length
| 5-255
| 24

| Pack
| Boolean (on or off)
| Off (`No Pack`)

| Debug
| Boolean (on or off)
| Off (`No Debug`)
|===============================================================================

The `Language` option specifies the language in which the adventure is assumed played, and selects different default message texts.
Alan is primarily designed for adventures in the English language, but it is also possible to write adventures in other languages.
To make this possible, the default messages output by the interpreter may be generated in different languages.
It is completely possible to write in other languages, but then you must customize all the message texts.
See <<Run-Time Messages>>, <<Input Response Messages>>, for a complete list of such messages.

The Alan compiler and interpreter will always allow multinational (((multinational characters))) 8-bit characters as input and the default messages are generated for 8-bit ((character sets)), internally representing national characters according to the ISO multinational character set (ISO8859-1) requiring 8 bits.
On output, this is converted to the native character set of the machine (whenever possible).
This means that portability between platforms should be good even for text containing multinational (non-ASCII) characters.

`Width` specifies how long the lines the interpreter outputs should be (formatting is automatic!).
The `Length` option will instruct the interpreter on how many lines to show on the screen without any player interaction (*<More>*).
These values are only used if the interpreter itself cannot get the actual values.

The `Pack` option will cause the compiler to compress the texts to occupy less space.
As a bonus, this also makes it impossible for the player to cheat by dumping the adventure code file.
As a minor drawback, it does make the execution of the adventure a bit slower (noticeable only on some very old, smaller, computers).

In order to allow debugging of the generated adventure (see <<Debugging>>), the `Debug` option must be turned on.
This may also be performed using the debug compiler switch (see <<Compiler Switches>>).



== Types

The Alan language handles information in bits, values.
Each such bit of information, or data, is of a specific type.
Alan is a strictly typed language, which means that assignment, comparisons and other statements will require that rules concerning the compatibility between such values are not broken.

In the Alan language, you cannot explicitly state the type of a value.
Instead, this is inferred from how values are used, e.g. the initial value of an attribute or the restrictions put on a `Syntax` parameter.



=== Basic, Simple and Compound Types

The ((basic types)) of values available in the Alan language are:

* *Integer* -- e.g. a simple integer constant, a reference to an integer typed attribute or a numeric expression using any of the mathematical operators.
* *String* -- e.g. a string constant or a reference to an attribute typed as a string.
* *Boolean* (_true_ or _false_) -- comparisons yield Boolean values, Boolean attributes.

Two other simple types are available:

* *Instance* -- a reference to an instance or an attribute typed as a ((reference attribute)) that refers to an instance.
* *Event* -- a reference to an `Event` or an attribute typed as a ((reference attribute)) that refers to an event.

There is one compound type in the Alan language:

* *Set* -- an unordered list of values.


=== Instance Type

Every time a reference to an instance is made, it can be considered an expression of ((*instance* type)).
In these cases, the class of the instance also often matters.
E.g. assigning a ((reference attribute)) can only be made if the new value refers to an instance that belongs to the same class or a subclass of the initial value of that attribute.

Some types of expressions return a value referring to an a class or instance in the Alan source.
Examples include an identifier bound to a parameter allowing instances and a ((reference attribute)).

=== Event Type

`Event` is a set of statements that can be scheduled to execute with a specified delay.
Each reference to an identifier of an `Event` is of course of the (((EVENT, type))) *Event* type.
``Event``s can be referenced by attributes and any reference to such an attribute is of *Event* type.

Expressions of *Event* type can be used in `Schedule` and `Cancel` statements.



=== Set Type


A Set is a collection of values that may be referenced as a single value, but also investigate, added to and removed from.
An example might be a set of cards in a dealt hand, the set of spells that the hero have learned, or the set of numbers guessed so far.

The order of elements in the set is not specified.
Each member can only occur once in the same set, but a member can occur in multiple sets.
You could for example include one set of numbers (integers) in one set and another set of numbers in another set.
It is then possible to investigate the sets and remove all members that are members in both.

The (((SET, type))) *Set* type is a compound type since it is not complete without a member type.
You can only include members in a set if the type compatibility rules allow it.
A Set may include members that are instances or integers.

If the Set includes instances, the subclass compatibility rule applies.
All members in the set must inherit from the same class.
See the section on type compatibility below.



[NOTE]
================================================================================
The fact that an instance is in a Set does not affect the instance.
In fact, there is no way to find out in which Sets, if any, a particular instance is included.
In particular, it does not affect the instances location.
================================================================================




=== Type Compatibility

Assignment and comparisons between values requires the values to be (((compatible types))) compatible.
The three basic types (integer, string and Boolean) are only compatible with themselves.

Values of the Instance type can be compared without restriction, except that there is no notion of lesser or equal, so only equality can be tested.
Assignment can be made if the new value is of the same class, or of a subclass, as the attribute or variable that receives the value.
This class is normally inferred from the initial value of the declaration.

For example, a ((reference attribute)) (an attribute referencing an instance) is inferred to be restricted to instances of the class of its initial value.
Any subsequent change of the attribute (setting it to refer to another instance) requires that the new instance be of the same class or a subclass thereof.

These rules ensure that attribute references and other properties are always retained during the execution of the whole game.
Thus, it will never cause a run-time error on the player.



=== Type Requirements

Some statements require their arguments to be of a specific type.
This is enforced by the compiler.
The compatibility rules apply here also, given that the required type is given by the statement itself.

Examples include the conditional (((IF, statement))) `If` statement, that requires a Boolean value (or expression) to test, and the (((USE, statement))) `Use` statement, which requires references to instances that are subclasses of the predefined class `actor`.




== IMPORT

The source text for a large adventure might become entangled and complex.
A way to break up a large text is to divide it into separate files.
Each such file can then be imported into the main source using the (((IMPORT, statement))) `Import` statement.
(((BNF, rules of, IMPORT)))

[source,bnf]
--------------------------------------------------------------------------------
import = 'import' quoted_identifier '.'
--------------------------------------------------------------------------------

The quoted identifier is the name of the file to import (see <<Filenames>>).
The `Import` may be placed anywhere in a file where a declaration can occur, and the effect will be the same as if the contents of the named file had been inserted at that position in the file.
``Import``s may be nested, so an imported file may in turn import more files, without limits.

An imported file is searched for first in the current directory and then in any of the directories indicated using the `Import` switch as described in <<Compiler Switches,_Compiler Switches_>>, this search is performed in the same order as the `Import` switches occurred on the command line.

The `Import` statement is the way to use the Standard Library (or a library of your own design).
Place the library files in a directory where the compiler will find them, either in the same directory as your other source files or somewhere else (see <<Compiler Switches>> on how to make the compiler look in more folders than just the one where the main source file resides).
In your source you would refer to the main file of such a library by:


[source,alan]
--------------------------------------------------------------------------------
Import 'library.i'.
--------------------------------------------------------------------------------

Another use is for dividing your own source into multiple files to make them easier to handle:

[source,alan]
--------------------------------------------------------------------------------
Import 'harbor.i'.
Import 'city.i'.
Import 'desert.i'.
Import 'actors.i'.
Start At city.
--------------------------------------------------------------------------------


== Classes

Classes (((classes))) are definitions of templates of instances.
That means that a class declaration only describes instances, and does not add anything to your game in itself.
Instead, you have to create an instance of the class to make it available in the game (see <<Instances,_Instances_>> below).
(((BNF, rules of, EVERY)))
(((BNF, rules of, class declaration)))
(((class, syntax for)))

[source,bnf,subs="macros"]
--------------------------------------------------------------------------------
class = 'EVERY' id
            [inheritance]
            {property}
        'END' 'EVERY' [id] ['.']
--------------------------------------------------------------------------------

The *id* is the identifier used by the author to refer to this class throughout the source code, e.g. when referring to it in the inheritance clause of other classes and instances.

The *properties* are described in <<Properties>>.



=== Inheritance

Every instance must inherit (((inheritance))) from a class (see <<Inheritance and Object-Orientation>>).
Furthermore, user-defined classes must also inherit from other classes.
A class or an instance inheriting from a class will get all properties of that class.
All properties explicitly declared in a class or instance inheriting from another class will extend, override or complement those properties as specified in the original, parent, class.
This way, you can easily create new classes by extending existing ones.

You specify which class another class or an instance inherits from using a clause following the grammar:
(((BNF, rules of, ISA))) (((BNF, rules of, inheritance)))

[source,bnf]
--------------------------------------------------------------------------------
inheritance = 'ISA' id ['.']
--------------------------------------------------------------------------------


For example:

[source,alan]
--------------------------------------------------------------------------------
The door IsA object ...
--------------------------------------------------------------------------------

and

[source,alan]
--------------------------------------------------------------------------------
Every coin IsA treasure ...
--------------------------------------------------------------------------------



== Instances

The most important part of an Alan game source is probably the declarations of ((instances)).
Instances are the ``object``s, ``location``s, ``actor``s and other ``thing``s that fill your game universe.
The player traverses and interacts with these in his quest to negotiating your game.
(((BNF, rules of, THE))) (((BNF, rules of, instance declaration)))

[source,bnf]
--------------------------------------------------------------------------------
instance = 'THE' id
              [inheritance]
              {property}
           'END' 'THE' [id] ['.']
--------------------------------------------------------------------------------


Every instance must inherit from a class (see <<Inheritance,_Inheritance_>> above) keeping all properties of that class.
Each inherited property can be amended or overridden by specifying it in the declaration of the instance, and new attributes, ``Exit``s and ``Script``s can be added in the same way as in class declaration.

Exactly the same rules for declaring properties apply to instances.
The only difference is that an instance will actually show up in the game when it is run.
Remember also that properties declared in an instance are not common to any other instances (unless the declaration overrode the value of a class property).

Instances inheriting, directly or indirectly, from the predefined classes `thing`, `entity`, `object`, `location`, `actor` and `literal`, are subject to special semantics (((semantics, of predefined classes))) and restrictions.

Here are two examples of instance declarations following the rules above:

[source,alan]
--------------------------------------------------------------------------------
The red_ball
  IsA object
  At bedroom
  Name red ball
  Is hidden.
  Description
    If This Is Not hidden Then
      "An ordinary ball is laying under the bed."
    End If.
  Verb roll
    Does
      "You roll the ball a bit. Nothing exciting happens."
  End Verb.
End The red_ball.

The mr_brown
  IsA actor
  Name Mr Brown
  Article "".
  Pronoun him.
  Is working.
  Description "Mr. Brown is here, working at his desk."
End The mr_brown.
--------------------------------------------------------------------------------


// @FIXME @thoni56:
//    "... as described by the EARLIER BOX."
//  Which box is that? There doesn't seem to be any boxes in the examples.


In these examples the source lines between `The` and `End The` all declare various properties that we will learn more about in <<Properties>>.
The rest of the lines are fairly easy to match up to the rules of the Alan language as described by the earlier box.


All capitalized words in the examples above are keywords in the Alan language (see <<table-of-keywords>> for a complete list), the rest are author defined words or identifiers (with the exception of the words `object` and `actor`, which are identifiers predefined to be special classes).



=== Entities

The base class `entity` (((ENTITY, predefined class))) represents the lowest denominator of all instances.
All other predefined classes inherit from `entity`.
So adding a property to `entity` will add it to every instance.

Entities cannot have an initial location, nor can they be located anywhere.
On the other hand, they can be considered to be available everywhere.
They are not described when encountered.
They can only be shown by explicitly executing a `Describe` statement.

So, if you want an instance to always be available but invisible, create an instance of `entity`.
It is also possible to create subclasses of `entity`.
Instances of such classes will follow the same rules.



=== Things

`Thing` (((THING, predefined class))) is a predefined subclass of `entity` that adds the property of having a location.
This means that they can have an initial location and be located at locations and into containers.
They will, however not show up in descriptions or listings, but the player can refer to and interact with them.
They can be described by explicitly executing a `Describe` statement.

Creating an instance of `thing` is a good choice if you want an invisible instance that should only be available at particular locations, or under specific circumstances.



[NOTE]
================================================================================
Note that a `thing` can be put in a container, but that container will not show any visible traces of that thing.
It will be rendered as empty if listed.
The `thing` is however subject to other effects of being part of a container, such as the removal rules and selection by a random selection of items in the container.
See <<RANDOM Values,_RANDOM Values_>> for a description of random selections of container items.
================================================================================




=== Objects

Objects (((OBJECT, predefined class))) are instances inheriting directly or indirectly from the predefined class `object`.
Objects are all the things that can be manipulated by the player.
They can be picked up, examined and thrown away (if the author has allowed it).
In addition to the properties inherited from `thing`, any present object will by default, be described when the player enters a location or otherwise encounters it.



=== Actors

The predefined class `actor` (((ACTOR, predefined class))) is intended for providing so called NPCs, non-player characters, in your game.
Like the player, they can move around but to do this they have to be scripted, i.e. programmed with some behaviour using scripts.

An instance inheriting from the `actor` class will be described when encountered.
Actors can be located, as can any `thing`, but not be inside a container.
In addition, they can have scripts.

Actors also exhibit special behaviour when they are described, e.g. when they are encountered.
If an actor (((ACTOR, description))) is executing a `Script` with a `Description`, (see <<SCRIPTs,_SCRIPTs_>>) this description will be used instead of the one declared in the description clause.

[source,alan]
--------------------------------------------------------------------------------
The kirk IsA actor Name Captain Kirk At control_room
  Has health 25.
  Container
    Header "Kirk is carrying"
    Else "Captain Kirk is not carrying anything."
  Description
    "Your superior, Captain Kirk, is in the room."
End The kirk.

The george IsA actor
  Name George Formby
  Description
    "George Formby is here."
  Script cleaning.
    Description
      "George Formby is here cleaning windows."
    Step ...
  Script tuning.
    Description
      "George Formby is tuning his ukelele."
  Step...
:
--------------------------------------------------------------------------------




==== The HERO

There is one very special actor, the `hero`, ((("HERO, the"))) which represents the player.
This actor is always pre-declared with some basic properties, so you don't have to declare it.
But if necessary, it may be re-declared in the same way as any other actor.

One situation when this is required is if you need attributes on the hero, such as "`sleepy`" or "`hungry`".
A declaration like the following can then be used:

[source,alan]
--------------------------------------------------------------------------------
The hero IsA actor
  Name me
  Is Not hungry.
  Verb examine Does
    If hero Is hungry Then
      "Examining yourself reveals a poor, hungry soul."
    Else
      "You find nothing but a poor beggar."
    End If.
  End Verb examine.
End The hero.
--------------------------------------------------------------------------------

The hero is predefined with a simple `Container` property taking ``object``s with no `Limits`.
It seems natural to use that as the "`inventory`" of the player, the storage for everything the player is picking up and carrying around.
You will probably need to handle carried items in some manner, and the pre-declared container is one suggestion.
You can also redeclare the `Container` property of the hero so that it suits your needs.



=== Locations

A `location` (((locations))) is a declaration of a place (a "`room`") in the game that (normally) can be visited by the player, and have objects lying around, etc.
In fact, the map of your game is a set of interconnected locations.
A location is any instance inheriting directly or indirectly from the predefined class `location`.
Inheriting from `location` implies the following semantic (((semantics, of locations))) properties:

* only locations can be visited by the player
* only locations may have the `Entered` clause
* things and locations may be located at locations
* ``Exit``s can only lead to locations and only locations can have ``Exit``s
* the `Start` location must be a `location`
* locations can't have `Container` properties
* ``Verb``s in locations are executed only when the hero is at that location

When a location is described (((DESCRIPTION, of locations))) (for example when entering it) it is presented with a heading (the location name), the description (in the `Description` clause) followed by descriptions of any present objects and actors not already, explicitly, described (using a `Describe` statement) in the description.

An interesting property of locations is that a location can be located at another, both initially and during run-time.
The result of having such ((nested locations)) is that all things present at the "`outer`" location are also present in the inner.
This can be used in multiple levels to allow access to sky, ground and other scenery items available at many locations at once.
It can also be used for grouping locations into sets of similar locations and for implementing vehicles.



=== Literals

The classes (((literals))) `literal`, `string` and `integer` cannot be instantiated explicitly.
Instead, you might say that they are implicitly instantiated when the player inputs a literal.
For example:

[example,role="gametranscript"]
================================================================================
&gt; turn dial to 12
================================================================================


The second parameter (see <<SYNTAX Definitions>>) in this player command is the integer 12.
This parameter is automatically considered an instance of the predefined class `integer`.


// @FIXME @thoni56:
// The following paragraph doesn't clarify enough the topic.

It is possible to add ``Verb``s to `literal` and its sub-classes.
This way it is possible to create verbs that take strings and integers as parameters.

// @TODO: Add example of adding verbs to literals!



== Properties

An instance or class can be given number of different ((properties)) by declaring them in the declaration of the class or instance.
(((BNF, rules of, properties))) (((property, syntax for)))

[source,bnf]
--------------------------------------------------------------------------------
property = initial_location
         | name
         | pronouns
         | attributes
         | initialization
         | description
         | articles
         | mentioned
         | container_properties
         | verb
         | script
         | entered
         | exit
--------------------------------------------------------------------------------


Attributes, exits, verbs and scripts can be repeated any number of times in the same declaration.
You cannot use the same identifier for more than one such property, e.g. you cannot declare two attributes with the same name.



=== Inheriting Properties

A property can be inherited (((inheriting properties, rules for))) from the parent of the class or instance.
It is not necessary to repeat the declaration in the inheriting class or instance if it should retain its inherited value.
Each inherited property may be amended or overridden by specifying it also in the declaration of the inheriting class or instance according to the following table.


.Properties Inheritance
[[table-of-properties-inheritance]]
[cols="s,<n",options="header"]
|===============================================================================
| Property | Inherited as

| Initial location
| Overridden

| Name
| Accumulated, the inherited names are appended at the end of the list of `Name` clauses

| Pronoun
| Overridden, each `Pronoun` clause inhibits inheriting pronouns from the parent class.

| Attribute values
| Overridden, attribute declarations using the same name as an inherited can give the attribute a different value but must match the type of the inherited.

  Accumulated, you can add further attributes in a class or instance.

| Initialize
| Accumulated. Inherited `Initialize` clauses are executed first so that the base classes may do their initialisation first.

| Description check
| Accumulated.

| Description
| Overridden.

| Articles & Forms
| Overridden.

| Mentioned
| Overridden. Also overrides names.

| Container
| Overridden, all clauses are overridden.

| Verb declarations
| Accumulated. `Verb` bodies are accumulated for verbs with the same name as the inherited.
  Use qualifiers (see <<Verb Qualification>>) if you don't want all of them to execute.

| Scripts
| Overridden, for same `Script` name.

| Entered
| Accumulated. `Entered` clauses in nested locations are executed from the outside in.
  `Entered` clauses in parent classes are executed first.
  So the first clause to be executed is the parent of an outer location.

| Exits
| Overridden, for same direction.
|===============================================================================

The table also show which properties are inherited separately from the parent.
E.g. you can override the `Description` but keep the description check, or even add another (since they are accumulated).
You cannot override the `Limits` of a container and keep the `Header` section since the `Container` property is overridden in its entirety.

In an inheriting class, you can also add new properties.
More attributes, ``Verb``s, ``Exit``s and ``Script``s can be added to those already present through the inheritance.

The properties available for use in classes, and thus also for instances, are described in detail in the following sections.
In general, all of these can be mixed freely, however, some semantic restrictions apply as to when a particular property is legal or not.



=== Initial Location

Where an instance will be located when the game starts is set using an optional *WHERE* clause.
If no such clause is used the instance will have no location.
An instance without location is not present (in the view of the player) in the game until it is moved somewhere by a `Locate` statement.
(((BNF, rules of, initial location)))

[source,bnf]
--------------------------------------------------------------------------------
initial_location = where
--------------------------------------------------------------------------------

Only the `At what` and `In what` forms of the *WHERE* construct (see <<WHERE Specifications>>) are allowed when describing the initial location of an instance.

[source,alan]
--------------------------------------------------------------------------------
The chest IsA object At treasury
...
--------------------------------------------------------------------------------

An instance inheriting from `location` cannot have an initial location that is `In` something, but it can be `At` some other location, creating a nesting of locations.



=== NAMEs


// @FIXME @thoni56:
//     That "AUTHOR NAME", and it use in this section, create more confusion
//     than clarity (especially later on in the text).
//     The original intention of distinguishing between the Id and the Name
//     gets lost in confused and confusing sentences.
//     Using something like "interal use/name/Id" instead of "author name"
//     might be better.



By default, the identifier ("`author name`") of an instance is also the name shown to the player, and by which he will be able to refer to it.
Normally you would want to override this with more elaborate and alternative names.
You can do that using the (((NAME, clause))) `Name` clause.
(((BNF, rules of, NAME)))

[source,bnf]
--------------------------------------------------------------------------------
name = 'NAME' id {id} ['.']
--------------------------------------------------------------------------------

The `Name` clause consists of a list of identifiers optionally followed by a full stop.

The identifiers given in the `Name` clause are used when the instance is presented to the player, and the player can use them in his commands to refer to the instance.
For example:

[source,alan]
--------------------------------------------------------------------------------
The south_door IsA object At south_of_house
  Name door
...
The south_of_house IsA location
  Name 'South of House'
...
--------------------------------------------------------------------------------

// @NOTE: [please, don't delete this note!]
//
//   Here I had to use the autogenerated anchor ID:
//       <<_words_identifiers_and_names>>
//   instead of the plain title:
//       <<Words, Identifiers and Names>>
//   because of the comma in the title (interpreted as custom text separator).
//   See Issue #1468 on this:
//   https://github.com/asciidoctor/asciidoctor/issues/1468#issuecomment-132378305

The use of a ((quoted identifier)) in the last example causes the name (((NAME, of locations))) to be a single string of text.
(See <<_words_identifiers_and_names>> for more details.)
This works fine for locations, since the player usually does not need to refer to them in his commands; but a more sophisticated mechanism is available for things which the player needs to interact with (i.e. things, objects and actors).

[source,alan]
--------------------------------------------------------------------------------
The chair3 IsA object
  Name little wooden chair
--------------------------------------------------------------------------------

// @FIXME: Don't use "author name" (See notes above)!!! use something else.

In this example, the name is a sequence of words.
The semantics of this declaration is that the word "`chair`" is a ((noun)) and "`little`" and "`wooden`" become (((adjective))) adjectives.
When the player wants to refer in a command to the object with the author name (identifier) `chair3`, he may use just "`chair`" if it's the only accessible object with "`chair`" as its noun, or he may distinguish between multiple chairs by also providing one or more adjectives to be more precise about which chair he means.



// @FIXME: Don't use "author name" (See notes above)!!! use something else.

[NOTE]
================================================================================
The `Name` clause hides the author name, so in the example, the player will not be able to use `chair3` to refer to the instance.
================================================================================

[NOTE]
================================================================================
An explicit `Mentioned` clause will override the names for presenting the instance.
================================================================================


It is possible to give an instance multiple names (((NAME, multiple names))) by listing a number of `Name` clauses.
Each clause will define adjectives and a noun, as described above.
As a result, the player can use any of those names to refer to the object.
For example:

[source,alan]
--------------------------------------------------------------------------------
The rod IsA object At grate
  Name rusty rod
  Name dynamite
  ...
--------------------------------------------------------------------------------


This would allow the player to refer to the object using either '`rusty rod`' or '`dynamite`'. (Or, as a side effect, even '`rusty dynamite`'.)
The first `Name` clause is used for building a default description, if necessary (see <<DESCRIPTION>>).

The letter case used in the original words is preserved in the adventure output, but player input will always be matched without taking into account letter case (i.e. case-insensitively).
This allows you, for example, to give capitalized names to people actors, which would then be shown correctly in the output.




==== Inheriting Names

Names can of course be (((NAME, inheriting names))) inherited.
This is done in an additive way so that any names inherited are appended to the `Name` clauses in the declaration.
This ensures that the class or instance itself can control the primary name (the first `Name` clause).
Furthermore, this has the effect that an instance inheriting from a class defining a `Name` can also be referred to using the inherited name(s).
Here is an example with fruits:

// @NOTE: Changed "mcintosh" to "McIntosh", and "gravensteiner" to "Gravensteiner",
//        because it's a proper name of the fruit! Also, the reader has just
//        learned about letter casing preservation in NAMEs, so it's a good time
//        to put it into practice in the examples!

[source,alan]
--------------------------------------------------------------------------------
Every fruit IsA object Name fruit ...
Every apple IsA fruit Name apple ...
Every pear IsA fruit Name pear ...
The Gravensteiner IsA apple ...
The McIntosh IsA apple ...
--------------------------------------------------------------------------------

In this example, both pear and apple can be referred to using the word "`fruit`".
Both the Gravensteiner and the McIntosh would be apples, not only by name, but also by all other properties of apples.




==== Displaying Instances


// @TODO: It might be good to insert here a flowchart resuming how Alan decides how
//        to print out an instances in the output. It could make it easier to memorize
//        the rules, and how defaults, fallbacks and customization interact.


When an instance is to be shown to the player, (((instance, displaying))) it must be displayed in form of text.
An instance can be printed in several different ways, it can be described or only mentioned.
A description of an instance is a complete and usually more elaborate description of it (see <<DESCRIPTION>>).
However, often an instance must be mentioned as a part of a sentence, or in a list.

Such a mentioning of an instance will involve the articles, the name and possibly the `Mentioned` clause.

The basis for this mechanism is the short form, which by default is the first of the ``Name``s.
It will, however, be overridden by any existing `Mentioned` clause (see <<MENTIONED>>).

The short form can be automatically transformed to a description (for instances that have no `Description`) by inserting the article (see <<Articles and Forms>>) and the short form in a default message.
In the following transcript example, output of the article is shown in bold, and the short forms in italic, the rest is the default message templates.

[example,role="gametranscript"]
================================================================================
There is *a* _little black book_, *a* _green pearl_ and *an* _owl_ here.
================================================================================

The interpreter also uses this principle when constructing lists of instances in container content lists (as the result of the execution of an implicit or explicit `List` statement, see <<LIST Statement>>).



=== PRONOUNs

In player input, it is often handy and natural to refer to items using (((PRONOUN, clause))) pronouns, such as "`it`", "`them`" or "`her`".
Alan provides a means to define which pronouns each instance can be associated with.
(((BNF, rules of, PRONOUN)))

[source,bnf]
--------------------------------------------------------------------------------
pronouns = 'PRONOUN' word { ',' word }
--------------------------------------------------------------------------------

The effect of associating a pronoun with an instance is that the player can refer to that instance explicitly in one command and then in a subsequent command use that pronoun to refer to it again.
Assume the player input:

[example,role="gametranscript"]
================================================================================
&gt; ask the priest about the bible
================================================================================



If the priest has been associated with the pronoun "`him`" and the bible with the pronoun "`it`", the next command could be:

[example,role="gametranscript"]
================================================================================
&gt; give it to him
================================================================================



Pronouns are inherited as any other property, but are overridden as soon as a `Pronoun` clause is present.


[NOTE]
================================================================================
The predefined class `entity` defines the (((PRONOUN, predefined))) pronoun
"`it`" (or equivalent for other supported languages).
================================================================================

=== Attributes


An attribute is a labelled value that instances have.
Attributes declarations (((attributes, declaration))) are placed either inside a class definition (in which case they will apply to all instances of that class or any of its sub-classes) or inside an instance declaration (in which case only that instance will have those attributes, unless it's overriding inherited attributes with new values).
An attribute declaration, or a set of declarations, is introduced using one of the keywords:
(((BNF, rules of, IS))) (((BNF, rules of, ARE)))
(((BNF, rules of, HAS))) (((BNF, rules of, CAN)))

[source,bnf]
--------------------------------------------------------------------------------
is = 'IS'
   | 'ARE'
   | 'HAS'
   | 'CAN'
--------------------------------------------------------------------------------


And the actual declaration of an attribute follows the structure:
(((BNF, rules of, attribute declaration)))

// @NOTE @thoni56:
//    In the BNF rule below it might help to add side comments indicating
//    which type of attributes it's referring to. Ex:
//
//        attribute_declaration = id                    // boolean
//                              | 'NOT' id              // boolean
//                              | id integer            // integer type
//                              | id string             // string
//                              | id id                 // reference type
//                              | id '{' values '}'     // set type


[source,bnf]
--------------------------------------------------------------------------------
attribute_declaration = id
                      | 'NOT' id
                      | id integer
                      | id string
                      | id id
                      | id '{' values '}'
--------------------------------------------------------------------------------

An attribute can be of Boolean (having truth values), numeric, string, event, instance or set type.
The type of an attribute is automatically inferred from the type of its initial value.

Combining the keywords with well chosen attribute names can give natural reading to your attributes:

[source,alan]
--------------------------------------------------------------------------------
The rats Are hungry
The cowboy Can shoot
The chest Is heavy
The combination_lock Has numbers {1,2,4,8}
--------------------------------------------------------------------------------


If you want some attributes to be present on every instance of a given class, then you must declare them in that class.
E.g. to declare a Boolean attribute that will be shared by all instances of the `animal` class, the following code can be used:


[source,alan]
--------------------------------------------------------------------------------
Every animal ...
  Is
    Not human.
...
--------------------------------------------------------------------------------

The attribute `human` will now be available in all instances of the class, without further declarations, and it will be false.
If you want the attribute to have a different value in a particular instance, you must declare it specifically in that instance and assign it the desired value, which will be effective only for that instance.
You can override the value in a subclass, e.g.:

[source,alan]
--------------------------------------------------------------------------------
Every person IsA animal ...
  Is
    human.
...
--------------------------------------------------------------------------------




==== Boolean Attributes

A Boolean attribute (((attributes, boolean))) is declared by simply giving the attribute name, or its name preceeded by the keyword `Not` (indicating a *FALSE* initial value):

[source,alan]
--------------------------------------------------------------------------------
thirsty.
Not human.
--------------------------------------------------------------------------------



==== Numeric and String Attributes

Numeric (((attributes, numeric))) and string attributes are declared by simply typing the value after the attribute name:


[source,alan]
--------------------------------------------------------------------------------
weight 42.
message "Enter password:".
--------------------------------------------------------------------------------

Note that string (((attributes, string))) type attributes are mainly intended for saving string parameters from the player input, like in:

[example,role="gametranscript"]
================================================================================
&gt; scribble "Kilroy was here" on the wall
================================================================================


They are not intended for storing long strings of descriptions, especially not as attributes to classes, as they (in the current implementation) require memory and take time to initialise when starting the game.


==== Event Attributes

Attributes can refer to (((attributes, event type))) events.
Such an attribute is declared by giving the identifier of an event as its initial value.

[source,alan]
--------------------------------------------------------------------------------
Event e1
  "This is e1 running."
  Set e Of l To e2.
End Event.

The l IsA location
  Has e e1.
End The l.
--------------------------------------------------------------------------------

An attribute of the event type can for example be used to dynamically remember which event is scheduled, so that it can be cancelled.

==== Reference Attributes

Reference attributes (((attributes, of reference type))) store references to instances.
Such an attribute is of instance type; the class is determined by the class of the initial instance that the attribute is referring.
You may for example store a reference to the other side of a door:

[source,alan]
--------------------------------------------------------------------------------
The east_door IsA door.
  Has otherside west_door.
  ...
--------------------------------------------------------------------------------


You must initialise a ((reference attribute)) with a reference to an instance belonging to a class having the required properties.
Any subsequent assignment to the attribute will require that the new value is either a member of the same class or a subclass of it.
This ensures that operations on instances referenced by that attribute will always be possible.

Inside a class declaration, reference attributes may be initialised with a class identifier instead of a reference to an instance.
This makes the attribute an ((_abstract_ attribute)), since it is defined but not initialised.
Any instances inheriting from this class must then initialise the attribute, either explicitly or indirectly (by initialising it in an intermediate class).
E.g.:

[source,alan]
--------------------------------------------------------------------------------
Every door IsA object ...
  Has otherside door.
End Every door.

The east_door IsA door.
  Has otherside west_door.
  ...
--------------------------------------------------------------------------------


[TIP]
================================================================================
If you need to set the initial value to refer to an instance of a sub-class of the actual class you want to allow, you can use an instance of the required class in the declaration and set its correct initial value in the `Start` or `Initialize` sections.
================================================================================


==== Set Type Attributes

(((SET, type, attributes)))(((attributes, of SET type)))
A set is an unordered set of either integers or instance references.
Initial members must be listed in the declaration of the set.
See <<Set Type>> for details on the set type.

The type and class of allowed members is inferred from the actual values in the initial set.
If they are instance references, the common ancestor of all members is used as the class of the allowed members.
An empty set is only allowed as an initial value if the attribute is an inherited attribute, since in this case the member class is known from the inheritance and need not be indicated in the declaration.

You can also initialise (((initialize empty SET))) a set type attribute with a set consisting only of a single class identifier.
This will create an empty set with instance type members restricted to that particular class.


[TIP]
================================================================================
If you require an initially empty set of another type, e.g. integer, and you cannot give the member class by inheriting it, you can initialise the set with a single value of the correct type and remove that value in the `Start` or `Initialize` sections.
================================================================================



==== Inheriting Attributes


Attributes are inherited (((inheriting attributes))) like any other property.
An attribute declaration employing the same name of an attribute already present in any ancestor of the instance or class will inherit the type of that attribute, for you cannot change its type in subsequent declarations.
This means that any declaration of a value different from the inherited one must therefore
follow the rules of type compatibility for assignment. (See <<Type Compatibility>>.)

This also applies to classes of instances in the reference and Set types attributes.
Both these types allow references to instances.
The initial value given at the point where the attribute is introduced determines the required class of the Set members or referenced instances.
This is retained throughout the complete inheritance of that attribute even if a subsequent initial value would imply a more specialised class.
An example:

[source,alan]
--------------------------------------------------------------------------------
Every door IsA object
  Has otherside someDoor.
End Every door.

Every lockable_door IsA door.
  Has otherside someLockableDoor.
End Every lockable_door.

The someDoor IsA door
  Has otherside someLockableDoor.
End The someDoor.

The someLockableDoor IsA lockable_door
  Has otherside someDoor.
End The someLockableDoor.
--------------------------------------------------------------------------------


In this example, the ((reference attribute)) `otherside` is introduced in the class `door`.
Its initial value is referring to the class `door`.
This makes the attribute refer to doors.
In the subclass `lockable_door` the attribute is used with another initial value, here it refers to a subclass of `door`.
Despite this, the attribute in the two door instances will allow reference to doors, as indicated by the first declaration (in the class `door`).

As a contrast, the same example can be used with abstract reference attributes (((abstract attribute))) (reference attributes that are defined, but not initialised, in the class declaration).

[source,alan]
--------------------------------------------------------------------------------
Every door IsA object
  Has otherside door.
End Every door.

Every lockable_door IsA door.
  Has otherside lockable_door.
End Every lockable_door.

The someDoor IsA door
  Has otherside someLockableDoor.
End The someDoor.

The someLockableDoor IsA lockable_door
  Has otherside someDoor.
End The someLockableDoor.
--------------------------------------------------------------------------------

Now the class declarations refer to classes instead of instances in their declaration of the `otherside` attribute.
This changes the semantics so that the subclass indicated by `lockable_door` actually makes it illegal to use a `door` as the declaration in `someLockableDoor` does, instead a `lockable_door` is required.

Using (((abstract attribute))) abstract reference attribute declarations in class declarations allows you to progressively refine the class of the instances that that attribute may refer to.

=== INITIALIZE

The attributes of an instance can be initialised using values in the attribute declaration.
This is usually sufficient for many situations.
For more flexibility, the (((INITIALIZE, clause))) `Initialize` clause can be used.
(((BNF, rules of, INITIALIZE)))


[source,bnf]
--------------------------------------------------------------------------------
initialize = 'INITIALIZE' statements
--------------------------------------------------------------------------------

The clause makes it possible to execute arbitrary statements before the game is started.
The statements are executed before the `Start` clause is executed.
This enables calculation of more complex initial attribute values to be located within the instance, or class, that requires it.
Of course general statements are also allowed so any prerequisites can be catered for.


[source,alan]
--------------------------------------------------------------------------------
Initialize
  Set first_course of This To Random In first_courses Of menu.
  Set second_course of This To Random In main_courses Of menu.
  Set third_course of This To Random In desserts Of menu.
--------------------------------------------------------------------------------


The current location is set to the `Start` location, and the current actor is the `hero` during the execution (((execution context, INITIALIZE clause))) (((INITIALIZE, clause, execution context))) of all `Initialize` clauses.

If the `Initialize` clause is inherited it will accumulate all clauses with clauses from base classes executing before the clause from the subclass.
This lets the base classes do their initialisation before the initialisation of the more specialized, class or instance is performed.




=== DESCRIPTION

The statements in the (((DESCRIPTION, clause))) `Description` clause should print a description of the instance.
These statements are executed when the hero encounters the instance.
Depending on which base class the instance inherits from, this can be a location description presented when the hero enters the location or when executing a `Look` statement.
Other possibilities are descriptions of objects and actors.
See <<Instances>> for descriptions of what inheriting from the predefined base classes means.


[WARNING]
================================================================================
The `Description` should not change any game state since it might not always be executed depending on the settings of `Visits`.
In particular, the `Description` clause of a location should not move the hero; this might lead to a recursive loop of descriptions.
This might instead be managed by the (((ENTERED, clause))) `Entered` clause.
================================================================================



See also <<Special Statements,_Special Statements_>>, concerning the `Visits` statement.

The syntax for simple descriptions is:
(((BNF, rules of, DESCRIPTION)))

[source,bnf]
--------------------------------------------------------------------------------
description = 'DESCRIPTION' {statement}
--------------------------------------------------------------------------------

If the `Description` clause is missing for an instance (and no `Description` is inherited), the Alan system will supply a default description such as "`There is a round ball here.`".
If there is a `Description` clause but it contains no statements, the object will be '`invisible`', i.e. no description of it will be printed, not even a default one.
This can be useful for objects already described by the location description, or for objects with particular properties.

Here are some examples of simple description declarations:

[source,alan]
--------------------------------------------------------------------------------
The south_of_house IsA location
  Name 'South of House'
  Is outdoors.
  Description
    "You are facing the south side of a white
     house. There is no door here, and all the
     windows are barred."
  ...

The door IsA object
  Description
    "In the north wall there is a large wooden door."
    If door Is closed Then
      "It is closed."
    End If.
  ...
--------------------------------------------------------------------------------

Before executing a `Description`, you can check for various conditions to be met.
A common example is the dark room.
If there is no light source present, the description should not be printed.
The syntax for such a description is:
(((BNF, rules of, DESCRIPTION)))


[source,bnf]
--------------------------------------------------------------------------------
description = 'DESCRIPTION' [checks] [does]
--------------------------------------------------------------------------------

You can guard the description with a `Check` in the same form as with `Verb` bodies (see <<Verb CHECKs>> for a detailed description of checks).
Of course, there are no qualifiers possible here.
To be able to separate the checks statement from the actual description statements the keyword `Does` (((DOES, in descriptions))) is required.
This is an example of the checks for a dark location:

[source,alan]
--------------------------------------------------------------------------------
Every dark_location IsA location
  Description
    Check Sum Of light_source Here > 1
      Else "It is pitch black. You are likely
            to be eaten by a grue.""
End Every dark_location.
--------------------------------------------------------------------------------


Note that it does not specify any description statements.
This is because the checks and the actual description are inherited separately, as described in <<table-of-properties-inheritance>>.
The actual descriptions are left for the instances.

If multiple ``Description Check``s are available in the inheritance chain, they are all tested and must be met before any description is attempted.
So the inheritance of description checks is "`additive`".

If any check fails, the description will not be executed.
This particularly also implies that the default listings and description of present objects and actors in location instances will not occur either.
Note, however, that any events and actor actions _will_ be shown.
See <<Locations,_Locations_>> below for a description of the default description mechanism for locations.

If neither a check nor any description statements occur after the keyword `Description` this _is_ a description, but it is empty.


[WARNING]
================================================================================
You should _not_ put statements that changes game state in the `Description` clause.
Descriptions can be executed in various circumstances that the game author has no control over.
Consider `Exit` statements and the `Entered` clause instead.
================================================================================




=== Articles and Forms

The syntax for articles and forms is:
(((BNF, rules of, DEFINITE))) (((BNF, rules of, INDEFINITE)))
(((BNF, rules of, NEGATIVE))) (((BNF, rules of, ARTICLE)))
(((BNF, rules of, FORM)))

[source,bnf]
--------------------------------------------------------------------------------
forms = indefinite | definite | negative

definite = 'DEFINITE' article_or_form

indefinite = [ 'INDEFINITE' ] article_or_form

negative = 'NEGATIVE' article_or_form

article_or_form = 'ARTICLE' {statement}
                | 'FORM' {statement}
--------------------------------------------------------------------------------

The optional `Definite`, `Indefinite` and `Negative` ((``Article``s)) and ``Form``s can be used to define how an instance is printed in its indefinite, definite and negative forms.
There are two cases for each form, either as an article prepended to the short display form of the instance (its names or `Mentioned` clause), or a complete form replacing the normal name printing.

Indefinite forms are used in e.g. inventory listings and when presenting instances that have no `Description` clause.
Definitive forms are usually used in messages of the type:


[example,role="gametranscript"]
================================================================================
The door is locked.
================================================================================


The negative forms are used in standard messages of the type:


[example,role="gametranscript"]
================================================================================
I can't see any door here.
================================================================================




``Article``s and ``Form``s can of course, be inherited.


[NOTE]
================================================================================
The predefined base class `entity` defines the default definite, indefinite and negative article to be "`the`", "a" and "`any`" (if using English).
You may override this by using an `Add` statement.
================================================================================




==== ARTICLE

Printing the indefinite (or definite or negative) form of an instance having an indefinite (or definite or negative) article is simply performed by executing the `Article` statements and then the normal printing of the instance, usually the first set of names.

For example:

[source,alan]
--------------------------------------------------------------------------------
The owl `IsA` object
  Indefinite Article "an"
  ...
--------------------------------------------------------------------------------


This results in output like:


[example,role="gametranscript"]
================================================================================
There is an owl here. +
You are carrying an owl.
================================================================================




An article is not used when the instance is displayed when acting on multiple objects, as in:


[example,role="gametranscript"]
================================================================================
&gt; take everything +
(owl) Taken.
================================================================================




For instances that should not have any article at all, like '`some money`' or '`Mr Andersson`', an `Indefinite Article` clause containing no statements must be used:

[source,alan]
--------------------------------------------------------------------------------
The money Name some money
  Article
  ...
--------------------------------------------------------------------------------

Instead of:


[example,role="gametranscript"]
================================================================================
There is a some money here.
================================================================================




This will produce the expected:


[example,role="gametranscript"]
================================================================================
There is some money here.
================================================================================






==== FORM

If an instance has a `Definite` (`Indefinite` or `Negative`) `Form`, either through declaration or inheritance, the printing of its definite, indefinite or negative form will be by executing the corresponding statements only; no article declaration is involved.
In this way, the author gets complete control over the spelling and inflection of the instance name in definite, indefinite or negative forms.
Some human languages will probably require more use of the `Form` form (like Swedish), and some less (like English).
The forms are particularly useful if the natural language used, have different forms of the noun itself in definite an indefinite forms.
An example is the Nordic languages, which use definite suffixes instead of articles.

The `Article` and `Form` are inherited as one property.
That means that an instance may override its inherited form using either of the forms regardless of how its parent defined the form.



==== Printing


You can use various forms of the `Say` statement (see <<SAY Statement>>) to choose in which form the instance will be presented.
In addition, the embedded parameter references allow selection of the form (<<String Statement>>).



==== MENTIONED

The optional (((MENTIONED, clause))) `Mentioned` clause overrides the name for displaying an instance in a short form that will be used when the instance is mentioned e.g. in listings of containers or when the *ALL* (((ALL (player input)))) form of player input is used.
A typical use of the `Mentioned` clause is to let some internal state of the instance be reflected in the short form, e.g. if you want the short form of a box to show if it is open or closed you cannot rely on the Names since they are static.
Instead, the `Mentioned` clause can print a different short name depending on an attribute.
(((BNF, rules of, MENTIONED)))

[source,bnf]
--------------------------------------------------------------------------------
mentioned = 'MENTIONED' {statement}
--------------------------------------------------------------------------------

For example:

[source,alan]
--------------------------------------------------------------------------------
Mentioned
  If mirror Is broken Then
    "broken"
  End If.
  "mirror"
...
--------------------------------------------------------------------------------



[example,role="gametranscript"]
================================================================================
&gt; _take all_ +
(little black book) OK! +
(green pearl) OK! +
(broken mirror) OK!
================================================================================



[IMPORTANT]
================================================================================
A `Mentioned` clause declared on a class will override the names of any instance that inherits from it.
================================================================================



=== CONTAINER Properties

An instance can also be a container.
This is declared by using the (((CONTAINER, property, of objects))) `Container` property clause.
The grammar is
(((BNF, rules of, CONTAINER properties)))
(((BNF, rules of, OPAQUE)))

[source,bnf]
--------------------------------------------------------------------------------
container_properties = ['WITH'] ['OPAQUE'] 'CONTAINER'
                           ['TAKING' id]
                           [limits]
                           [header]
                           [empty]
                           [extract]
--------------------------------------------------------------------------------


For example:

[source,alan]
--------------------------------------------------------------------------------
The chest IsA object
  With Container
    Limits ...
    Header ...
  Description ...
  :
End The chest.
--------------------------------------------------------------------------------


A (((CONTAINER))) `Container` is something that can contain instances.
By default, the instances it can contain must be inheriting from the base class `object`, but by using the `Taking` clause, you can allow any instances.

Instances with the container property, "`inherits`" a special, predefined, Boolean attribute, `opaque`.
This attribute can be manipulated in the same way as any other attribute.
Its current value indicates if the instances inside the container are visible and accessible or not.

By default, containers expose their content, but by placing the keyword `Opaque` in the container declaration, you indicate that this container declaration will initially prohibit access to the contained instances.
A typical use of this is to prohibit access to contents of closed cases, drawers and boxes.
Once open such containers usually reveal the content, which then can be accessed.
You can implement such behaviour by modifying the built in `opaque` attribute.
For example:


[source,alan]
--------------------------------------------------------------------------------
The drawer IsA object
  With Opaque Container
    Header "The drawer contains"
  Verb open
    Does
      Make drawer Not opaque.
      List drawer.
  End Verb.
End The drawer.
--------------------------------------------------------------------------------


[NOTE]
================================================================================
If you want to hide the content of a container, you have to take care so that a `List` statement is not executed while the container is opaque since this will reveal its contents.
You can check the state of the `opaque` attribute like any other Boolean attribute.
================================================================================

(((predefined attributes, OPAQUE (CONTAINER))))
(((attributes, predefined, OPAQUE (CONTAINER))))
(((CONTAINER, OPAQUE attribute)))
(((CONTAINER, property, opaqueness)))
[NOTE]
================================================================================
The predefined `opaque` attribute is only available in instances and classes having the container property.
================================================================================



When an instance with the `Container` property is encountered during game play, it will be described as usual.
If the instance has a default description the contents of the container will be listed if it is not empty and not opaque.



==== LIMITS

The (((LIMITS, clause))) `Limits` clause of the `Container` property declaration put limitations on what and how much can be put in the container.
(((BNF, rules of, LIMITS)))

[source,bnf]
--------------------------------------------------------------------------------
limits = 'LIMITS' {limit}

limit = limiting_attribute 'ELSE' {statement}

limiting_attribute = attribute_definition
                   | 'COUNT' integer
--------------------------------------------------------------------------------



If any of these limits are exceeded when trying to locate anything inside the container, the statements in the corresponding `Else` part will be executed and the players turn aborted.
In fact, these checks are performed because of the execution of a (((locating inside containers))) `Locate` statement (usually as a result of the player issuing a command with the intent of placing something in a container).
This means that the execution of a sequence of statements can actually be interrupted in the middle by these limitations.

The specification of an attribute, which must be a numeric attribute on the class the container takes (by default `object`), implies that the sum of this attribute of all objects in the container cannot exceed the value specified.
The special attribute `Count` (((COUNT, in LIMITS))) can be also be used and indicates a limitation on the number of instances allowed.

[source,alan]
--------------------------------------------------------------------------------
Container
  Limits
    weight 50 Else "You can not lift that much."
    Count 2 Else "You only have two hands!"
--------------------------------------------------------------------------------



[NOTE]
================================================================================
The `Count` limit considers all instances in the container.
This might differ from the number of instances listed e.g. if the container takes ``Thing``s (which are not 'visible').
================================================================================



`Container` properties are inherited in its entirety.
Locations can't have container properties.



==== HEADER and ELSE

Syntax:
(((BNF, rules of, HEADER)))

[source,bnf]
--------------------------------------------------------------------------------
header = 'HEADER' {statement}

empty = 'ELSE' {statement}
--------------------------------------------------------------------------------


`Header` is used when the contents of the container is listed.
It is intended to produce something like:


[example,role="gametranscript"]
================================================================================
"The box contains"
================================================================================


or:

[example,role="gametranscript"]
================================================================================
"You are carrying"
================================================================================


It is followed by a list of instances mentioned. <<MENTIONED>> describes this listing.

The `Else` part is used instead of the `Header` if the container is empty.

If `Limits` or `Header` is missing, the Alan system supplies the default of no limits, and the messages output will be equivalent with:

[source,alan]
--------------------------------------------------------------------------------
Header
  "The <container> contains"
Empty
  "The <container> is empty."
--------------------------------------------------------------------------------

(<container> is replaced by the actual name of the instance.)



==== EXTRACT

The (((EXTRACT, clause))) `Extract` clause defines what happens when anything is extracted from a container.
Any `Locate` statement that moves an instance out of a container is considered an extraction.
The extraction will be subject to the restrictions enforced by the `Extract` clause.
(((BNF, rules of, EXTRACT)))

[source,bnf]
--------------------------------------------------------------------------------
extract = 'EXTRACT' [check] [does]
        | 'EXTRACT' {statement}
--------------------------------------------------------------------------------


The `Extract` clause, including optional `Check` and `Does` clauses, allows prohibiting the extraction of the item from the container depending on some condition.
If the `Check` is present, it works the same way as for ``Verb``s (see <<Verb CHECKs>>).
I.e. a `Check` without a guard expression will unconditionally prohibit extractions; a `Check` with an expression will evaluate that expression and, if false, execute its `Else` clause, and then abort the move.
The `Does` clause will be executed if the optional `Check` passes, or there was no `Check`.

An `Extract` clause without a `Check`, but with a `Does` clause, executes the `Does` clause and then allows the extraction to take place.
So, in a way, ``Check``s, if triggered, prevents the extraction, and the `Does` clause amends to it, being an extensions of the normal case, much like the `Check` and `Does` clauses for ``Verb``s (see <<VERBs>>).
The second form of the clause, with just the statements, is equivalent to an `Extract` with only a `Does` clause.

An example use of the `Extract` clause is to prohibit, put restrictions on, or modify the behaviour when the hero attempts to take things carried by another actor.

[source,alan]
--------------------------------------------------------------------------------
The waiter IsA actor
  At bar.
  Is Not annoyed.
  Description
    "A slow-moving, traditionally dressed waiter is here."
    List waiter.
    If waiter Is annoyed Then
      "He is rather annoyed."
    End If.
  Container
    Header "The waiter is carrying"
    Else "The waiter is empty-handed."
    Extract Does "The waiter is annoyed by your presupposition."
      Make waiter annoyed.
End The waiter.
--------------------------------------------------------------------------------


=== VERBs

``Verb``s declared inside an class or instance are inherited in the same way as other properties.
See <<VERBs>> for a description on how to declare verbs.

The verbs in a class or instance will only be a candidate for execution if the instance bound to a parameter is of the corresponding class, or is the instance.
See <<Verb Execution>> for a detailed explanation.



=== ENTERED

Syntax:
(((BNF, rules of, ENTERED)))

[source,bnf]
--------------------------------------------------------------------------------
entered = 'ENTERED' {statement}
--------------------------------------------------------------------------------

The `Entered` clause is only allowed in instances inheriting from the predefined class `location`.
This clause will be executed whenever any actor enters the location.
Game state changes can be made without restriction.

However, the `Entered` clause is primarily intended for setting up the location in a correct way, not for describing events, actions and states changes.
For this the `Description` clause is recommended.

The `Entered` clause can also be used to restrict the movements of actors other than the `Hero`. (The hero's travels are controlled by `Exit` checks as described in <<EXITs,_EXITs_>>).

If some of the statements should only apply to a particular actor, it is possible to test for the `Current Actor` with a simple `If` statement.

The actor is located at the location before the clause is executed so `Current Location` will be the location having the clause.

`Entered` clauses are inherited and locations can be nested (see <<Locations,_Locations_>>).
The order of execution is explained by the following table:


[[table-of-entered-execution]]
.Order of Execution of ENTERED in Nested Locations
[cols="^s,3*^n",options="header"]
|===============================================================================
|            | Outer Region |     ...      | Current Location
| Base class |  Outermost   |    {darr}    |    {darr}
| {vdots}    |    {darr}    |    {darr}    |    {darr}
| Leaf class |    {darr}    |    {darr}    |    {darr}
| Instance   |    {darr}    |    {darr}    |    {darr}
|===============================================================================

This means that the first `Entered` clause to be executed is the clause in the base class of the outermost location, if any, then moving down the inheritance of the outermost.
After that, any parent classes for any intermediate locations are considered in the same way.
Finally, running any `Entered` clauses in the parents of the new location, ending with the clause in the location itself.


[NOTE]
================================================================================
The `Entered` clause is only executed when the actor is entering the location.
This goes for _all_ actors, not only the player/hero.
The actor will be at the location when the clause starts to execute.
================================================================================



[NOTE]
================================================================================
If it is the hero that is moving, the `Description`, including the normal header containing the location name, of the new location will be executed _directly after_ the `Entered` clause.
================================================================================




=== EXITs

To build a traversable world of locations, they must be connected.
This is done using ``Exit``s.
The syntax for an `Exit` declaration is:
(((BNF, rules of, EXIT)))

[source,bnf]
--------------------------------------------------------------------------------
exit = 'EXIT' id {',' id} 'TO' id [exit_body] '.'

exit_body = [checks] [does] 'END' 'EXIT' [id]
--------------------------------------------------------------------------------

An (((EXIT))) `Exit` has a list of identifiers, all of which are considered directional words.
I.e. when any of those words is input by the player, he will be located at the location identified as the target of the exit.
It is possible to customize the exit using a (((CHECK, in exits))) `Check`, that must be satisfied to allow passage through the exit, and statements (`Does`) that will be executed when the player passes through.
The checks work as described in <<Verb CHECKs,_Verb CHECKs_>>.

If either of the `Check` or `Does` clauses is present, the `End Exit` is required.

Two interconnected locations might be declared like this:

[source,alan]
--------------------------------------------------------------------------------
The east_end IsA location Name 'East End of Hall'
  Description
    "This is the east end of a vast hall. Far
     away to the west you can see the west end."
  Exit w To west_end.
End The east_end.

The west_end IsA location Name 'West End of Hall'
  Description
    "From this western end of the large hall it
     is almost impossible to discern the
     opposite end to the east."
  Exit e To east_end.
End The west_end.
--------------------------------------------------------------------------------



[NOTE]
================================================================================
If an exit is declared from one location to another, and you want there to be an exit in the opposite direction, you have to define the reverse passage.
It is not created automatically.
================================================================================



Exits are only allowed in classes or instances inheriting from the predefined class `location`.



=== SCRIPTs

The (((SCRIPT))) `Script` is the way actors perform things.
In a way, it corresponds to what the hero is ordered to do by the player's typed-in commands.
(((BNF, rules of, SCRIPT)))

[source,bnf]
--------------------------------------------------------------------------------
script = 'SCRIPT' id ['.'] [description] {step}
--------------------------------------------------------------------------------

Every script has an identifier (the *id*) to identify it.
A script is selected by the (((USE, statement))) <<USE Statement,`Use` statement>>.
When an actor starts following a script, it will continue with one step after the other, with all the other actors, including the hero, taking turns.

The optional `Description` (((DESCRIPTION, of ACTOR scripts))) allowed in the beginning of a script is used instead of the general description (from the instance declaration) whenever the actor is executing that particular script.
If it is not present, the general description is used.

[source,alan]
--------------------------------------------------------------------------------
Actor george
  Name George Formby
  Description "George Formby is here."
  Script cleaning.
    Description
      "George Formby is here cleaning windows."
    Step ...
  Script tuning.
    Description
      "George Formby is tuning his ukelele."
    Step ...
...
--------------------------------------------------------------------------------



An actor continues executing its script until:

* it reaches the end
* another `Use` statement is executed for that actor
* the actor is stopped using the <<STOP Statement,`Stop` statement>>
* something fails


[NOTE]
================================================================================
There are a few things that might fail when an actor executes.
One example is an `Extract`, which means that something is removed from a container.
As containers may define ``Extract Check``s that action might be prevented.
This means of course that that step is aborted, but also that the actor is automatically stopped, so no further steps from the script will be run.
The author is responsible for handling this, e.g. by using rules to ensure that the condition is detected and handled correctly.
================================================================================



==== STEPs


A script is divided into steps.
Each (((STEP))) `Step` contains statements representing what the actor will do in what corresponds to one player move.
A step can be defined to be executed immediately, at the next move, to wait a number of moves before it's executed or even to wait for a special situation (condition) to arise.
(((BNF, rules of, STEP)))

[source,bnf]
--------------------------------------------------------------------------------
step = 'STEP' {statement}
     | 'STEP' 'AFTER' expression {statement}
     | 'STEP' 'WAIT' 'UNTIL' expression {statement}
--------------------------------------------------------------------------------


For example:

[source,alan]
--------------------------------------------------------------------------------
Step Wait Until hero Here
  Locate waiter Here.
  "From the shadows a waiter emerges: $p
   '-Bonjour, monsieur', he says."
Step After ticksLeft Of train
  "The train driver enters the train, and after a brief
   moment the train starts to move."
--------------------------------------------------------------------------------


When an actor has executed the last step (((STEP, executing the last))) of the current script, it will do nothing more until the next `Use` statement is executed for this actor (the actor will not act, but still present at the location where it was).
If this is not what you wanted, you can end each script with a new `Use` statement.



== Additions

In certain circumstances, you need to add properties to a class after it is defined.
A simple example of this is adding attributes to the predefined classes.
For this purpose, the `Add` construct is available.
It follows the grammar:
(((BNF, rules of, ADD TO EVERY)))

[source,bnf]
--------------------------------------------------------------------------------
addition = 'ADD' 'TO' 'EVERY' id
               {property}
           'END' 'ADD' ['TO'] [id] '.'
--------------------------------------------------------------------------------

Using this construct, you can add any property to a class without having access to its declaration.
A standard library would make heavy use of this since it would be structured so that related verbs, their syntax and synonyms are packaged together.
If such a package required particular attributes in classes, they could be added using the `Add` construct.



== SYNTAX Definitions

The (((SYNTAX, construct))) `Syntax` construct is used to specify the allowed structure of the player's input.
Each definition defines the syntax for one `Verb`.
The effects triggered by the player input are declared using the `Verb` construct (see <<VERBs>>).
(((BNF, rules of, SYNTAX)))

[source,bnf]
--------------------------------------------------------------------------------
syntaxes = 'SYNTAX' {syntax}

syntax = id '=' {element} syntax_end

element = id
        | '(' id ')' [indicator]

syntax_end = parameter_restrictions
           | '.'
--------------------------------------------------------------------------------

The syntax is defined as a number of _syntax elements_ each being either a player word (a single *id*) or the name of a parameter (an identifier enclosed in parenthesis).
Parameters may be in any position, including the first.
Bare in mind that a syntax definition containing only parameters might be tricky for the interpreter to match as you intended, for the complete set of allowed input can easily become ambiguous.

[source,alan]
--------------------------------------------------------------------------------
Syntax
  quit = 'quit'.
  examine = 'examine' (obj).
  command_north = (act) 'north'.
  unlock_with = 'unlock' (l) 'with' (k).
--------------------------------------------------------------------------------

When the player types a command, it is compared to the set of declared syntaxes.
This provides a very flexible way to extend the allowed command set (see also <<Player Input>> for general details on player input).

After the player input has been matched to an allowed syntax, the parameters are bound to the instances referred to by the player, and the parameter identifiers in the `Syntax` declaration will now refer to those entities.
Any references to attributes, etc., will be done in the instance referred by the parameter.

[source,alan]
--------------------------------------------------------------------------------
Syntax open = open (obj).
  ...
  If obj Is open Then ...
  ...
--------------------------------------------------------------------------------


In the above example, the parameter `obj` can be used in the declaration of the `open` verb and, at execution time, it will refer to the actual instance it was bound to.
Consider the `unlock_with` syntax declaration of the previous example, the following table illustrates which instances the parameter identifiers `l` and `k` will be referring to in the actual game:



[[table-syntax-parameters]]
[cols="<60a,2*<20n",options="header"]
|===============================================================================
| Player input | `l` | `k`

|[example,role="gametranscript"]
================================================================================
&gt; _unlock the door with the key_
================================================================================
| door | key

|[example,role="gametranscript"]
================================================================================
&gt; _unlock the bottom drawer with the rusty knife_
================================================================================
| bottom drawer | rusty knife

|[example,role="gametranscript"]
================================================================================
&gt; _unlock the skeleton with the tiny blue chair_
================================================================================
|skeleton |tiny blue chair

|===============================================================================

This, of course, provided that there is an instance that will match the player input, given the adjectives and nouns in the input and those in the instance declaration.

It is allowed to define multiple syntaxes for the same identifier (verb).
See <<Syntax Synonyms,_Syntax Synonyms_>>.




=== Indicators

Following a parameter, (((parameter, indicators))) indicators are allowed in `Syntax` declarations.
(((BNF, rules of, parameter indicators)))

[source,bnf]
--------------------------------------------------------------------------------
indicator = '*'' | '!''
--------------------------------------------------------------------------------

There are two indicators available (_multiple_ and _omnipotent_):

* `+++*+++` -- (((indicator, multiple)))(((multiple indicator)))
  This parameter can reference multiple instances (for example by the player
  using *ALL* (((ALL (player input)))) or concatenating a number of parameters using a conjunction like *AND* (((AND (player input)))); see <<Player Input>>).

* `!` -- (((indicator, omnipotent)))(((omnipotent indicator)))
  The parameter (the instance the player refers to in this position in the syntax) need not be present at the current location.
  The default behavior of the Alan interpreter requires that a referenced instance must be present at the same location as the hero, if the parameter inherits from `thing`.
  (Note that *entities* are always accessible).
  For cases when the player must be able to refer to objects and actors that are not present (e.g. in a verb like `talk_about`) this _omnipotent indicator_ can be used to force the interpreter to accept references to any object or actor.

An example:

[source,alan]
--------------------------------------------------------------------------------
Syntax
  take = 'take' (obj)*.
  drop = 'drop' (obj).
--------------------------------------------------------------------------------

This shows the syntax definitions for the verbs `take` and `drop`; where `take` also allows multiple objects.
This would make the following inputs possible:


[example,role="gametranscript"]
================================================================================
&gt; _take everything except the pillow_

&gt; _drop the vase_
================================================================================


Refer to <<Player Input>> for details on multiple parameters references in player's input (such as objects).

The above declarations would force the interpreter to reject player input like:


[example,role="gametranscript"]
================================================================================
&gt; _drop the shovel and the bucket_
================================================================================


This is because the syntax for the verb `drop` does not allow multiple references, as it doesn't include the _multiple indicator_.
Another example, this time using the `!` indicator:

[source,alan]
--------------------------------------------------------------------------------
Syntax
  talk_about = 'talk' 'to' (act) 'about' (subj)!.
  find = 'find' (obj)!.
--------------------------------------------------------------------------------

Even if the robber or the key are not present, it will allow the player to say:


[example,role="gametranscript"]
================================================================================
&gt; _talk to the policeman about the robber_

&gt; _find the key_
================================================================================

For more information on player inputs, refer to <<Player Input>>.

Indicators given in one syntax declaration can affect other syntaxes if they have identical beginnings, like:


[example,role="gametranscript"]
================================================================================
&gt; _put everything on_
================================================================================

and

[example,role="gametranscript"]
================================================================================
&gt; _put everything on the table_
================================================================================


Even if only one of the syntax declarations indicate that the first parameter should allow multiple instances, both syntaxes will actually allow this because they have the same syntax part before the parameter, in this case the verb "`put`".



=== Parameter Restrictions

To restrict (((restriction, of parameters))) the types of entities the player may refer to in the place of a ((parameter)), its class can be defined by using explicit test in the syntax declaration.
(((BNF, rules of, WHERE)))
(((BNF, rules of, parameter restrictions)))


[source,bnf]
--------------------------------------------------------------------------------
parameter_restrictions = 'WHERE' restriction
                             {'AND' restriction}

restriction = id 'ISA' restriction_class
                  'ELSE' {statement}

restriction_class = id
                  | 'CONTAINER'
--------------------------------------------------------------------------------


[NOTE]
================================================================================
Any predefined or user defined class can be used.
================================================================================

[TIP]
================================================================================
Don't forget that also `literal`, `integer` and `string` are predefined classes (see <<The Predefined Classes>>).
================================================================================


The following example describes the syntax for a verb that only allows ``object``s as its parameters (this is however also the default, see below).

[source,alan]
--------------------------------------------------------------------------------
Syntax
  take = 'take' (obj)
    Where obj IsA object
      Else "You can't take that."
--------------------------------------------------------------------------------

Each parameter may be restricted to refer only to instances of particular classes or instances with the `container` property, or numeric or string literals.
The statements following the `Else` will be executed if that restriction is not met, i.e. if the player refers to an instance not belonging to the specified class or classes.
The default restriction is `object`, i.e. if no class restriction is supplied for that parameter identifier the player may only refer to objects at that position in his input.

A more elaborate example of prerequisites for conversation might look like:

[source,alan]
--------------------------------------------------------------------------------
Syntax
  talk_about = 'talk' 'to' (act) 'about' (sub)!
    Where act IsA actor
      Else "Don't you think talking to a person
            might be better?!?!"
    And sub IsA subject
      Else
        Say act. "does not know anything about
                  that."
...
--------------------------------------------------------------------------------


You can provide multiple restrictions, even for the same parameter; but if they refer to the same parameter they must be presented in increasingly restrictive order.
For example:

[source,alan]
--------------------------------------------------------------------------------
Where obj IsA object Else ...
  And obj IsA openable_object Else ...
  And obj IsA door Else ...
--------------------------------------------------------------------------------


References to attributes in the source are only allowed if it can be guaranteed that they exist during run-time.
The class restrictions placed on a parameter are used by the compiler to make this guarantee for code executed by player input (verb bodies).
The same applies for other semantic restrictions, e.g. you can only use a parameter in a `List` statement if it has been restricted to having the `Container` property.

You can use `IsA Container` to restrict instances to only those entities that are containers (have the `Container` property).

If there is no restriction for a parameter, it is restricted to the class `object`.



=== Syntax Synonyms

It is possible to create multiple syntax declarations for the same verb.
The semantics of this is that any of the input formats will be accepted and trigger the same verb action.
This is a way to define syntactical synonyms, which are useful to allow multiple forms of input for the same action, increasing chances that the player will find the correct form.
For example:

[source,alan]
--------------------------------------------------------------------------------
Syntax give = give (o) to (p) ...
Syntax give = give (p) (o) ...
--------------------------------------------------------------------------------
The syntaxes must be compatible in the sense that the parameters must be named the same.
However, the order of the parameters may differ, they will automatically be mapped as appropriate.


// @TODO: Add note about the fact that parameter dollar-symbols ($1, $2, etc.)
//        will always represent the parameters as defined in the first (main)
//        syntax declaration, and that they will therefore show the correct
//        parameter even when syntax alternatives with inverted parameters order
//        are used.

Restrictions are only allowed in the first of such syntax declarations.
These restrictions will be applied regardless of which syntax was used.



=== Default Syntax

If no `Syntax` is defined for a `Verb` at all, this is handled with one of two default syntaxes (((SYNTAX, default))) according to the two templates below:

// @NOTE: The example below could very well use AsciiDoc callouts, but there might
//        be problems with the fact that the placeholders use the same notation as
//        callouts.


[source,alan]
--------------------------------------------------------------------------------
Syntax <1> = <1>.
Syntax <1> = <1> (<2>).
--------------------------------------------------------------------------------

The placeholders represent 1) the name of the verb, and 2) the class in which the verb is first encountered.

The first template is used for verbs that are declared globally, i.e. outside of any class or instance.
Since these are only applied when no parameters are used, this will effectively work for simple '`verb-only`' ``Verb``s, such as '`quit`', '`look`', '`save`', etc.

When a `Verb` declared in an instance or a class has no `Syntax` counterpart, it automatically receives a default syntax of the common verb/object type corresponding to the second template above.
This is a reasonable syntax for many cases and restricts the parameters to instances of the class where the verb was declared.
It also implies that the default name for the single parameter is the same as the name of that class, e.g. `object`, `actor`, `thing`, etc. (See <<WHAT Specifications>> for the implications of this.)


[NOTE]
================================================================================
A `Verb` which is declared in a number of classes, or instances of various heritage, can not be handled with the default rules, since that would imply that the parameter should be restricted to multiple classes at the same time.
This case must be handled explicitly.
================================================================================


// @FIXME:  The warning below is not very clear regarding the implications of the
//          parameter being restricted to the `location` class.
//          The way it's phrased it seem to mean that the verb will be available
//          on EVERY LOCATION -- because it mentions "the location class" and
//          not the specific instance where it resides.

[WARNING]
================================================================================
When a `Verb` declared in a location has no `Syntax` counterpart, it will receive a default syntax restricting the parameter to the `location` class, which probably is not what you wanted.
================================================================================



=== Scope

If the player inputs a command following a syntax which requires parameters, the interpreter first determines if the referenced instance is in scope.
This is performed even before the restrictions are executed.

There are a number of ways to get an instance into scope:

* Instances of `entity`, and of any user defined subclasses thereof, are always in scope.

* Instances of `thing` and its subclasses at the current location, including any nested locations, are in scope.

* Instances of any class inside a container that is in scope are in scope too, unless that container is opaque and closed.
  (See <<CONTAINER Properties, _Container Properties_>> for details.)

* If the syntax indicated a parameter as omni-potent, any instance is in scope for that parameter position.
  (See <<Indicators, _Indicators_>> for details.)

If the interpreter finds multiple instances matching the input (the set of given adjectives and noun), it will try to disambiguate giving preference to present instances -- i.e. at the location of the hero.
If there are still multiple candidates left after this, the interpreter will print a message and abort execution of the current command.

When all parameter positions in the syntax have been resolved this way, the restrictions are executed.



== VERBs

A (((VERB, declaration))) `Verb` declaration specifies what to check and the effects of something the player does (i.e. commands using a syntactically legal input).
(((BNF, rules of, VERB)))
(((BNF, rules of, META VERB)))

[source,bnf]
--------------------------------------------------------------------------------
verb = ['META'] 'VERB' id {',' id}
           verb_body
       'END' 'VERB' [id] '.'

verb_body = simple_verb_body
          | {verb_alternative}

simple_verb_body = [check] [does]
--------------------------------------------------------------------------------

[source,alan]
--------------------------------------------------------------------------------
Verb take, get
  ...
End Verb take.
--------------------------------------------------------------------------------

Verbs can be declared at two different levels:

* global (outside any other declaration), or
* inside a class or instance declaration, including inside an `Add` construct.

A global declaration will only be considered when the verb is not applied to any instance (i.e. such as the player referring to an object).
In fact, a global verb cannot include any parameters in their syntax declaration.

A verb declaration inside a class or instance definition will be considered if that instance (or an instance inheriting from that class) is used as a parameter in the input.

The identifiers in the list (`take` and `get` in the example above) will become the default player words that can be used to invoke the verb.
But if a `Syntax` is declared for the `Verb` (see <<SYNTAX Definitions>>), the identifiers in the list will not be accessible to the player, instead the sequence of words and parameters specified in the `Syntax` must be used.


// @FIXME @thoni56:
//
//   The following paragraph (which is very important for the reader) is too
//   condensed. It might be worthy rephrasing it and make it easier to grasp,
//   and adding examples or more details on the implications wouldn't hurt either.
//
//   A good example to provide here would be that of the "ask" and "tell"
//   verbs, which are often used as one verb in many contexts.

If there is more than one identifier in the list, as in the example above, this can be viewed as a shorthand for declaring identical checks and bodies for all the verbs in the list.
This will create synonymous actions for different verbs at the level of the verb declaration.
They may differ in implementation at other places, i.e. if they are declared in the same verb declaration on one level in an inheritance tree, they can still have different bodies on another level.

=== META VERBs

(((VERB, META VERB)))
Any action from the player usually takes one '`tick`' in the default simulated game time.
Sometimes you want a player command to _not_ consume a '`tick`', for example administrative commands like '`help`', '`score`' etc.

// @TODO @tajmone:
//    Add a note about out-of-game actions (aka "directives"), and difference
//    between diegetic and extra-diegetic actions/verbs (indeed: commands/directives).
//    Quote Nick Montfort's "Twisty Little Passages" on the topic.

You can achieve this by attaching (((META))) `Meta` in front of the verb definition:

[source,alan]
--------------------------------------------------------------------------------
Meta Verb 'score'
  Does
    Score.
End Verb.
--------------------------------------------------------------------------------



If your `Verb` has multiple definitions (e.g. for various classes) applying `Meta` to any one of them will make the verb a meta verb, meaning that if the player uses that verb in any context and on any instance, it won't consume a tick, even if that particular definition did not have the `Meta` property explicitly expressed.
A library might decide that `'score'` was a meta verb and there is nothing you, as an author, can do to override that short of editing the library source.

Furthermore, a `Meta` verb does not trigger evaluation of _rules_ and ``Event``s either, so they are genuinely "`outside`" the game and should only be used with verbs that are not considered part of the players progression inside the game.


[NOTE]
================================================================================
The `Meta Verb` feature only applies to the built-in timing mechanism known as '`ticks`', where every player command counts as 1 tick.
It is possible to implement your own timing mechanism, in which case the `Meta` does not help.
================================================================================



=== VERBs in Locations

A special case is a `Verb` declared in, or inherited by, the `location` where the player is currently located.
If this verb is used, any checks or body of that verb will be considered before the verbs in the parameters.
An example might be a location representing walking on a high wire.
Anything dropped at the following location will disappear:

[source,alan]
--------------------------------------------------------------------------------
The high_wire IsA location
  Verb drop
    Does Only
      Locate o At limbo. â€“- Instead of "here".
  End Verb.
End The.
--------------------------------------------------------------------------------


=== Verb CHECKs

Syntax:
(((BNF, rules of, CHECK)))

[source,bnf]
--------------------------------------------------------------------------------
check = unconditional_check
      | check_list

unconditional_check = 'CHECK' {statement}

check_list = 'CHECK' expression 'ELSE' {statement}
             {'AND' expression 'ELSE' {statement}
--------------------------------------------------------------------------------


To determine if the action is possible to carry out, the checks in (((CHECK))) `Check` are executed.
Which checks to run, is determined by the class of the instances bound to the verb by the parameters.
All checks in the inheritance tree are tried by starting at the base class.
This way, the more general checks are tried first, followed by increasingly more specific checks.

A typical use of `Check` is to verify if the parameter has a particular property:


[source,alan]
--------------------------------------------------------------------------------
Verb take
  Check obj Is moveable
    Else "You can't take that."
  ...
End Verb take.
--------------------------------------------------------------------------------

If no expression is specified for a `Check`, that check will always fail, in effect becoming an (((CHECK, unconditional))) unconditional `Check`.
This is useful for preventing certain actions, for example at specific locations, since the checks are always executed first:

[source,alan]
--------------------------------------------------------------------------------
The jumpless IsA Location
  Verb jump
    Check "You can't do that here."
  End Verb jump.
End The jumpless.
--------------------------------------------------------------------------------

If any check should fail, the execution of the current verb is interrupted and the statements following the failing check are executed.
The user (player) is then prompted for another command.
So in the above example, the verb "`jump`" will always result in "`You can't do that here.`" at the location `jumpless`.


[NOTE]
================================================================================
``Check``s are intended to take care of any _exceptions_ for executing the normal case.
The normal, or positive/affirmative, case should be handled by the `Does` clause.
================================================================================


With this in mind, ``Check``s are also used when handling the user input *ALL* (((ALL (player input)))) (see <<Player Input>> for details on possible player input).
The mechanisms for this involve examining all objects at the current location and evaluating all checks for the verb.
Any objects that do not pass the checks are not considered for execution.
This limits the handling of *ALL* to executing only the verb bodies of objects that are reasonable, i.e. whose ``Check``s will not fail.

For example assuming the above definition of the verb `take` and a location containing the objects `ball` and `box`, where only the ball is `moveable`, the player input:


[example,role="gametranscript"]
================================================================================
&gt; take all
================================================================================

would result in *ALL* representing only the ball.
See <<Player Input>> for an explanation of the player view of this.



=== DOES Clause

Syntax:
(((BNF, rules of, DOES)))  (((BNF, rules of, BEFORE)))
(((BNF, rules of, AFTER))) (((BNF, rules of, ONLY)))

[source,bnf]
--------------------------------------------------------------------------------
does = [qualifier] {statement}

qualifier = 'BEFORE'
          | 'AFTER'
          | 'ONLY'
--------------------------------------------------------------------------------

If all checks succeed, the execution (((DOES, in verbs))) of the verb will be carried out.
Multiple verb bodies may be involved.
The default order is to execute first the body of any verb declaration for the current location (including verb bodies inherited by it).
Each parameter is then examined to find any declarations of that verb for the instance (including inherited verb bodies).
These verb bodies are then executed in the order in which the parameters occurred in the `Syntax` declaration, for each parameter starting with the body in the most basic class.
By default, all of the involved verb bodies are executed.
This is the most natural order and covers most cases.

In some unfrequent situations, another order may be necessary.
By using the (((VERB, qualifiers))) qualifiers, `Before`/`After`/`Only`, the author can decide which verb bodies will be executed and in which order (see <<Verb Qualification,_Verb Qualification_>> below for details).

A simple verb example:

[source,alan]
--------------------------------------------------------------------------------
Verb take
  Check obj Not In inventory
    Else "You already have that."
  Does
    Locate obj In inventory.
End Verb take.
--------------------------------------------------------------------------------



=== Verb Alternatives

Syntax:
(((BNF, rules of, verb alternatives)))
(((BNF, rules of, WHEN)))

[source,bnf]
--------------------------------------------------------------------------------
verb_alternatives = 'WHEN' id simple_verb_body
--------------------------------------------------------------------------------

When a `Verb` (((VERB, alternative))) is declared within an instance declaration, verb alternatives are allowed.
These alternatives are used in conjunction with the `Syntax` declaration defined for the verb and allow differentiating between the instance occurring at different parameter positions in the input.

When a player inputs a command, each parameter in the syntax (see above) is bound to an actual instance or receives the value of a literal, depending on the specified syntax.
To determine which checks to test for, and which verb bodies to execute, the parameters are examined in turn according to the algorithm described in the section <<Verb Qualification,_Verb Qualification_>> below.
Each instance may have different verb bodies executed depending on which position it occurred at (to which parameter it was bound).

For example, assume the following syntax definition:

[source,alan]
--------------------------------------------------------------------------------
Syntax break_with = 'break' (o) 'with' (w).
--------------------------------------------------------------------------------

If used with the `delicate_vase`, the resulting actions could differ depending on whether it occurs as the direct object (`o`) or as the indirect object (`w`).
To implement this, the `Verb` body for `break_with` should differentiate between the two cases.
For each parameter in the `Syntax`, you may define different actions by supplying a verb alternative for each parameter identifier.
The verb declaration could look like:

[source,alan]
--------------------------------------------------------------------------------
The feather IsA object
  Verb break_with
    When o Does
      "The feather is even more flat than before."
      Make feather flat.
    When w Does
      "There is not much that you can break with a feather!"
  End Verb break_with.
End The feather.
--------------------------------------------------------------------------------

If no alternative is explicitly specified the verb body will be considered for all positions in the syntax.
The compiler will warn for this when it detects a syntax that allows the class or instance to occur at every parameter positions.



=== Verb Qualification

Syntax:
(((BNF, rules of, BEFORE)))
(((BNF, rules of, AFTER)))
(((BNF, rules of, ONLY)))

[source,bnf]
--------------------------------------------------------------------------------
qualifier = 'BEFORE'
          | 'AFTER'
          | 'ONLY'
--------------------------------------------------------------------------------

The order in which the different verb bodies are executed is normally from the most general to the most specific.
But, to allow for local differences (i.e. special handling of the verb at the current location) any definition of the verb in the current location (including inherited verb bodies) are considered first.
Then, the verb bodies in the parameters on which the verb was applied are examined (in their order of appearance in the syntax definition) to find and execute their verb definitions.
For each parameter, its most general definition is executed first, then verb bodies down the inheritance tree are executed next, ending with any verb body declared in the specific instance bound to that parameter.


In most circumstances, this is the most logical order, but if another order is required, the `Verb` qualifiers (((VERB, qualifiers))) (((AFTER, qualifier))) `After`, (((BEFORE, qualifier))) `Before` and (((ONLY, qualifier))) `Only` may be used to alter this behaviour.
These qualifiers alter the order of execution, as described in full detail below.



=== Verb Execution

(((VERB, execution order)))
First all parameters are evaluated according to the `Syntax` restrictions (see <<Parameter Restrictions,_Parameter Restrictions_>>).
Then, if they passed, the ``Check``s of all verb declarations are evaluated (see <<Verb CHECKs>>).
Finally the `Verb` bodies are executed in the normal order, as explained in the following table.


[[table-of-verbs-execution]]
.Order of Execution of Verbs
[cols="^s,6*^n",options="header"]
|===============================================================================
|  | Outer Region | ... | Current Location | First parameter | ... | Last parameter

| Base class (entity)
| Outermost | {darr} | {darr} | {darr} | {darr} | {darr}

| {vdots}
| {darr} | {darr} | {darr} | {darr} | {darr} | {darr}

| Leaf class
| {darr} | {darr} | {darr} | {darr} | {darr} | {darr}

| Instance
| {darr} | {darr} | {darr} | {darr} | {darr} | Innermost
|===============================================================================


The table above illustrates the normal order of execution of verb bodies and checks.
Starting with any base classes to the outermost region (containing location), continuing to the actual instance of that location, as illustrated by the first column.
It then continues with any inner regions (second column) and the current location itself (third column).
The execution then proceeds to the parameters of the syntax in order (columns four through six), traversing the inheritance tree from the base class to the instance.


[IMPORTANT]
================================================================================
If you add a verb to the class `entity`, it will be inherited by all instances, including locations and objects.
This will result in the execution of that verb body multiple times, since it will be in every column in the table above.
================================================================================



==== Controlling Execution with Qualifiers

There are cases where you don't want all the bodies to be executed, or there is a special need to execute them in a different order.
The most common case is to prohibit other bodies to be executed, e.g. a verb body in a location might want to stop the player from throwing any object.
This verb body must then ensure that it is the only verb body to be executed.
This can be done using the `Only` qualifier (see <<Verb Qualification>>).

Qualifiers control the order of execution of verb bodies.
How does this work?

First, starting at the "`innermost`" according to the table above, the verb in the last parameter (if any) is investigated and, if any of its (inherited) verb bodies have the `Before` or `Only` qualifier it is executed.
If the qualifier was `Only` then execution is also aborted at this stage and no more verb definitions are examined, otherwise the other parameters are examined in the same way.

In the next step, the current location is examined and, if it contains (or inherits) a verb definition with a `Before` or `Only` qualifier, that definition is executed now (and if the qualifier was `Only`, execution is also aborted).
Since locations can be nested, the surrounding locations are then examined in the same way.

As a result of this behaviour, a `Before` qualifier in the verb definition in an object parameter will supersede an `Only` qualifier in the location.

At this stage, all `Before` and `Only` qualifiers are handled appropriately.
This only leaves the definitions without any qualifier or with the `After` qualifier.
The outermost verb body (as indicated in the table above) is examined and if it did not have the `After` specification, it is executed (if it had an `Only` qualifier then no furhter executions will be taken into consideration).
Any definition of the verb in the current location is again examined and, if it did not have the `After` qualifier, it is executed.
What remains is to execute the verb definition in the parameters if they have not been executed already, and to execute the location definition if they where declared with the `After` qualifier.

So in short (with base class definitions of the outermost location being the outermost and the instance bound to the last syntax parameter the innermost):

* From the inside out, find any `Before` or `Only` definitions and execute them (stop if `Only` found).
* From the outside in, execute any definitions not already executed and not declared with the `After` qualifier.
* Execute the remaining verb definitions (those with an `After` qualifier) from the inside out.

The second item in the above list is equivalent to the normal order of execution, without any qualifiers.

The qualifiers are a powerful but confusing concept.
The normal order of execution is usually appropriate and only in special cases should qualifiers be used.
When they are needed, you will find that one qualifier at the correct definition will normally do the trick.
The above algorithm is used to get a strict definition of the execution order.
It is not expected that all this complex behaviour will be needed in practice.


[NOTE]
================================================================================
All ``Check``s (((CHECK, execution order))) for a `Verb` will always be run in the normal order regardless of any `Before`/`After`/`Only` qualifiers.
================================================================================



An example of the use of qualifiers is to ensure that only the verb body within the object is executed:


[source,alan]
--------------------------------------------------------------------------------
The bomb IsA object
  Verb examine
    Does Only
      "Your curious fingering at the intricate
       mechanism sets it of. BOOOM!"
      Quit.
  End Verb examine.
End The bomb.
--------------------------------------------------------------------------------


This also illustrates the fact that the most commonly used qualifier is the `Only` qualifier since it is used whenever all other behaviour is replaced by some special behaviour.



== EVENTs

An (((EVENT))) `Event` is a sequence of statements executed at a specified time (count of turns).
It is also executed at some specific location.
An event can e.g. be used to create an explosion where the bomb is three moves from now or to let the ceiling of the cave fall down in five moves.

[source,alan]
--------------------------------------------------------------------------------
Event nearby_explosion
  "Somewhere in the distance there is an explosion."
  Make bomb gone_off.
  Schedule small_avalanche After 2.
End Event.
--------------------------------------------------------------------------------

The body of an event can be any sequence of statements.
however, they can not refer to any parameters, since no verb is executing, nor to the `Current Actor`.
See <<Run-Time Contexts,_Run-Time Contexts_>>.

Events may be scheduled and cancelled with the `Schedule` and `Cancel` statements (see <<EVENT Statements,_EVENT Statements_>>).



== Rules

Syntax:
(((RULE, syntax for)))
(((BNF, rules of, WHEN (in rule))))

[source,bnf]
--------------------------------------------------------------------------------
rule = 'WHEN' expression ('THEN' | '=>')
           {statement}
       ['END' 'WHEN' '.' ]
--------------------------------------------------------------------------------


A (((RULE))) _rule_ is an arbitrary expression, which, when true, results in the execution of some given statements.
Rules can only be declared on the global level (not inside classes or instances).
The main intended use of rules is to detect particular situations and then trigger some action.
Typically they can be used to make things happen when certain situations arise, such as starting an actor when the hero enters the cave.

Here is an example that investigates if the hero is in the cave and if so, activates the monster:

[source,alan]
--------------------------------------------------------------------------------
When hero At cave And monster Not active Then
  Use Script hunting For monster.
End When.
--------------------------------------------------------------------------------

The expression that is tested may of course have any level of complexity:

[source,alan]
--------------------------------------------------------------------------------
When hero At cave
  And (monster Is hungry Or monster Is angry)
  And sword Not In hero
=>
  Use Script eat_hero For monster.
End When.
--------------------------------------------------------------------------------

Each actor action and event execution is considered atomic (it can't be divided into smaller parts).
All rule conditionals are evaluated (((RULE, execution))) after each actor (including the player) has acted (script step and player command respectively) and after each event has executed.
In effect this will mean that a change in state will be detected almost immediately, if there is a rule for detecting that change.

The statements within the rule are triggered when the condition _becomes_ true.
In the first example, this means that if the monster is not active, the statements will be executed when the hero enters the cave (`hero At cave` becomes true).
A rule body can never be executed twice in succession unless the conditional has been evaluated to false in between.
In the example above, the triggering of the `hunting` script for the monster will not happen again unless either the hero has left the cave and entered it again, or the monster has been `active` and then become `NOT active` again.

The use of parameters, `Current Actor`, `Current Location`, `Here` and `Nearby` is not allowed in rules conditionals or bodies.

Rules are executed at no location.
Therefore, within _rules_ it's not possible to communicate directly with the player via output statements (since the hero cannot be where the rule is executing, see <<Output Statements>>).
Triggering an `Event` that handles the output intended for the player is the recommended solution to this.

The following is a complete game using a rule:

// FIXME: Render 'Count IsA actor, At kitchen = 1' in different BG color!

[source,alan, subs="+quotes"]
--------------------------------------------------------------------------------
The kitchen IsA location
  Exit x To kitchen.
End The kitchen.

When Count IsA actor, At kitchen = 1
  Then Schedule whee At actor After 0.
End When.

Event whee
  "Whee!"
End Event.

Start At kitchen.
--------------------------------------------------------------------------------


In this example the _rule_ conditional (i.e. `Count IsA actor, At kitchen = 1`) is using an aggregation (`count`, see <<Aggregates>>) over two filters (see <<Filters>>) that will count the number of ``actor``s at the `kitchen`, and when that number becomes one, the rule will trigger and execute the statements, in this case scheduling an event that handles the presentation of the output to the player.

Again, remember that rules are checked after each actor has moved.
What happens if there are more actors in play and they move in and out of the kitchen, is left as an exercise to the reader.



== SYNONYMS

Syntax:
(((BNF, rules of, SYNONYMS)))
[source,bnf]
--------------------------------------------------------------------------------
synonyms = 'SYNONYMS' {synonym_declaration}

synonym_declaration = word {',' word} '=' word '.'
--------------------------------------------------------------------------------

A (((SYNONYMS, declaration))) `Synonyms` declaration declare words that, when used in player input, are always interchangeable.
For example:

[source,alan]
--------------------------------------------------------------------------------
Synonyms
  'i', 'invent' = 'inventory'.
  'q' = 'quit'.
--------------------------------------------------------------------------------

The word on the right hand side of the equal sign must be a word defined elsewhere in the adventure source, such as (part of) an instance name (a noun or adjective), a direction or a verb.
The list of words on the left-hand side contains new words (_not_ defined elsewhere) that always will be interpreted as being replaced by the word on the right in the player input.

Synonyms are player words that can be interchanged.
Defining synonyms for verb names will not always give you the result that you expect.
The following example is incorrect.

[source,alan]
--------------------------------------------------------------------------------
Synonyms
  'examine' = look_at.
Syntax
  look_at = 'look' 'at' (obj).
Verb look_at ...
--------------------------------------------------------------------------------

This will result in an error message indicating that the synonym word `look_at` is not defined.
This is because the `Syntax` (see <<Additions>>) defined the verb `look_at` to have the specified syntax (including the player words '`look`' and '`at`'), the player word `look_at` is not defined, which is as well as the player would not be able to input a word with an underscore (see <<Player Input>>).

You can achieve the desired effect by instead giving multiple verb identifiers in the verb declarations; this will give the same verb bodies (checks and actions) to multiple verbs.
See <<VERBs,the section on _VERBs_>> for details on verb declarations.

It is also possible to define multiple names for an instance to achieve other effects similar to synonyms.
See <<NAMEs>> for a description of this.



== MESSAGEs

The Alan system has a number of standard messages built in.
These messages are presented to the player in various situations, both normal and otherwise.
An example is the following:


[example,role="gametranscript"]
================================================================================
&gt; go north +
You can't go that way.
================================================================================


The response "`You can't go that way.`" is a typical example of such system messages (for details see <<Input Response Messages>>).

// @NOTE @thoni56:
//    It's not clear what "to the settings you select" is referring to:
//    The general Alan settings, or the adventures' settings (as in the epoch
//    and environment the game takes place)?

To better adapt the user dialogue to the settings you select, Alan allows you to define your own version of these messages.
The grammar for this is
(((BNF, rules of, MESSAGE)))

[source,bnf]
--------------------------------------------------------------------------------
messages = 'MESSAGE' {message}

message = id ':' {statement}
--------------------------------------------------------------------------------


An example would be:

[source,alan]
--------------------------------------------------------------------------------
Message
  NOWAY: "There is no exit in that direction."
--------------------------------------------------------------------------------

If the above where used in the source for the same game as the previous example, it would instead look like:


[example,role="gametranscript"]
================================================================================
&gt; go north +
There is no exit in that direction.
================================================================================



The `Message` constructs allows general statements following the message identifier:

[source,alan]
--------------------------------------------------------------------------------
Message NOWAY:
  If Random 1 To 2 = 1 Then
    "There is no way in that direction."
  Else
    "You can't go there."
  End If.
--------------------------------------------------------------------------------


The standard message for `Noway` is replaced by the output from the statements in the definition.
For a complete list of all the identifiers of messages and their use, see <<Run-Time Messages>>.



=== MESSAGE Parameters

`Message` sections must be declared at the global level, but to make it possible to create high-quality messages, parameters are available in message sections.
Which parameters are available vary depending on the message, the details for each message is available in <<Input Response Messages>>.

The parameters can be used in the same way as in verb bodies.
The names of the parameters are "`parameter1`", "`parameter2`", etc.
The type of the parameters will also vary.

For some messages, a parameter is an instance.
In these cases, the instance is always of the predefined `entity` class.
Any attribute available for this class will be available in message sections with instance parameters.


[NOTE]
================================================================================
If the message must be modified according to the case of the noun, which is the case with adjectives and negative forms in many languages, an attribute available on all instances can be used to select the correct form.
================================================================================



== PROMPT Section

The (((PROMPT, section))) `Prompt` section allows you to customize the way players are prompted for their input.
(((BNF, rules of, PROMPT)))

[source,bnf]
--------------------------------------------------------------------------------
prompt = 'PROMPT' {statement}
--------------------------------------------------------------------------------

The default prompt for player input, which will be used if no `Prompt` section is declared, looks like this:


[example,role="gametranscript"]
================================================================================
&gt;
================================================================================



Using the following `Prompt` section it can be set to something else:

[source,alan]
--------------------------------------------------------------------------------
Prompt "What now?"
--------------------------------------------------------------------------------

Then the player will of course see:


[example,role="gametranscript"]
================================================================================
What now?
================================================================================




In fact, the `Prompt` section allows any statements, not just strings.
So you can have the prompt change during the game.

[source,alan]
--------------------------------------------------------------------------------
Prompt
  "Hello" Say hero. "!$n"
  "Where do you want to go from"
  Say Current Location. "?"
--------------------------------------------------------------------------------

This will give the following output:


[example,role="gametranscript"]
================================================================================
*Pirates Bay Harbor* +
You can see the town of Pirates Bay to the north, and your ship is at the docks, to the south. +
Hello Jack Sparrow! +
Where do you want to go from Pirates Bay Harbor?
================================================================================


[NOTE]
================================================================================
The prompt section is global and applies to the whole game.
There is currently no way to dynamically customize the prompt except by using the statements inside the `Prompt` section itself.
================================================================================



== START Section

The (((START, section))) `Start` section defines where the player (the hero) will be at the start of the game.
This must be a location.
Optionally this may be followed by statements to be executed at the beginning of the game, such as hello-messages or short instructions as well as starting any actors and scheduling events.
(((BNF, rules of, START)))

[source,bnf]
--------------------------------------------------------------------------------
start_section = 'START' where '.' {statement}
--------------------------------------------------------------------------------

An example would be:

[source,alan]
--------------------------------------------------------------------------------
Start At outside_house.
  Schedule bird_chirp After 5.
--------------------------------------------------------------------------------

Only the `At What` form of the *WHERE* construct (see <<WHERE Specifications>>) is allowed in the `Start` section.
Any statements are allowed in the start section but they cannot refer to any parameters.

The start section must be the last declaration in an Alan source.



== Statements



=== Output Statements

There are various ways to present output (((output statements))) to the player: string output, descriptions, printing expressions, listing container content and showing pictures.

The interpreter intersperses your output with spaces whenever needed.
This might for example occur between two output strings:

[source,alan]
--------------------------------------------------------------------------------
"There is a door into the kitchen."
If kitchenDoor Is open Then
  "It is open."
End If.
--------------------------------------------------------------------------------

If handled simple-mindedly the two texts would be adjoined and you as an author would need to cater for this.
Instead Alan realizes that a space is required between them.
This space is automatically inserted by the interpreter during game play.
This is also the case if the output from a `Say` statement is followed by an output string.

[source,alan]
--------------------------------------------------------------------------------
"Your wristwatch shows" Say hours Of watch.
". Time to go."
--------------------------------------------------------------------------------

However, as in this example, this is not always the intended output.
Particularly, if the `Say` statement terminated the previous sentence, as in the example, we want the full stop to be placed immediately after the output.
So, the Alan interpreter will leave out the space between two outputs if the second starts with a period (full stop) followed by a space, or is the single character in the string.
This special handling also applies to strings starting with a comma.

Whenever an output statement is executed, the result will be printed on the players terminal with the following important exception: if an output statement is executed at a game location other than the hero's location, the output won't be shown.
This important feature will relieve the author from the burden of constantly considering what the player will see.
It can be used in the following way:

[source,alan]
--------------------------------------------------------------------------------
"Charlie Chaplin leaves the house through the front door."
Locate charlie_chaplin At outside_house.
"Charlie Chaplin comes out from the nearest house."
--------------------------------------------------------------------------------

If the hero is inside the house or out in the street, he will get different views of the situation.
This feature ensures that the player only sees what is going on at the current location, and allows for easy adaptation to various viewpoints on the events without the need for any special tests.
But see <<Distant Events,_Distant Events_>> for a solution in case the hero need to be informed about things happening in other locations.



==== String Statement

Syntax:
(((BNF, rules of, output statements, string)))
[source,bnf]
--------------------------------------------------------------------------------
output_statement = string
--------------------------------------------------------------------------------

The simplest case of output is just a ((string)), i.e. any text, possibly stretching over multiple lines, surrounded by double quotes.
See also <<Strings>> for some detailed descriptions on the definition of strings.

Some character combinations (((character combinations, in strings))) have special meaning for the printout:

// @TODO: Should add a Title and anchor to this list of special symbols, as they
//        are rather important and the user might wish to find it often for
//        consultation.

// @TODO @thoni56:
//    Possibly, these special chars should be given a name or definition of
//    some type, so they can be mentioned in the text too!
//    ("characters combinations" isn't an intuitive way to refer to them;
//     maybe "escape sequences"? they are similar to esc.seq. in many ways)

[literal, role="plaintext", subs="normal"]
................................................................................
*$p*    New paragraph (usually one empty line)
*$n*    New line
*$i*    Indent on a new line
*$t*    Insert a tabulation
*$$*    Escape from automatic space insertion and capitalization
*$a*    The name of the actor that is executing
*$l*    The name of the current location
*$v*    The verb the player used (the first word)
*$_*    Print this as a '$' if in conflict with other symbols
................................................................................


// @NOTE: I've substituted the underscore symbol with its XML Entity because it
//        was breaking syntax highlighting in Sublime Text's AsciiDoctor package!
//        The problem is only in ST, and the original compiled well, but it broke
//        up the whole document syntax from this point on, making it impossible
//        to work on it using Sublime Text.

[NOTE]
================================================================================
You might want to output "`$400`" but "`$4`" will be interpreted as the indefinite form of the fourth parameter, as described below.
So you need to use the '`&#95;`' to make that happen (`$&#95;400`).
================================================================================




The following can be used to refer to parameters while executing a verb, but the `Say` statement (see below) is safer and preferred whenever possible:

// @NOTE @thoni56:
//    These special chars should be given a caption and a proper name too!

[literal, role="plaintext", subs="normal"]
................................................................................
*$<n>*     The parameter <n> (<n> is a digit > 0, e.g. "$1")
*$+<n>*    Definite form of parameter <n>
*$0<n>*    Indefinite form of parameter <n>
*$-<n>*    Negative form of parameter <n>
*$!<n>*    Pronoun for the parameter <n>
*$o*       The current object (first parameter)
................................................................................


[NOTE]
================================================================================
The `$<n>` formats must be used with care as they are not checked at compile time, e.g. you can use "```$+1```" in a context where no parameter is defined which would lead to a run-time error.
To avoid the risk of any run-time problems use the `Say` statement with the parameter name wherever possible.
See <<SAY Statement,_SAY Statement_>> below.
================================================================================



[NOTE]
================================================================================
The use of `$o` is deprecated.
The `<n>` variants are better, but the recommended use is to refer to the parameters using their parameter names in a `Say` statement instead.
This will ensure full reference analysis by the compiler protecting against any runtime error.
================================================================================


==== STYLE Statement

Syntax:
(((BNF, rules of, STYLE)))

[source,bnf]
--------------------------------------------------------------------------------
style_statement = 'STYLE' style '.'

style = 'NORMAL'
      | 'EMPHASIZED'
      | 'PREFORMATTED'
      | 'ALERT'
      | 'QUOTE'
--------------------------------------------------------------------------------

// @FIXME @thoni56:
//    The following paragraph doesn't clarify that to end an inlne EMPHASIZED
//    style NORMAL should be used --- it seems to say that even NORMAL would
//    apply to the whole paragraph.

The style of the text output can be controlled using the `Style` statement.
With the exception of the `Emphasized` style, the styles are intended to be applied to whole paragraphs.
The style indicated in the statement applies until another `Style` statement is executed.


// @TODO: Adding an example here would be nice.


[NOTE]
================================================================================
The exact visual appearance of the styles is implementation dependent.
In fact, there is no guarantee that the styles will actually differ.
================================================================================


==== DESCRIBE Statement

Syntax:
(((BNF, rules of, DESCRIBE)))
(((BNF, rules of, output statements, DESCRIBE)))

[source,bnf]
--------------------------------------------------------------------------------
output_statement = 'DESCRIBE' what '.'
--------------------------------------------------------------------------------

The (((DESCRIBE, statement))) `Describe` statement executes the description part for an instance, such as an actor, an object or a location.
If no such description exists a default description, such as:

[example,role="gametranscript"]
================================================================================
There is a coin here.
================================================================================

is used instead.
In this case, if the instance has the container property, a `List` statement is also executed for that object automatically (see below).

If a `Describe` statement is executed for another instance during the execution of the `Description` clause, the system will recognise this and make sure that the second instance is not described more than once.
This makes it possible to use instances as parts of a location and embedding their description at the correct place in the longer description of the location.

[source,alan]
--------------------------------------------------------------------------------
"This office is dusty and probably hasn't been used for
 many years."
DESCRIBE desk.
"To the west is an open door, and to the east you can see the
 staircase.""
--------------------------------------------------------------------------------


==== SAY Statement

Syntax:
(((BNF, rules of, SAY)))
(((BNF, rules of, output statements, SAY)))

[source,bnf]
--------------------------------------------------------------------------------
output_statement = 'SAY' [form] expression '.'

form = 'THE' | 'AN' | 'IT' | 'NO'
--------------------------------------------------------------------------------


The (((SAY, statement))) `Say` statement will output a short description of what is referred to by the expression.
If it refers to an instance, it will print its name or execute its `Mentioned` clause if one is available.
If it refers to an attribute, it will print its value, such as an integer or a string.
Parameter names are also allowed in the `Say` statement, which, of course will result in a short description of the instance to which it is bound, or in a literal printout if the parameter was a `string` or `integer`.

[source,alan]
--------------------------------------------------------------------------------
If contents Of bottle > 0 Then
  "In the bottle there are still"
  Say contents Of bottle.
  "litres of water left."
Else
  "The bottle is empty."
End If.
--------------------------------------------------------------------------------


If the *WHAT* part refers to an instance, the optional *form* may be used to control in which form the instance will be output.

If `The` is used, then the definite form will be employed, which is usually the short form preceded by a definite article.
Correspondingly, the use of `An` indicates an indefinite form.
A third form, using `No`, is also available.
It indicates that the negative form (as defined by the negative article or form) should be output.
Refer to <<Articles and Forms>> for a description of the definite/indefinite articles and forms.
Finally, the `It` form will print the pronoun associated with the instance.


==== LIST Statement

Syntax:
(((BNF, rules of, LIST)))
(((BNF, rules of, output statements, LIST)))

[source,bnf]
--------------------------------------------------------------------------------
output_statement = 'LIST' expression '.'
--------------------------------------------------------------------------------

The (((LIST, statement))) `List` statement lists all objects in a container together with the `Header` as specified for the container.
If the container is empty, the statements in the `Empty` clause of the container are executed instead.

[source,alan]
--------------------------------------------------------------------------------
"The chest is heavy."
If chest Is open Then
  List chest.
End If.
--------------------------------------------------------------------------------

Of course, the instance being listed must be an instance that has the `Container` property, which may be inherited.
This instance can be referred to by being bound to a parameter or a ((reference attribute)), for example.

=== Multimedia Statements

Alan has some multimedia provisions, although they may not be available on every platform and implementation.
The `Show` statement, presents an image in the output window, and the `Play` statement plays a sound.

The Alan compiler will always support the multimedia statements, but a particular interpreter might not do so.
Most GLK-based interpreters will support them, but other kind of interpreters might too.
The game will still play fine, but the multimedia resources will be silently ignored.
There is also no way to check for this in your source code.
So, don't rely on them for your story, particularly do not give the player necessary information only through pictures.

Image and sound files are analyzed by the compiler and copied into an Alan v3 resource file (file extension *.a3r*) that must be distributed with your game file, otherwise they will not be available during game play.
The original file will be left untouched.

The format of the resource file follows the standard interactive fiction resource file format "`blorb`" and supports images of JPEG and PNG types, and sounds in MOD and AIFF formats.

If a resource file is referenced from multiple statements, it will only be copied once.
The Alan compiler uses the file extension to determine the media type of the file.
The following extensions are recognized: *.jpg*, *.jpeg*, *.png*, *.mod*, *.aif* and *.aiff*.


==== SHOW Statement

Syntax:
(((BNF, rules of, SHOW)))
(((BNF, rules of, output statements, SHOW)))

[source,bnf]
--------------------------------------------------------------------------------
output_statement = 'SHOW' id '.'
--------------------------------------------------------------------------------

// NOTE: It's not very clear when it says "a quoted identifier is USUALLY required".
//       If the file extension is mandatory, then a quoted id is ALWAYS required;
//       otherwise not. Clarify...

The *id* should be the name of an image file.
Since filenames may contain various special characters, a quoted identifier (see <<Filenames,_Filenames_>>) is usually required.

Alan currently supports the JPEG and PNG formats only.

==== PLAY Statement

Syntax:
(((BNF, rules of, PLAY)))
(((BNF, rules of, output statements, PLAY)))

[source,bnf]
--------------------------------------------------------------------------------
output_statement = 'PLAY' id '.'
--------------------------------------------------------------------------------

The *id* should be the name of a sound file.
Since filenames may contain various special characters, a quoted identifier (see <<Filenames,_Filenames_>>) is usually required.

Alan currently supports the MOD and AIFF formats only.


=== Manipulation Statements


==== LOCATE Statement

The (((LOCATE, statement))) `Locate` statement is a way of transferring instances to new locations.
When executed, the indicated instance will be placed at the specified location.
(((BNF, rules of, LOCATE)))

[source,bnf]
--------------------------------------------------------------------------------
locate_statement = 'LOCATE' what where '.'
--------------------------------------------------------------------------------

For a description on how to specify *WHERE*, see <<WHERE Specifications>>.
When an actor is located at a new location the `Does` clause of that location is always executed.

One special case of the `Locate` statement is when the predefined actor `hero` is located somewhere.
This is analogous to the player typing a direction, i.e. the hero will be located at the appropriate location.
Under particular circumstances, you may want to locate the player at a different location as a side effect of another action.
For example:

[source,alan]
--------------------------------------------------------------------------------
Event explosion
  "Suddenly the door seems to bulge outwards, it bursts
   open throwing rocks and splinters everywhere. The
   impact of the explosion literally throws you back
   out in the hallway."
  Locate hero At hallway.
End Event explosion.
--------------------------------------------------------------------------------

In this case, the new location will be described and the `Does` clause of that location executed.

Another special case is when locating (((locating inside containers))) something inside a container.
The `Locate` statement will then cause the execution of the `Limits` of that container, and if any of the limits are exceeded the complete player turn is aborted immediately, resulting in no more statements being executed.
So, if a player command should result in locating an object inside a container, it's better to place the `Locate` statement as early as possible, as this enforces the `Limits` checks at the beginning of this player turn.

A very special third case is locating a location at another location.
Locations can be (((nested locations))) nested this way, resulting in an outer location working as a region or surrounding for the inner location.
The effect of this is that any instances present in the outer location are reachable from the inner.



==== EMPTY Statement

The (((EMPTY, statement))) `Empty` statement locates all instances currently located inside the given container (instance with the `Container` property) at a certain location.
(((BNF, rules of, EMPTY)))

[source,bnf]
--------------------------------------------------------------------------------
empty_statement = 'EMPTY' what [where] '.'
--------------------------------------------------------------------------------

The meaning of the *WHERE* part is the same as in the `Locate` statement.
If it is not specified the instances will be placed at the current location.

[source,alan]
--------------------------------------------------------------------------------
Empty inventory Here.
"You seem to have lost most of your possessions. Well,
 you can't have everything."
Locate hero At restart_point.
--------------------------------------------------------------------------------



==== STRIP Statement

The (((STRIP, statement))) `Strip` statement is used to manipulate the contents of (((string, functions))) strings.
(((BNF, rules of, STRIP)))

[source,bnf]
--------------------------------------------------------------------------------
strip_statement = 'STRIP' [direction] [count] [size]
                    from_clause [into_clause] '.'

direction = 'FIRST' | 'LAST'

count = expression

size = 'WORDS' | 'CHARACTERS'

from_clause = 'FROM' expression

into_clause = 'INTO' expression
--------------------------------------------------------------------------------

You can use it to remove words or characters from a string, starting from the beginning or the end.
The words or characters that are removed may be placed in an attribute as specified by the optional `Into` clause.
If the statement is used to manipulate words, blanks and separators are used to separate the words.
In this case, any resulting string is also free of leading and trailing blanks.

// @NOTE @thoni56:
//    It's not clear in the following example if the line:
//
//       Strip First Word From topic Into topic.
//
//    will replace the contents of 'topic', or if it will append to them, etc.

A short example:

[source,alan]
--------------------------------------------------------------------------------
The eliza IsA actor
  Has topic "".
  Verb talk_to
    Does
      Set topic Of eliza To "sailing music cooking reading".
      Strip Random 0 To 2 Words From topic Of eliza.
      Strip First Word From topic Into topic.
      "And how do you feel about" Say topic Of eliza. "?"
  End Verb.
End The eliza.
--------------------------------------------------------------------------------


=== EVENT Statements


==== SCHEDULE Statement

`Schedule` (((SCHEDULE, statement))) will queue an event to occur at a specified location after the number of player turns specified by the expression.
(((BNF, rules of, SCHEDULE)))

[source,bnf]
--------------------------------------------------------------------------------
event_statement = 'SCHEDULE' what [where]
                    'AFTER' expression '.'
--------------------------------------------------------------------------------

For example:

[source,alan]
--------------------------------------------------------------------------------
Schedule ringing At clock After 60 - minutes Of clock.
--------------------------------------------------------------------------------

The number of moves can be zero, i.e. `After 0` means that the event will occur now (during this player turn, probably last, though).
If no location is specified, `Here` is assumed, i.e. it will be executed at the current location, the location where the statement itself was executed.

An important case is when a `Schedule` statement without a *WHERE* clause is executed inside a _rule_.
Since rules are executed at nowhere so will the event.
This means that any printout will occur nowhere, and will thus be invisible to the player.

The *WHERE* expression can be any expression yeilding an instance type, such as the identifier of a location or actor, an attribute referring to an instance.
The event will occur wherever that instance is when the event occurs.
The event will '`follow`' the instance.

There is an interesting difference between the following two statements:

[source,alan]
--------------------------------------------------------------------------------
Schedule explosion At hero After 1.
Schedule explosion At location Of hero After 1.
--------------------------------------------------------------------------------

The first statement will schedule the event at the hero and will execute where the hero is after one turn.
The second will schedule the event at the location where the hero was when the statement was executed, even if the hero has moved after that.

Executing a second `Schedule` statement for the same event before it has occurred will reschedule the event to the new time.
An event can only be scheduled for one execution at a time.


[NOTE]
================================================================================
The event can be specified by giving an event identifier or referring to an attribute of `Event` type.
================================================================================


==== CANCEL Statement

`Cancel` (((CANCEL, statement))) will remove the referenced event from the queue of scheduled events.
(((BNF, rules of, CANCEL)))

[source,bnf]
--------------------------------------------------------------------------------
cancel_statement = 'CANCEL' what '.'
--------------------------------------------------------------------------------

Canceling an `Event` which is not currently scheduled is not considered an error.


// @TODO: Could add a comment to the example to show that/where 'defuse' cancels
//        an EVENT that might not be shceduled (i.e. 'explosion').

[source,alan]
--------------------------------------------------------------------------------
Event ticking
  "Tick..."
  If timer Of bomb = 0 Then
    Schedule explosion After 1.
  Else
    Decrease timer Of bomb.
    Schedule ticking After 1.
  End If.
End Event ticking.

Verb defuse
  Does
    Cancel ticking.
    Cancel explosion.
    "Phuuui! That was close."
End Verb defuse.

Start At office.
  "The bomb is ticking..."
  Schedule ticking After 1.
--------------------------------------------------------------------------------

// @TODO @thoni56:
//    Clarify better the following, possibly via an example:

The event can be referenced using any expression of `Event` type, e.g. an attribute.



=== Assignment Statements

There are a number of statements for changing values of attributes.


==== MAKE Statement

The (((MAKE, statement))) `Make` statement is used to set or reset Boolean attributes.
(((BNF, rules of, MAKE)))

[source,bnf]
--------------------------------------------------------------------------------
make_statement = 'MAKE' what something '.'

something = ['NOT'] id
--------------------------------------------------------------------------------

Examples:

[source,alan]
--------------------------------------------------------------------------------
Make door open.
Make door Not open.
--------------------------------------------------------------------------------


==== INCREASE and DECREASE Statements

Syntax:
(((BNF, rules of, INCREASE)))
(((BNF, rules of, DECREASE)))

[source,bnf]
--------------------------------------------------------------------------------
increase_statement = 'INCREASE' what [by] '.'

decrease_statement = 'DECREASE' what [by] '.'

by = 'BY' expression
--------------------------------------------------------------------------------


The `Increase` (((INCREASE, statement))) and `Decrease` (((DECREASE, statement))) statements modify the value of numeric attributes by increasing or decreasing it by the value of the expression given in the optional `By` clause.
If no `By` clause is specified the attribute is changed by one.

[source,alan]
--------------------------------------------------------------------------------
Increase level Of bottle By contents Of mug.
Decrease lives Of hero.
--------------------------------------------------------------------------------



==== SET Statement

The (((SET, statement))) `Set` statement is used when assigning values to numeric, string, reference or set valued attributes.
(((BNF, rules of, SET)))

[source,bnf]
--------------------------------------------------------------------------------
set_statement = 'SET' what 'TO' expression '.'
--------------------------------------------------------------------------------

Examples:

[source,alan]
--------------------------------------------------------------------------------
Set mood Of king_tut To 3.
Set hour Of clock To hour Of clock + 1.
--------------------------------------------------------------------------------

Setting attributes of reference or set type requires that the expression follows the type and subclass compatibility rules.
For example, you can only assign:

* *integer type expressions* to an integer attribute:
+
--
[source,alan]
--------------------------------------------------------------------------------
Set intAttr To 4. -- Correct if intAttr is of Integer type
Set intAttr To "hi". -- Incorrect
--------------------------------------------------------------------------------
--
* *instance type expressions* to a ((reference attribute)) whose class is a parent of the instance in the expression:
+
--
[source,alan]
--------------------------------------------------------------------------------
Has suspect butler.
Set suspect Of detective To someLocation. -- Incorrect
--------------------------------------------------------------------------------
--
* *set type expressions* to a Set type attribute if all members in the expression are instances of a subclass of the member class of the target attribute.
Here are some examples, given the natural types of the instances:
+
--
[source,alan]
--------------------------------------------------------------------------------
Has friends {monica, ross, chandler, rachel, phoebe, joey}. -- 'person's
Set friends Of mine To {book}. -- Incorrect, probably not a 'person'
Set friends Of mine To {}. -- Correct, an empty set is always OK
Set friends Of mine To {suspect Of detective}. -- Maybe correct
--------------------------------------------------------------------------------
--

==== INCLUDE Statement

The (((INCLUDE, statement))) `Include` statement is used to include a new member in a Set.
(((BNF, rules of, INCLUDE)))

[source,bnf]
--------------------------------------------------------------------------------
include_statement = 'INCLUDE' expression 'IN' set '.'
--------------------------------------------------------------------------------

Typically, this is used to add an instance or value to a collection of similarly typed members.
See <<Set Type>> for an explanation of the Set type.
Attempts to include a member already present in the Set will be silently ignored without generating duplicate entries.

The Set may be identified using an expression involving (((reference attribute))) reference attributes:


[source,alan]
--------------------------------------------------------------------------------
Include hitchhiker In friends Of driver Of car.
--------------------------------------------------------------------------------


And vice versa:

[source,alan]
--------------------------------------------------------------------------------
Include driver Of car In friends Of hitchhiker.
--------------------------------------------------------------------------------


==== EXCLUDE Statement

The `Exclude` statement is the reverse of the `Include` statement.
It removes a member from a Set.
(((BNF, rules of, EXCLUDE)))

[source,bnf]
--------------------------------------------------------------------------------
exclude_statement = 'EXCLUDE' expression 'FROM' set '.'
--------------------------------------------------------------------------------

Attempts to remove something not included in the Set will be silently ignored; therefore, it's guaranteed that after executing this statement the instance or value of its expression will not be in the Set.

[NOTE]
================================================================================
The inclusion or exclusion of an instance will not affect its location.
A member may be included in multiple Sets.
================================================================================



=== Conditional Statements

In Alan there are two conditional statements: the common `If` statement and the `Depending On` statement.


==== IF Statement

The (((IF, statement))) `If` statement is essential for varying output and otherwise change the activities in the game.
(((BNF, rules of, IF)))
(((BNF, rules of, ELSE)))
(((BNF, rules of, ELSIF)))

[source,bnf]
--------------------------------------------------------------------------------
if_statement = 'IF' expression 'THEN' statements
                   { elsif_part }
                   [ else_part ]
               'END' 'IF' '.'

elsif_part = 'ELSIF' expression 'THEN' statements

else_part = 'ELSE' expression 'THEN' statements
--------------------------------------------------------------------------------

The expression is evaluated (see <<Expressions>> for details and examples of expression) and if it evaluates to true, the statements following the `Then` keyword are executed.
Otherwise, the expressions in any following `ElsIf` clauses are evaluated (in order) and the statements following the first expression that results in a true value is executed.
If none of the expressions in the `ElsIf` clauses evaluated to true, or if there are no `ElsIf` clauses, the statements following the `Else` keyword are executed.
The `Else` clause is optional.

// @NOTE @thoni56:
//   Previous paragraph, last line:
//      "The `Else` clause is optional"
//   ... so is the 'ElseIf' clause! Should add that too, for the sake of clarity?
//   Otherwise it makes the reader wonder why it was left out.

[source,alan]
--------------------------------------------------------------------------------
If minute Of clock = 59 Then
  Set minute Of clock To 0.
  Increase hour Of clock.
Else
  Increase minute Of clock.
End If.
If level Of bottle = 0 Then
  "You have no water."
ElsIf level Of bottle < 5 Then
  "You have almost no water left."
Else
  "You have plenty of water."
End If.
--------------------------------------------------------------------------------

`If` statements which have an `IsA` expression (see <<Class Expressions>>) are particularly important.
As an `IsA` expression test for the class of an instance, an `If` statement like:

[source,alan]
--------------------------------------------------------------------------------
If i IsA actor Then ...
--------------------------------------------------------------------------------

// @FIXME @thoni56:
//    Looks like some words were lost in the sentence:
//
//        This means that references to attributes [...]  ??? as if `i` belong"
//
//    The sentence is incomplete, some words must have been deleted by mistake.

will quarantee that for any statement inside the `Then` part of that statement, the `i` will be of the class `actor`.
This means that references to attributes, container properties, actor scripts, etc. as if `i` belongs to the class `actor`, even if that was not known outside of the `If` statement.

A typical example where this is helpful is inside verbs where parameters can be restricted to more general classes by the `Syntax` and the `Verb` body can still perform specific actions only allowed on more specialized classes.

Another example would be looping over a set of unknown instances:

[source,alan]
--------------------------------------------------------------------------------
For Each e IsA entity, Here Do
  If e IsA actor Then ...
  If e IsA object Then ...
  If e IsA container_object Then ...
End For.
--------------------------------------------------------------------------------



==== DEPENDING ON Statement

The (((DEPENDING ON, statement))) `Depending On` statement enables us to select one of a number of possible conditional cases depending on an expression.
(((BNF, rules of, DEPENDING ON)))

[source,bnf]
--------------------------------------------------------------------------------
depend_statement = 'DEPENDING' 'ON' expression
                       {case}
                   'END' 'DEPEND' '.'

case = right_hand_side 'THEN' statements
     | 'ELSE' statements
--------------------------------------------------------------------------------

// @TODO: Rephrase Paragraph.
//    Rephrase from "The *expression* part...".
//    The part explaining the BNF rules could be made more readable and clearer.

The *expression* part can be any expression.
The *right_hand_side* part is the right hand side of any valid expression.
When combined with *expression* (as the left hand side of the expression) they will form a complete expression, which is evaluated.

A simple example of the `Depending On` statement:

[source,alan]
--------------------------------------------------------------------------------
Depending On weight Of obj
  = 1 Then "light as a feather"
  Between 2 And 10 Then "carryable"
  Between 10 And 20 Then "heavy"
  > 20 Then "immobile"
  Else "weightless"
End Depend.
--------------------------------------------------------------------------------

The purpose of this example is to test the `weight Of obj` and select one of the cases depending on its value.
If it's equal to one, then the first case will be executed.
If none of the cases match, the optional `Else` case will be executed (in this case it will only be executed for weights of zero or less).

The cases are tested in the specified order.
At most, one case will be executed.
In the example, a weight of ten will render as "carryable".

The above tests are thus equivalent to:

[source,alan]
--------------------------------------------------------------------------------
If weight Of object = 1 Then "light as a feather"
ElsIf weight Of object Between 2 And 10 Then "carryable"
ElsIf weight Of object Between 10 And 20 Then "heavy"
ElsIf weight Of object > 20 Then "immobile"
Else "weightless"
End If.
--------------------------------------------------------------------------------


A `Depending On` statement is preferable to a chain of `If` statements when the same expression will be tested for multiple matches.



=== Actor Statements

Actor statements are statements that are used to control actors.

==== USE Statement

The (((USE, statement))) `Use` statement starts execution of a given <<SCRIPTs,`Script`>> for a given actor.
(((BNF, rules of, USE)))

[source,bnf]
--------------------------------------------------------------------------------
use_statement = 'USE' script ['FOR' actor] '.'
--------------------------------------------------------------------------------

The `For actor` clause is optional when writing code within a certain actor -- in this case, the statement applies to the actor (instance or class) containing the code.

[source,alan]
--------------------------------------------------------------------------------
Use Script playing For george.
--------------------------------------------------------------------------------


[NOTE]
================================================================================
For the *actor* clause you can use an expression such as a simple identifier, a parameter reference or a ((reference attribute)).
================================================================================



==== STOP Statement

The (((STOP, statement))) `Stop` statement stops an actor from proceeding with any script it may be executing.
In effect, it will abort it and put the actor in an idle state.
(((BNF, rules of, STOP)))


[source,bnf]
--------------------------------------------------------------------------------
stop_statement = 'STOP' actor '.'

actor = expression
--------------------------------------------------------------------------------


The most common case is the direct reference to an actor using its identifier.
More complex expressions resulting in an actor type value, such as a parameter reference or a ((reference attribute)), can be used as the *actor* clause.


// @NOTE: Changing "REPETITION" with "ITERATION" might be better!

=== Repetition Statements

The Alan language provides one compound statement for repetition, the `For Each` statement.
(((BNF, rules of, FOR EACH)))

[source,bnf]
--------------------------------------------------------------------------------
repetition_statement = 'FOR' 'EACH' id [filters] 'DO'
                           statements
                       'END' 'FOR' 'EACH' '.'

filters = filter { ',' filter }
        | 'BETWEEN' expression 'AND' expression
--------------------------------------------------------------------------------


You can optionally leave out either `For` or `Each`, but not both.

The *identifier* is called the _loop variable_, and its semantics are similar to a `Syntax` parameter.
It will be dynamically bound to instances, one for each repetition.
Inside the loop body (i.e. the *statements*) this variable can be referenced in the same way as a `Syntax` parameter.

The optional *filters* can be used to restrict the values in the loop.
If the `Between` form is used, the loop becomes an integer loop, resulting in the loop variable being of the integer type, and a loop range encompassing the values of the two expressions (included).
Otherwise, the loop variable will be of instance type and will consecutively assume the value of each instance fulfilling the filters.
See <<Filters>> for an explanation of filters.

// @FIXME: This whole paragraph should be rephrased and smoothened out:

Within the repetition, any references to the loop variable will refer to the bound instance, or integer value, in this repetition.

You can use any statements inside the repetition, e.g. to check for further conditions before operating on the instance.
For example:

[source,alan]
--------------------------------------------------------------------------------
For Each creature IsA actor Do
  If creature Here Then
    ...
  End If.
End For.
--------------------------------------------------------------------------------



=== Special Statements



==== QUIT Statement

`Quit` (((QUIT, statement))) prints a question giving the player the choice to restart the game, restore a previously saved game or to quit the game.
Any scoring or other printouts have to be made explicitly before executing the `Quit` statement.

// @TODO: Might be worth mentioning here that although the printed message can be
//        changed (mention related MESSAGE) the actual replies are hardconded into
//        Alan and can't be translated. Or at least, provide a cross reference to
//        "C.1. Input Response Messages > QUIT_ACTION"


==== LOOK Statement

`Look` (((LOOK, statement))) describes to the player the current location and what it contains (which location is going to be the current location depends on which context `Look` is being executed in).
First, the location name is printed out, then the `Description` part for the location is executed.
If you do not want the name of the location to be included, you can use a `Describe` statement instead.

Then, all object and actors at the location will be automatically executed by means of an implicit `Describe` for each of them.
Any objects or actors that were explicitly described using a `Describe` statements, will be excluded from this automatic `Describe`.

The equivalent of a `Look` is automatically performed when the hero enters a new location.


[NOTE]
================================================================================
As the player will only see output generated at the same location as the hero, a
`Look` executed by another actor at some other location will not be seen by the
player.
See <<Output Statements>> for more details on this important
consideration.
================================================================================



==== SAVE and RESTORE Statements

`Save` (((SAVE, statement))) saves the game on a file for later use with (((RESTORE, statement))) `Restore`.
Both `save` and `restore` asks the player for a file name to use for storing and restoring.
This allows the player to use unlimited number of save files.

If the player should be shown the current surroundings after a `Restore`, you will have to implement a player verb like:

[source,alan]
--------------------------------------------------------------------------------
Verb 'restore'
  Does
    Restore.
    Look.
End Verb 'restore'.
--------------------------------------------------------------------------------

[NOTE]
================================================================================
In the above example, the verb identifier `'restore'` was enclosed in single
quotes (i.e. a <<_words_identifiers_and_names,quoted identifier>>) to prevent
conflict with the reserved keyword `Restore`.
================================================================================


==== SCORE Statement

`Score` (((SCORE, statement))) is a way of rewarding the player by giving points for certain actions.
This is done using the statement:
(((BNF, rules of, SCORE)))

[source,bnf]
--------------------------------------------------------------------------------
score_statement = 'SCORE' integer '.'
--------------------------------------------------------------------------------

For example:

[source,alan]
--------------------------------------------------------------------------------
Score 25.
--------------------------------------------------------------------------------

// @TODO: It's worth mentioning here the 'HAVE_SCORED' MESSAGE that controls the
//        score printout, and maybe add a cross reference link to it in App C.1.

The first time every such statement is executed the points given are added to the player's current score. `Score` without any arguments prints a message indicating the current accumulated score.


// @FIXME @thoni56: Meaning Unclear.
//    The following note was unclear, but even after adjusting it it seems
//    ambiguos. The point is that some score-actions might not be strictly
//    necessary to complete the game, but might be instead some bonus actions
//    that add extra points. Possibly, the note should be rephrased to
//    clarify this point. Is there a reason why the default scoring system
//    can't handle bonus scores? The end of the note seems to suggest that
//    this is the case, but doesn't explain why...What are the implications
//    of a game which is winnable without carrying out every score action?

[NOTE]
================================================================================
The `Score` statements assume a simple scoring model: a number of specific actions are necessary to complete the game, and all of them are necessary to achieve the maximum number of points.
Negative scores are not allowed and once a score has been awarded it cannot be revoked, and it can't be awarded twice either.
For adventures requiring a more complex and varied scoring system (especially if the game can be successfully finished without performing all scoring actions, or in multiple ways), manual scoring should instead be implemented using attributes (e.g. on the hero) and suitable manipulation and test statements.
================================================================================



==== VISITS Statement

The (((VISITS, statement))) `Visits` statement changes the number of times a location can be visited before its long description is presented again:
(((BNF, rules of, VISITS)))

[source,bnf]
--------------------------------------------------------------------------------
visits_statement = 'VISITS' count '.'
--------------------------------------------------------------------------------

The value of the argument (*count,* which must be an integer number) controls the number of visits to a particular location between full descriptions.
The initial setting of 0 (zero) indicates that every time a particular location is visited its full description will be shown (which can also be expressed as: the full description will _not_ be shown 0 times in between).
Thus, a setting of 1 (one) would give a full description every second time the same location is visited.
Therefore:

[source,alan]
--------------------------------------------------------------------------------
Visits 0.
--------------------------------------------------------------------------------


will always show full descriptions (which is also the initial setting).


[TIP]
================================================================================
The classic and familiar commands *verbose*, *brief*, etc. can be imitated using different values in the `Visits` statement.
================================================================================



[IMPORTANT]
================================================================================
The handling of descriptions is rather conservative in that it also takes modified attributes into account.
If the `Visits` calculation would indicate no full description, a modified attribute of the location will cause the full description to be shown the next time.
That attribute might have caused the description of the location to change.
So the `Visits` handling ensures that the player will "`see`" all changes to the location.
If you set attributes of the location every time they are visited, the built-in `Visits` handling will not work as you expect.
================================================================================


(((predefined attributes, VISITS (LOCATION))))
(((attributes, predefined, VISITS (LOCATION))))
(((LOCATION, VISITS attribute)))
Associated with this is a predefined attribute, `visits`, that exists for all instances inheriting from `location`.
It will count how many times the player have visited the location.
For example:

[source,alan]
--------------------------------------------------------------------------------
The secret_cave IsA location
  Description
    "This is the secret cave. You have visited it"
    Say visits Of This.
    "times before."
End The secret_cave.
--------------------------------------------------------------------------------




==== TRANSCRIPT Statement

Using the (((TRANSCRIPT, statement))) `Transcript` statement you can turn transcripting on or off.
(((BNF, rules of, TRANSCRIPT)))

[source,bnf]
--------------------------------------------------------------------------------
transcript_statement = 'TRANSCRIPT' ('ON' | 'OFF') '.'
--------------------------------------------------------------------------------

When transcripting is turned on all player input and game output is recorded in a file (or similar) which can be studied afterwards.
Example uses are:

* reading the game output as a novel (player)
* comparing the output to output from previous versions of the game (author)
* comparing output to the output of a v2 game (porting from v2)

To enable player access to the transcripting function you need to implement global verbs:


[source,alan]
--------------------------------------------------------------------------------
Syntax script_on = 'script' 'on'.
Verb script_on
  Does
    Transcript On.
    "Transcript turned on."
End Verb.

Syntax script_off = 'script' 'off'.
Verb script_off
  Does
    Transcript Off.
    "Transcript turned off."
End Verb.
--------------------------------------------------------------------------------


== WHERE Specifications

Many constructs in the Alan language require a specification of where the construct should operate.
The general intention of such a (((WHERE, specification))) *WHERE* specification is to specify a location.
(((BNF, rules of, where specification)))
(((BNF, rules of, AT)))
(((BNF, rules of, IN)))
(((BNF, rules of, HERE)))
(((BNF, rules of, NEAR)))
(((BNF, rules of, NEARBY)))

[source,bnf]
--------------------------------------------------------------------------------
where = 'HERE'
      | 'NEARBY'
      | 'NEAR' what
      | 'AT' what
      | 'IN' what
--------------------------------------------------------------------------------

// @FIXME @thoni56: Unclear Paragraph.
//   First list item:
//
//     "BUT examples include an event scheduled at a particular location, in WHICH case"
//
//   Which examples is it referring to?
//   It's unclear what these "BUT" and "WHICH" are referring to.

The meaning of the different constructs is as follows:

* (((HERE))) `Here` is the location where the current activity is performed.
  Often this means where the hero is, but if the expression is evaluated in another run-time context then that context is the one used.
  See <<Run-Time Contexts,_Run-Time Contexts_>> for a detailed discussion, but examples include an event scheduled at a particular location, in which case that location is `Here`.
  Note that `Here` is equivalent to `At Current Location`.
* (((NEARBY))) `Nearby` means at any adjacent location.
  An adjacent location means that there is an `Exit` from the other location to `Here` (note that the direction is from `Nearby` to `Here`).
  It is allowed to refer to any instance using an identifier or expression.
  In particular, instances inheriting from `location` are allowed, which can be used to see if someone at that location can use an exit to get here.
* `Near what` has a similar meaning to `Nearby` except that it refers to some other instance (the *WHAT*) instead of the current location.
  The results is a truth value indicating wether that other instance is at a location which is nearby (has an `Exit` to) the location of the first instance.
* `At what` means at the location of the instance referenced by the *WHAT* specification (see <<WHAT Specifications>>).
  Note that an instance is always `At` itself, i.e. `x At x` is always true.
  This can come as a surprise, especially if you try to aggregate or loop over instances. (See <<Aggregates,_Aggregates_>> and <<Repetition Statements,_Repetition Statements_>>.)
* `In what` must refer to a container and the expression refers to being inside that container.

// @FIXME: Rephrase paragraph and make it more readable.

These forms can be used in `Locate` statements and in some expressions, for example.
When used in their basic form in expressions they all look inside containers (and in containers inside other containers too) to evaluate the expression.
See <<The Whereabouts of an Entity,_The Whereabouts of an Entity_>> for more information about *WHERE* expressions.


[NOTE]
================================================================================
Not all kinds of *WHERE* specifications are meaningful in every constructs.
For example, `Nearby` and `Near` can not be used in a `Locate` statement, as it requires a specific location to locate to.
================================================================================




== WHAT Specifications

Constructs in the grammar for the Alan language often refer to some class or instance defined in the Alan source.
This is generally called a (((WHAT, specification))) *WHAT* specification, as it specifies what the construct refers to.
An example is the `Locate` statement that must refer to something that should be relocated.
(((BNF, rules of, what specification)))
(((BNF, rules of, CURRENT LOCATION)))
(((BNF, rules of, CURRENT ACTOR)))
(((BNF, rules of, THIS)))

[source,bnf]
--------------------------------------------------------------------------------
what = 'CURRENT' 'ACTOR'
     | 'CURRENT' 'LOCATION'
     | 'THIS'
     | id
     | attribute_reference
--------------------------------------------------------------------------------


The meaning of the different forms of the *WHAT* specification are:

* `Current Actor` (((ACTOR, in WHAT specifications))) is always set to the actor currently active, e.g. when a non-player actor is running a script this refers to the actor instance that is running.
* `Current Location` (((LOCATION, in WHAT specifications))) is the current location, i.e. the location where the current activity is performed.
  Normally this is the location where the hero is, but may also be where an event is executed or the location where a scripted actor is currently executing.
  See <<Run-Time Contexts,_Run-Time Contexts_>> for more details.
* `This` refers to the instance in which the current code (e.g. a verb body or a script) is run.
  This can be used, for example, to test or set attributes in inherited code, thus testing or setting attributes in an instance while the code is defined in the class from which the instance inherits.
  It cannot be used in events or global verbs.
* An identifier, *id*, refers to the class or instance with that name, a syntax parameter, script or loop variable with that name.
  A syntax parameter may have the same name as an class or instance declared elsewhere in the source, in which case the parameter has precedence.
* A reference to an attribute, as described in <<Attribute References>>, might be used depending on its type and the context of the usage of the *WHAT* expression.


[NOTE]
================================================================================
Not all kinds of *WHAT* specifications are meaningful in every contexts.
For example, it is not possible to use `Current Location` (nor an identifier referring to an instance inheriting from location) as the *WHAT* part of a `Locate In` statement (since it is illogical to locate locations in containers).
================================================================================




== Expressions

The Alan grammar often refers to ((*expression*)).
This is a generic name for a number of constructs yielding a value.
The following sections describe the different kinds of expressions available in the Alan language.



=== Types of Expressions

(((types of expressions)))
Expressions are used e.g. in `If` and `Set` statements.
The `If` statement requires a Boolean expression, i.e. an expression yielding a true or false value, while the `Set` statement can handle all other types of values.
See <<Types>> for details on types.



=== Literal Values

(((literals)))
A single integer (e.g. 42) is a numeric expression.
A string is an expression and represents a string value, e.g.:

[source,alan]
--------------------------------------------------------------------------------
Set password Of terminal To "xyzzy".
--------------------------------------------------------------------------------

A value of the Set type can be constructed directly as an expression.
This can be used in a `Set` statement or another expression.
E.g.:

[source,alan]
--------------------------------------------------------------------------------
Set suspectedWeapons Of detective To {gun, bat, axe}.
--------------------------------------------------------------------------------

Each member in the `Set` expression can be an expression of integer or reference type in itself.



=== Attribute References

A reference to an attribute can be used as part of any expression provided its type matches the semantics of the context.
The type of the expression is the type of the attribute.
(((BNF, rules of, attribute references)))
(((BNF, rules of, OF)))

[source,bnf]
--------------------------------------------------------------------------------
attribute_reference = id 'OF' expression
                    | expression ':' id
--------------------------------------------------------------------------------

There are two formats available; the first one resembles plain English:

[source,alan]
--------------------------------------------------------------------------------
Set password Of terminal To password Of manual.
--------------------------------------------------------------------------------

The second format is more compact, which might be preferable when referring to chains of attributes referring to other attributes.
See <<Reference Attributes,_Reference Attributes_>> for an explanation on how this works.

[source,alan]
--------------------------------------------------------------------------------
Say detective:suspect:weapon.
--------------------------------------------------------------------------------

It might help to read the `:` as a replacement for *â€™s*.
In this example the detective must be known to have a ((reference attribute)), `suspect`, which can only refer to instances of a class that have an attribute named `weapon`.
It would be the same as:

[source,alan]
--------------------------------------------------------------------------------
Say weapon Of suspect Of detective.
--------------------------------------------------------------------------------

You can test Boolean attributes of an instance by following the pattern:
(((BNF, rules of, expressions)))
(((BNF, rules of, IS)))

[source,bnf]
--------------------------------------------------------------------------------
expression = expression 'IS' something
--------------------------------------------------------------------------------

For example:

[source,alan]
--------------------------------------------------------------------------------
If bottle Is empty Then ...
--------------------------------------------------------------------------------

The test can be reversed by adding a `Not`:

[source,alan]
--------------------------------------------------------------------------------
If hero Is Not hungry Then ...
--------------------------------------------------------------------------------



==== LOCATION OF

(((predefined attributes, LOCATION attribute)))
(((attributes, predefined, LOCATION attribute)))
(((attributes, pseudo-attribute)))
There is a particularly useful predefined ((pseudo-attribute)), `location`, that can be used to query an instance of which location it is currently at.

[source,alan]
--------------------------------------------------------------------------------
Make location Of magic_lantern lit.
--------------------------------------------------------------------------------


This attribute is predefined on all instances and is guaranteed to return an instance of the class `location`, and it will be the innermost location of the instance (bearing in mind that locations may be nested).



=== RANDOM Values

There are three types of random expressions.
The first is the traditional random integer expression.
(((BNF, rules of, RANDOM)))
(((BNF, rules of, expressions, RANDOM)))

[source,bnf]
--------------------------------------------------------------------------------
expression = 'RANDOM' expression 'TO' expression
--------------------------------------------------------------------------------

The random integer expression returns a numeric value that is randomly selected between and including the values of the two expressions.
Arbitrary expressions yielding an integer value can be used as the boundary expressions.

[source,alan]
--------------------------------------------------------------------------------
Set eyes Of first_die To Random 1 To 6.
Decrease temp Of room By Random 0 To temp Of Room.
--------------------------------------------------------------------------------


The second and third types return a random member in a Set or in a container respectively.

(((BNF, rules of, DIRECTLY IN)))
(((BNF, rules of, expressions, RANDOM DIRECTLY IN)))
[source,bnf]
--------------------------------------------------------------------------------
expression = 'RANDOM' ['DIRECTLY'] 'IN' expression
--------------------------------------------------------------------------------


If the expression refers to a container, the expression returns one of the instances currently in that container.
The type of the entire expression is instances of the class accepted by the container.
See <<CONTAINER Properties>> for details on how to determine the class of instances allowed inside a container.

If the expression refers to a Set, the result is one of the members in the Set.
The type and class of the entire expression is determined by the allowed members in the Set.
See <<Set Type Attributes>>.

The optional keyword `Directly` is only allowed if the expression refers to a container.
The semantics are the same as for the *WHERE* expression, see <<The Whereabouts of an Entity>>.


[WARNING]
================================================================================
Attempting to apply a random selection from an empty Set or container is one of the very few situations that could lead to a runtime error.
It is the author's responsibility to ensure that this is not attempted.
As a safeguard against similar runtime errors, you should always surround a random member expression with an `If` statement that ensures that the Set or container is not empty.
See <<Aggregates,_Aggregates_>> for descriptions on how to count members in a set or container.
================================================================================



[NOTE]
================================================================================
A `thing` or `entity` inside a container -- which normally do not exhibit themselves -- will be candidates for being selected by a `Random In` statement, as any other instance.
================================================================================




=== Logical Expressions

(((logical expressions)))
The `And` and `Or` operators are standard binary Boolean (((operators, logical))) operators, meaning that the result of an expression is true or false depending on the right and left expressions, which must also be boolean values or expressions.
(((BNF, rules of, expressions, logical expressions)))
(((BNF, rules of, expressions, AND)))
(((BNF, rules of, expressions, OR)))

[source,bnf]
--------------------------------------------------------------------------------
expression = expression ('AND' | 'OR') expression
--------------------------------------------------------------------------------

For `And` both expressions need to be true for the expression to be true.
If using `Or` either of them need to true.
Otherwise the expression will be evaluated to false.

`And` has higher priority, but parenthesis may be used to change the order of evaluation.

[source,alan]
--------------------------------------------------------------------------------
If kalif Here And mood Of sultan Is 0 Then ...
If o IsA treasure And (size Of o > capacity Of c
  Or thief Is greedy) Then ...
--------------------------------------------------------------------------------


=== Class Expressions

(((class expressions)))
It is possible to check if an instance belongs to, or inherits from, a particular class.
The resulting value is a Boolean type value.
(((BNF, rules of, ISA)))
(((BNF, rules of, expressions, class expressions)))

[source,bnf]
--------------------------------------------------------------------------------
expression = something 'ISA' class_id
--------------------------------------------------------------------------------

Example:

[source,alan]
--------------------------------------------------------------------------------
If p IsA object Then ...
If opponent IsA enemy Then ...
--------------------------------------------------------------------------------


There is a subtle but very important side effect when checking for an instance class in an `If` statement like the above.
Doing so will ensure that the instance or parameter being checked has all the properties.
This holds true for all statements in the `Then` part of the `If` statement.

This is used by the compiler to allow references to attributes, scripts, container properties, etc. that otherwise would not be allowed.

A very common use of this is to restrict parameters in a `Syntax` to a more general class, like `thing` or `entity`, and then doing "`manual`" restrictions using `If` statements to ensure that their usage does not conflict with the actual properties of the instance.
See also the <<IF Statement,section on _IF Statement_>>.



=== Binary Operators

All binary operators (((operators, binary))) (plus, minus, multiplication, division) may be used on integer expressions.
The result is another integer expression.
The exact set of available operators is:


[literal, role="plaintext", subs="normal"]
................................................................................
+, -, *, /
................................................................................



For example:

[source,alan]
--------------------------------------------------------------------------------
age Of golden_child + 4
--------------------------------------------------------------------------------

The plus operator (`+`) may also be used on strings for (((concatenation, of strings))) concatenation.
The meaning of such an expression is that the two strings are concatenated into a resulting string.
For example:

[source,alan]
--------------------------------------------------------------------------------
string1 + " " + anotherString
--------------------------------------------------------------------------------



=== Relational and Equality Operators

Equality (`=`, meaning '`equals`') and relational operators (((operators, relational))) (`<`, `>`, `+<=+`, `>=`, meaning: '`less than`', '`greater than`', '`less than or equal`', '`greater than or equal`', respectively) are used to compare expressions.
The result is true or false and may be negated by using an optional `Not`.

[source,alan]
--------------------------------------------------------------------------------
If temperature Of oven Not > 100 Then ...
If weather Of world Not < protection Of hero Then ...
--------------------------------------------------------------------------------

Comparing (((comparisons, equality))) two string expressions (((string, comparisons))) using the binary equality operator `=` will make a case insensitive comparison, i.e. it will give a true value if the strings are the same without considering the case of the characters.
The special identity operator, `==`, only works on strings and compares the strings for an exact match (i.e. considering character case).

Two values of instance type may be compared with the `=` and `<>` operators, and may e.g. be used to test if a parameter refers to a particular instance or is the same as another parameter.
For example:

[source,alan]
--------------------------------------------------------------------------------
Syntax put_in = 'put' (o) 'in' (c)
  Where c IsA Container
    Else "You can't put anything in the" Say c.
Verb put_in
  Check o <> c
    Else "That would be a good trick if you could do it!!"
  Does
    ...
--------------------------------------------------------------------------------


Relational operations (((operators, relational))) are not allowed on entities or strings, nor is it possible to compare values of different types.

A special relational operator is the (((BETWEEN))) `Between` operator which makes it possible to test if a numeric expression is within a range of values.
The range is inclusive, i.e. the values are included in the accepted range.
For example:

[source,alan]
--------------------------------------------------------------------------------
If level Of water Between 2 And capacity Of bottle Then ...
--------------------------------------------------------------------------------



=== String Containment

There is a string (((string, containment operator))) ((containment operator)), (((CONTAINS))) `Contains`, which can be used to test if a string contains another string.
The test ignores any differences in character case.
An example of an expression that is true is:

[source,alan]
--------------------------------------------------------------------------------
"A string" Contains "a S"
--------------------------------------------------------------------------------

An optional `Not` (before `Contains`) can be used to reverse the test.

[source,alan]
--------------------------------------------------------------------------------
"A string" Not Contains "a S"
--------------------------------------------------------------------------------

The expression yields a Boolean value.



=== CURRENT Entities


// @FIXME @thoni56: Entities or Expressions?
//   Here Current Actor/Location are first introduced as "entities", but then in
//   the next paragraph they are referred to as "expressions".
//   What are they then? the former or the latter?
//   It's somewhat confusing -- especially referring to them as "entities", for
//   one is led to think that an entity is always reachable, everywhere.

There are two particularly interesting entities that you might want to learn about.
They are:

* (((CURRENT ACTOR))) `Current Actor`
* (((CURRENT LOCATION))) `Current Location`

These two expressions can be used wherever a reference to an instance can be used.
They will refer to the currently executing actor and the current location respectively.
Details about execution contexts can be found in <<Run-Time Contexts,_Run-Time Contexts_>>.



=== THIS Instance

You can also refer to the instance that is actually executing the code containing the expression.
This is particularly useful when using inheritance since the class defining the code has no way of knowing which instance will actually execute it.
(((THIS, expression))) This expression is `This`.

An example is the code for objects that can be opened:

[source,alan]
--------------------------------------------------------------------------------
Every openable IsA object
  Is Not open.
  Verb open
    Check ...
    Does
      Make This open.
  End Verb.
End Every openable.

The door IsA openable
End The door.
--------------------------------------------------------------------------------

[example,role="gametranscript"]
================================================================================
&gt; *open the door*
================================================================================

Given these two declarations, and some `Syntax` declarations, the `door` will inherit the `open` attribute.
When the verb body, also inherited from `openable`, is executed, it will set the attribute on the `door`, because this is the instance running the code.


=== The Whereabouts of an Entity

An expression following the pattern below can be used to test if a particular instance, as specified by the *WHAT*, is (or is `Not`), at the place indicated by the *WHERE*.
(((BNF, rules of, whereabouts of an entity)))
(((BNF, rules of, expressions, whereabouts of an entity)))

[source,bnf]
--------------------------------------------------------------------------------
expression = what ['NOT'] [transitivity] where
--------------------------------------------------------------------------------

Example:

[source,alan]
--------------------------------------------------------------------------------
If bottle In inventory Then ...
--------------------------------------------------------------------------------

or

[source,alan]
--------------------------------------------------------------------------------
If hero Not Nearby Then ...
--------------------------------------------------------------------------------

The forms available for the *WHERE* expression are described in detail in <<WHERE Specifications>>.

The default behaviour of a *WHERE* expression is to evaluate recursively through containers, e.g. if the bottle was inside a bag which was in the inventory, the first expression above would still be true.
This implicitly transitive evaluation can also be made explicit through the use of the keyword (((INDIRECTLY))) `Indirectly`.
This would result in exactly the same semantics, but explicitly expressed, which can be useful.
(((BNF, rules of, DIRECTLY)))
(((BNF, rules of, INDIRECTLY)))
(((BNF, rules of, TRANSITIVELY)))
(((BNF, rules of, transitivity)))
(((BNF, rules of, expressions, transitivity)))

[source,bnf]
--------------------------------------------------------------------------------
transitivity =
             | 'DIRECTLY'
             | 'INDIRECTLY'
             | 'TRANSITIVELY'
--------------------------------------------------------------------------------


In addition, another qualifying keyword, (((DIRECTLY)))  `Directly`, can be used to indicate that the expression should _not_ evaluate recursively into containers.
To test if an instance is at a particular location but not in a container at that location you can use:

[source,alan]
--------------------------------------------------------------------------------
If key Directly At treasury Then ...
--------------------------------------------------------------------------------

The qualifying keyword `Directly` works in the same way with all *WHERE* expressions.
Adding a `Directly` qualifier to the first example above would change the expression to only be true if the bottle was in the container but not inside any other container, even if that container was in the inventory.
See <<_containment_classes_and_transitivity,_Containment, Classes and Transitivity_>> for some background information.


[NOTE]
================================================================================
If the transitivity is not `Directly`, the compiler analyses the container to see which classes of instances might be contained transitively.
This includes all existing instances of the class that the container takes, and if any of those are containers, those containers and all instances of the classes they take, and so on.
================================================================================


=== Aggregates

Aggregates are functions to calculate values from Sets of instances.
(((BNF, rules of, COUNT))) (((BNF, rules of, SUM)))
(((BNF, rules of, MAX)))   (((BNF, rules of, MIN)))
(((BNF, rules of, expressions, aggregate)))

[source,bnf]
--------------------------------------------------------------------------------
aggregate_expression = aggregate filters

aggregate = 'COUNT' | 'SUM' | 'MAX' | 'MIN'
--------------------------------------------------------------------------------
There are four aggregates available: `Count`, `Sum`, `Min` and `Max`.
Aggregates work by inspecting all instances available, applying the *filters*, which may remove some, or even all, from the Set of instances, and then calculate the value from the remaining instances.

You can use filters to filter out instances belonging to a particular class, at a particular location or having a particular Boolean attribute.
See <<Filters>> for an explanation of filters.

(((COUNT))) `Count` counts the number of instances in the Set, e.g.:

[source,alan]
--------------------------------------------------------------------------------
"You are carrying"
Say Count IsA object, In inventory, Is big.
"big objects."
--------------------------------------------------------------------------------


In this example there are three filters applied, `IsA object`, `In inventory` and `Is big`.
All of these filters must pass before an instance is counted.
The result of that count is an integer, which is then printed using the `Say` statement.

The (((SUM, aggregate))) `Sum`, (((MIN, aggregate))) `Min` and (((MAX, aggregate))) `Max` aggregates return the sum, minimum and maximum value respectively, of an attribute of all instances in the filtered set.

Any attribute referred to either in the aggregation itself or in the filters, must be an attribute of some class in order to ensure that the attribute is available for all instances.
You must ensure this by filtering out only instances of the relevant class, e.g. objects, using a class filter.

Some examples:

[source,alan]
--------------------------------------------------------------------------------
If Sum Of weight At bridge > 500 Then ...
If Max Of size In inventory > size Of small_door Then ...
If Count IsA lightsource, Is lit, Here > 0 Then
  "Let there be light..."
End If.
--------------------------------------------------------------------------------


These examples could be used to create various restrictions in the possible travels of the hero.


== Filters

Filters can be used to filter out only particular instances to loop or aggregate over.
(((BNF, rules of, filters)))

[source,bnf]
--------------------------------------------------------------------------------
filters = filter { ',' filter }

filter = 'ISA' class
       | is attribute
       | where
--------------------------------------------------------------------------------

If one of the filters is a `IsA class`, only instances of that class will be bound to the loop variable or considered in the aggregation.
In particular, this is required if any of the other filters refer to attributes, which is only allowed if the class is known and that class is guaranteed to have that attribute.
Other ways to restrict the filtered instances is to use a *WHERE* filter which implicitly restricts to instances available at or in that location, container or Set.
See <<The Whereabouts of an Entity>> for details on the various forms of the *WHERE* expression.

Multiple filters can be listed by using a comma to separate them.
Each filter must enumerate the Set of values to a compatible Set, e.g. using two `IsA` filters for actors and locations respectively is not allowed since those two Sets can never be compatible.


// EOF //
