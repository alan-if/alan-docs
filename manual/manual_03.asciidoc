= Language Reference

This chapter describes the Alan language in detail. Within each section, grammar rules are used to precisely define allowed formats. A description of how these rules should be interpreted can be found in <<Language Grammar>>.

:sectnums!:


== General Rules

The Alan language is divided into syntactic components of different kinds. Each component may be composed of text and/or other components. A component is terminated by a period or full stop ('`.`'). This indicates that that component is complete. Some components start with a keyword or initial phrase, such as `Description` or `Exit east To kitchen`. If it is to be followed by further components, such as statements or output strings, that keyword or phrase should normally _not_ be followed by a period, but by its continuing components. For example:

[source,alan]
--------------------------------------------------------------------------------
Exit east to Kitchen.
--------------------------------------------------------------------------------

But

[source,alan]
--------------------------------------------------------------------------------
Exit east To Kitchen
  Check kitchenDoor Is open
  ...
End Exit.
--------------------------------------------------------------------------------


Note that the first is terminated, but the second example is continued with a check, and not terminated until the `End Exit`.

:sectnums:


== An Adventure

An adventure starts with an (optional) set of (((OPTION))) ``Option``s (see <<Options>>) followed by a set of declarations.

[source,ebnf]
--------------------------------------------------------------------------------
adventure = {option} {declaration} start_section
--------------------------------------------------------------------------------

According to the rules it is actually possible to have no declarations at all (as indicated by the curly braces) but there would be no adventure without a single location, right? So, in practice you'll need at least one declaration.

The declarations constitute the major part of the adventure. The declarations can be declared in any order and repeated freely, and are of many different possible types.

[source,ebnf]
--------------------------------------------------------------------------------
declaration = import
            | class
            | instance
            | addition
            | syntax
            | verb
            | rule
            | synonyms
            | event
            | messages
            | prompt
--------------------------------------------------------------------------------

The adventure source text must end with a (((START section))) `Start` section.

[source,ebnf]
--------------------------------------------------------------------------------
start_section = 'START' where '.' statements
--------------------------------------------------------------------------------

It indicates where the hero is when the game starts but can also be used to set things up, welcome the player and so on. The start section is mandatory.

[source,alan]
--------------------------------------------------------------------------------
Start At bedroom.
  Schedule alarm_clock After 2.
    "Slowly you come to your senses, your numb limbs
     starting to feel the blood flowing through them..."
--------------------------------------------------------------------------------

You can look up the meaning of the rules "`where`" and "`statement`" elsewhere in this chapter.



== Options

Options (((OPTION))) define things concerning the overall behaviour of the generated Alan adventure. As is implied they are optional and are only required if you need to change the value of an option from its default setting. An option follows the grammar

[source,ebnf]
--------------------------------------------------------------------------------
option = id '.'
       | id id '.'
       | id integer '.'
--------------------------------------------------------------------------------


The example below illustrate how options may be written, following the above rules.

@[source,alan]
--------------------------------------------------------------------------------
Debug.
Language Swedish.
No Pack.
Width 128.
--------------------------------------------------------------------------------

The available options are

// FIXME: CLEANUP TABLE

[cols=",,",]
|========================================================================================================================================
|*Option name* |*Possible values* |*Default value*
|*Language* |English, Swedish, Germanfootnote:[Other non-English languages may be supported in the future depending on demand.] |English
|*Width* |24-255 |80footnote:[Width and Length is overridden by the actual terminal or window size, if available.]
|*Length* |5-255 |24
|*Pack* |Boolean (on or off) |Off (No Pack)
|*Debug* |Boolean (on or off) |Off (No Debug)
|========================================================================================================================================

The Language option specifies the language in which the adventure is assumed played, and selects different default message texts. Alan is primarily designed for adventures in the English language, but it is also possible to write adventures in other languages. To make this possible, the default messages output by the interpreter may be generated in different languages. It is completely possible to write in other languages, but then you must customize all the message texts. See <<Run-time Messages>>, <<Input Response Messages>>, for a complete list of such messages.

The Alan compiler and interpreter will always allow multinational (((multinational characters))) 8-bit characters as input and the default messages is generated for 8-bit ((character sets)), internally representing national characters according to the ISO multinational character set (ISO8859-1) requiring 8 bits. On output, this is converted to the native character set of the machine (whenever possible). This means that portability between platforms should be good even for text containing multi-national (non-ASCII) characters.

Width specifies how long the lines the interpreter outputs should be (formatting is automatic!). The Length option will instruct the interpreter to how many lines to show on the screen without any player interaction (*<More>*). These values are only used if the interpreter itself cannot get the actual values.

The Pack option will cause the compiler to compress the texts to occupy less space. As a bonus, this also makes it impossible for the player to cheat by dumping the adventure code file. As a minor drawback, it does make the execution of the adventure a bit slower (noticeable only on some very old, smaller, computers).

In order to allow debugging of the generated adventure (see <<Debugging>>), the debug option must be turned on. This may also be performed using the debug compiler switch (see <<Compiler Switches>>).



== Types

The Alan language handles information in bits, values. Each such bit of information, or data, is of a specific type. Alan is a strictly typed language, which means that assignment, comparisons and other statements will require that rules concerning the compatibility between such values are not broken.

In the Alan language, you cannot explicitly state the type of a value. Instead, this is inferred from how values are used, e.g. the initial value of an attribute or the restrictions put on a syntax parameter.



=== Basic, Simple and Compound Types

The ((basic types)) of values available in the Alan language are:

* Integer -- e.g. a simple integer constant, a reference to an integer typed attribute or a numeric expression using any of the mathematical operators.
* String -- e.g. a string constant or a reference to an attribute typed as a string.
* Boolean (true or false) -- comparisons yield Boolean values, Boolean attributes.

Two other simple types are available:

* Instance -- a reference to an instance or an attribute typed as a ((reference attribute)) that refers to an instance.
* Event -- a reference to an event or an attribute typed as a ((reference attribute)) that refers to an event.

There is one compound type in the Alan language:

* Set -- an unordered list of values.


=== Instance Type

Every time a reference to an instance is made, it can be considered an expression of ((instance type)). In these cases, the class of the instance also often matters. E.g. assigning a ((reference attribute)) can only be made if the new value refers to an instance that belongs to the same class or a subclass of the initial value of that attribute.

Some types of expressions return a value referring to an a class or instance in the Alan source. Examples include an identifier bound to a parameter allowing instances and a ((reference attribute)).

=== Event Type

Event is a set of statements that can be scheduled to execute with a specified delay. Each reference to an identifier of an `Event` is of course of the (((EVENT, type))) `Event` type. Events can be referenced by attributes and any reference to such an attribute is of `Event` type.

Expressions of `Event` type can be used in `Schedule` and `Cancel` statements.



=== Set Type

A `Set` is a collection of values that may be referenced as a single value, but also investigate, added to and removed from. An example might be a set of cards in a dealt hand, the set of spells that the hero have learned, or the set of numbers guessed so far.

The order of elements in the set is not specified. Each member can only occur once in the same set, but a member can occur in multiple sets. You could for example include one set of numbers (integers) in one set and another set of numbers in another set. It is then possible to investigate the sets and remove all members that are members in both.

The (((SET, type))) `Set` type is a compound type since it is not complete without a member type. You can only include members in a set if the type compatibility rules allow it. A `Set` may include members that are instances or integers.

If the `Set` includes instances, the subclass compatibility rule applies. All members in the set must inherit from the same class. See the section on type compatibility below.



[NOTE]
================================================================================
The fact that an instance is in a Set does not affect the instance. In fact, there is no way to find out in which Sets, if any, a particular instance is included. In particular, it does not affect the instances location.
================================================================================




=== Type Compatibility

Assignment and comparisons between values requires the values to be (((compatible types))) compatible. The three basic types (integer, string and Boolean) are only compatible with themselves.

Values of the Instance type can be compared without restriction, except that there is no notion of lesser or equal, so only equality can be tested. Assignment can be made if the new value is of the same class, or of a subclass, as the attribute or variable that receives the value. This class is normally inferred from the initial value of the declaration.

For example, a ((reference attribute)) (an attribute referencing an instance) is inferred to be restricted to instances of the class of its initial value. Any subsequent change of the attribute (setting it to refer to another instance) requires that the new instance be of the same class or a subclass thereof.

These rules ensure that attribute references and other properties are always retained during the execution of the whole game. Thus, it will never cause a run-time error on the player.



=== Type Requirements

Some statements require their arguments to be of a specific type. This is enforced by the compiler. The compatibility rules apply here also, given that the required type is given by the statement itself.

Examples include the conditional (((IF, statement))) `If` statement that requires a Boolean value (or expression) to test and the (((USE, statement))) `Use` statement, which requires references to instances that are subclasses of the predefined class `actor`.



== Import

The source text for a large adventure might become entangled and complex. A way to break up a large text is to divide it into separate files. Each such file can then be imported into the main source using the (((IMPORT, statement))) `Import` statement.

[source,ebnf]
--------------------------------------------------------------------------------
import = 'import' quoted_identifier '.'
--------------------------------------------------------------------------------

The quoted identifier is the name of the file to import, see <<Filenames>>. The `import` may be placed anywhere in a file where a declaration can occur, and the effect will be the same as if the contents of the named file had been inserted at that position in the file. Imports may be nested, so an imported file may in turn import more files, without limits.

An imported file is searched for first in the current directory and then in any of the directories indicated using the `import` switch as described in <<Compiler Switches,_Compiler Switches_>>, this search is performed in the same order as the `import` switches occurred on the command line.

The import statement is the way to use the standard library (or a library of your own design). Place the library files in a directory where the compiler will find them, either in the same directory as your other source files or somewhere else (see <<Compiler Switches>> on how to make the compiler look in more folders than the one the main source file is in). In your source you would refer to the main file of such a library by

[source,ebnf]
--------------------------------------------------------------------------------
import 'library.i'.
--------------------------------------------------------------------------------

Another use is for dividing your own source into multiple files to make them easier to handle:

[source,ebnf]
--------------------------------------------------------------------------------
import 'harbor.i'.
import 'city.i'.
import 'desert.i'.
import 'actors.i'.
Start At city.
--------------------------------------------------------------------------------




== Classes

[source,ebnf,subs="macros"]
--------------------------------------------------------------------------------
class = 'EVERY' id(((class, syntax for)))
            [inheritance]
            {property}
        'END' 'EVERY' [id] ['.']
--------------------------------------------------------------------------------


Classes (((classes))) are definitions of templates of instances. That means that a class declaration only describes instances, and does not add anything to your game in itself. Instead, you have to create an instance of the class to make it available in the game (see <<Instances,_Instances_>> below).

The *id* is the identifier used by the author to refer to this class throughout the source code, e.g. when referring to it in the inheritance clause of other classes and instances.

The *properties* are described in <<Properties>>.



=== Inheritance

Every instance must inherit (((inheritance))) from a class (see <<Inheritance and Object Orientation>>). Furthermore, user-defined classes must also inherit from other classes. A class or an instance inheriting from a class will get all properties of that class. All properties explicitly declared in a class or instance inheriting from another class will extend, override or complement those properties as specified in the original, parent, class. This way, you can easily create new classes by extending existing ones.

You specify which class another class or an instance inherits from using a clause following the grammar:

[source,ebnf]
--------------------------------------------------------------------------------
inheritance = 'ISA' id ['.']
--------------------------------------------------------------------------------


For example

[source,alan]
--------------------------------------------------------------------------------
The door IsA object ...
--------------------------------------------------------------------------------

and

[source,alan]
--------------------------------------------------------------------------------
Every coin IsA treasure ...
--------------------------------------------------------------------------------



== Instances

The most important part of an Alan game source is probably the declarations of ((instances)). Instances are the objects, locations, actors and other things that fill your game universe. The player traverses and interacts with these in his quest to negotiating your game.

[source,ebnf]
--------------------------------------------------------------------------------
instance = 'THE' id
              [inheritance]
              {property}
           'END' 'THE' [id] ['.']
--------------------------------------------------------------------------------


Every instance must inherit from a class (see <<Inheritance,_Inheritance_>> above) keeping all properties of that class. Each inherited property can be amended or overridden by specifying it in the declaration of the instance, and new attributes, exits and scripts can be added in the same way as in class declaration.

Exactly the same rules for declaring properties apply to instances. The only difference is that an instance will actually show up in the game when it is run. Remember also that properties declared in an instance are not common to any other instances (unless the declaration overrode the value of a class property).

// @NOTE: I didn't style as inline code the classes in the following paragraph,
// 		  as some of these are not actually referenceable in real code (eg, literal)

Instances inheriting, directly or indirectly, from the predefined classes *thing*, *entity*, *object*, *location*, *actor* and *literal,* are subject to special semantics (((semantics of predefined classes))) and restrictions.

Here are two examples of instance declarations following the rules above:

[source,alan]
--------------------------------------------------------------------------------
The red_ball
  IsA object
  At bedroom
  Name red ball
  Is hidden.
  Description
    If This Is Not hidden Then
      "An ordinary ball is laying under the bed."
    End If.
  Verb roll
    Does
      "You roll the ball a bit. Nothing exciting happens."
  End Verb.
End The red_ball.

The mr_brown
  IsA actor
  Name Mr Brown
  Article "".
  Pronoun him.
  Is working.
  Description "Mr. Brown is here, working at his desk."
End The mr_brown.
--------------------------------------------------------------------------------


In these examples the source lines between `The` and `End The` all declare various properties that we will learn more about in <<Properties>>. The rest of the lines are fairly easy to match up to the rules of the Alan language as described by the earlier box.

All capitalized words in the examples above are keywords in the Alan language (see <<Keywords>> for a complete list), the rest are author defined words or identifiers (with the exception of the bold words object and actor, which are identifiers predefined to be special classes).



=== Entities

The base class `entity` (((ENTITY, predefined class))) represents the lowest denominator of all instances. All other predefined classes inherit from `entity`. So adding a property to `entity` will add it to every instance.

Entities cannot have an initial location, nor can they be located anywhere. On the other hand, they can be considered to be available everywhere. They are not described when encountered. They can only be shown by explicitly executing a `Describe` statement.

So, if you want an instance to always be available but invisible, create an instance of `entity`. It is also possible to create subclasses of `entity`. Instances of such classes will follow the same rules.



=== Things

`Thing` (((THING, predefined class))) is a predefined subclass of `entity` that adds the property of having a location. This means that they can have an initial location and be located to locations and into containers. They will, however not show up in descriptions or listings, but the player can refer to and interact with them. They can be described by explicitly executing a `Describe` statement.

Creating an instance of `thing` is a good choice if you want an invisible instance that should only be available at particular locations, or under specific _*circumstances*_.



[NOTE]
================================================================================
Note that a `thing` can be put in a container, but that container will not show
any visible traces of that thing. It will be rendered as empty if listed. The
`thing` is however subject to other effects of being part of a container, such
as the removal rules and selection by a random selection of items in the
container. See <<Random Values,_Random Values_>> for a description of random
selections of container items.
================================================================================




=== Objects

Objects (((OBJECT, predefined class))) are instances inheriting directly or indirectly from the predefined class `object`. Objects are all the things that can be manipulated by the player. They can be picked up, examined and thrown away (if the author has allowed it). In addition to the properties inherited from `thing`, any present object will by default, be described when the player enters a location or otherwise encounters it.



=== Actors

The predefined class `actor` (((ACTOR, predefined class))) is intended for providing so called NPC:s, non-player characters, in your game. Like the player, they can move around but to do this they have to be scripted, i.e. programmed with some behaviour using scripts.

An instance inheriting from the `actor` class will be described when encountered. Actors can be located, as can any `thing`, but not be inside a container. In addition, they can have scripts.

Actors also exhibit special behaviour when they are described, e.g. when they are encountered. If an actor (((ACTOR, description))) is executing a script with a description, (see <<Scripts,_Scripts_>>) this description will be used instead of the one declared in the description clause.

[source,alan]
--------------------------------------------------------------------------------
The kirk IsA actor Name Captain Kirk At control_room
  Has health 25.
  Container
    Header "Kirk is carrying"
    Else "Captain Kirk is not carrying anything."
  Description
    "Your superior, Captain Kirk, is in the room."
End The kirk.

The george IsA actor
  Name George Formby
  Description
    "George Formby is here."
  Script cleaning.
    Description
      "George Formby is here cleaning windows."
    Step ...
  Script tuning.
    Description
      "George Formby is tuning his ukelele."
  Step...
:
--------------------------------------------------------------------------------




==== The Hero

There is one very special actor, the `hero`, ((("HERO, the"))) which represents the player. This actor is always pre-declared with some basic properties, so you don't have to declare it. But if necessary, it may be re-declared in the same way as any other actor.

One situation when this is required is if you need attributes on the hero, such as "`sleepy`" or "`hungry`". A declaration like the following can then be used:

[source,alan]
--------------------------------------------------------------------------------
The hero IsA actor
  Name me
  Is Not hungry.
  Verb examine Does
    If hero Is hungry Then
      "Examining yourself reveals a poor, hungry soul."
    Else
      "You find nothing but a poor beggar."
    End If.
  End Verb examine.
End The hero.
--------------------------------------------------------------------------------

The hero is predefined with a simple container property taking objects with no limits. It seems natural to use that as the "`inventory`" of the player, the storage for everything the player is picking up and carrying around. You will probably need to handle carried items in some manner, and the pre-declared container is one suggestion. You can also redeclare the container property of the hero so that it suits your needs.



=== Locations

A location (((locations))) is a declaration of a place (a "`room`") in the game that (normally) can be visited by the player, and have objects lying around, etc. In fact, the map of your game is a set of interconnected locations. A location is any instance inheriting directly or indirectly from the predefined class `location`. Inheriting from `location` implies the following semantic (((semantics, of locations))) properties:

* only locations can be visited by the player
* only locations may have the `Entered`-clause
* things and locations may be located to locations
* exits can only lead to locations and only locations can have exits
* the start location must be a location
* locations can't have container properties
* verbs in locations are executed only when the hero is at that location

When a location is described (((DESCRIPTION, of locations))) (for example when entering it) it is presented with a heading (the location name), the description (in the description clause) followed by descriptions of any present objects and actors not already, explicitly, described (using a `describe` statement) in the description.

An interesting property of locations is that a location can be located at another, both initially and during run-time. The result of having such ((nested locations)) is that all things present at the "`outer`" location are also present in the inner. This can be used in multiple levels to allow access to sky, ground and other scenery items available at many locations at once. It can also be used for grouping locations into sets of similar locations and for implementing vehicles.



=== Literals

The classes (((literals))) *literal*, *string* and *integer* cannot be instantiated explicitly. Instead, you might say that they are implicitly instantiated when the player inputs a literal. For example

[example,role="gametranscript"]
================================================================================
&gt; turn dial to 12
================================================================================



The second parameter (see <<Syntax Definitions>>) in this player command is the integer 12. This parameter is automatically considered an instance of the predefined class *integer*.

It is possible to add verbs to *literal* and its sub-classes. This way it is possible to create verbs that take strings and integers as parameters.



== Properties

An instance or class can be given number of different ((properties)) by declaring them in the declaration of the class or instance.

[source,ebnf,subs="macros"]
--------------------------------------------------------------------------------
property = initial_location(((property, syntax for)))
         | name
         | pronouns
         | attributes
         | initialization
         | description
         | articles
         | mentioned
         | container_properties
         | verb
         | script
         | entered
         | exit
--------------------------------------------------------------------------------


Attributes, exits, verbs and scripts can be repeated any number of times in the same declaration. You cannot use the same identifier for more than one such property, e.g. you cannot declare two attributes with the same name.



=== Inheriting Properties

A property can be inherited (((inheriting properties, rules for))) from the parent of the class or instance. It is not necessary to repeat the declaration in the inheriting class or instance if it should retain its inherited value. Each inherited property may be amended or overridden by specifying it also in the declaration of the inheriting class or instance according to the following table.

// FIXME: CLEANUP TABLE

.Properties Inheritance
[[table-of-properties-inheritance]]
[cols=",",]
|==========================================================================================================================================================================================================================
|*Property* |*Inherited as*
|*Initial location* |Overridden
|*Name* |Accumulated, the inherited names are appended at the end of the list of Name clauses
|*Pronoun* |Overridden, each pronoun clause inhibits inheriting pronouns from the parent class.
|*Attribute values* a|
Overridden, attribute declarations using the same name as an inherited can give the attribute a different value but must match the type of the inherited.

Accumulated, you can add further attributes in a class or instance.

|*Initialize* |Accumulated. Inherited initialize clauses are executed first so that the base classes may do their initialization first.
|*Description check* |Accumulated.
|*Description* |Overridden.
|*Articles & Forms* |Overridden.
|*Mentioned* |Overridden. Also overrides names.
|*Container* |Overridden, all clauses are overridden.
|*Verb declarations* |Accumulated. Verb bodies are accumulated for verbs with the same name as the inherited. Use qualifiers (see <<Verb Qualification>>) if you don't want all of them to execute.
|*Scripts* |Overridden, for same script name.
|*Entered* |Accumulated. Entered-clauses in nested locations are executed from the outside in. Entered-clauses in parent classes are executed first. So the first clause to be executed is the parent of an outer location.
|*Exits* |Overridden, for same direction.
|==========================================================================================================================================================================================================================

The table also show which properties are inherited separately from the parent. E.g., you can override the description but keep the description check, or even add another (since they are accumulated). You cannot override the container limits and keep the header section since the container property is overridden in its entirety.

In an inheriting class, you can also add new properties. More attributes, verbs, exits and scripts can be added to those already present through the inheritance.

The properties available for use in classes, and thus also for instances, are described in detail in the following sections. In general, all of these can be mixed freely, however, some semantic restrictions apply as to when a particular property is or is not legal.

=== Initial Location

Where an instance will be located when the game starts is set using an optional `Where` clause. If no such clause is used the instance will have no location. An instance without location is not present (in the view of the player) in the game until it is moved somewhere by a `Locate` statement.

[source,ebnf]
--------------------------------------------------------------------------------
initial_location = where
--------------------------------------------------------------------------------

Only the `At` `what` and `In` `what` forms of the `Where` construct (see <<WHERE Specifications>>) are allowed when describing an initial location of an instance.

[source,alan]
--------------------------------------------------------------------------------
The chest IsA object At treasury
...
--------------------------------------------------------------------------------

An instance inheriting from `location` cannot have an initial location that is `In` something, but it can be `At` some other location, creating a nesting of locations.



=== Names

By default, the identifier ("`author name`") for an instance is also the name shown to the player, and by which he will be able to refer to it. Normally you would want to override this with more elaborate and alternative names. You can do that using the (((NAME, clause))) `Name` clause.

[source,ebnf]
--------------------------------------------------------------------------------
name = 'NAME' id {id} ['.']
--------------------------------------------------------------------------------

The `Name` clause consists of a list of identifiers optionally followed by a full stop.

The identifiers given in the `Name` clause is used when the instance is presented to the player and which the player can use to refer to it. For example

[source,alan]
--------------------------------------------------------------------------------
The south_door IsA object At south_of_house
  Name door
...
The south_of_house IsA location
  Name 'South of House'
...
--------------------------------------------------------------------------------

// @NOTE: Here I had to use the autogenerated anchor ID:
//            <<_words_identifiers_and_names>>
//        instead of the plain title:
//            <<Words, Identifiers and Names>>
//        because of the comma in the title (interpreted as custom text separator).
//        See Issue #1468 on this:
//        https://github.com/asciidoctor/asciidoctor/issues/1468#issuecomment-132378305

The ((quoted identifier)) used in the last example makes the name (((NAME, of locations))) be one single text string. See <<_words_identifiers_and_names>> for an explanation of this. This works for locations, which a player usually does not need to refer to, but for things the player should interact with, a more sophisticated mechanism is available.

[source,alan]
--------------------------------------------------------------------------------
The chair3 IsA object
  Name little wooden chair
--------------------------------------------------------------------------------


In this example, the name is a sequence of words. The semantics of this declaration is that the word "`chair`" is a ((noun)) and "`little`" and "`wooden`" become (((adjective))) adjectives. When the player, in a command, want to refer to the object with the author name (identifier) `chair3`, he may use just "`chair`" if it is the only accessible object with "`chair`" as its noun, or he may distinguish between multiple chairs by also giving one or more adjectives to be more precise about which chair he meant.


[NOTE]
================================================================================
The `Name` clause hides the author name, so in the example, the player will not be able to use `chair3` to refer to the instance.
================================================================================

[NOTE]
================================================================================
An explicit `Mentioned` clause will override the names for presenting the instance.
================================================================================


It is possible to give an instance multiple names (((NAME, multiple names))) by listing a number of name clauses. Each one will define adjectives and a noun as described above. The result is that the player can use any of the names to refer to the object. For example:

[source,alan]
--------------------------------------------------------------------------------
The rod IsA object At grate
  Name rusty rod
  Name dynamite
  ...
--------------------------------------------------------------------------------


This would allow the player to refer to the object using either '`rusty rod`' or '`dynamite`'. (Or as a side effect '`rusty dynamite`'.) The first name clause is used for building a default description, if necessary (see <<Description>>).

The character case used in any word is retained for output, but player input will always be matched without considering case. This way you can e.g. give capitalized names to people giving a correct output.



==== Inheriting Names

Names can of course be (((NAME, inheriting names))) inherited. This is done in an additive way so that any names inherited are appended to the `Name` clauses in the declaration. This ensures that the class or instance itself can control the primary name (the first `Name` clause). In addition, this has the effect that an instance inheriting from a class defining a `Name` will be possible to refer to also using the inherited name(s). Here is an example with fruits:

[source,alan]
--------------------------------------------------------------------------------
Every fruit IsA object Name fruit ...
Every apple IsA fruit Name apple ...
Every pear IsA fruit Name pear ...
The gravensteiner IsA apple ...
The macintosh IsA apple ...
--------------------------------------------------------------------------------

In this example, both the pear and the apple would be possible to refer to using the word "`fruit`". Both the gravensteiner and the macintosh would be apples, not only by name, but also by all other properties of apples.



==== Displaying Instances

When an instance is to be shown to the player, (((instance, displaying))) it must be displayed in form of text. An instance can be printed in several different ways, it can be described or only mentioned. A description of an instance is a complete and usually more elaborate description of it (see <<Description>>). However, often an instance must be mentioned as a part of a sentence, or in a list.

Such a mentioning of an instance will involve the articles, the name and possibly the `Mentioned` clause.

The basis for this mechanism is the short form, which by default is the first of the ``Name``s. It will, however, be overridden by any existing `Mentioned` clause (see <<Mentioned>>).

The short form can be automatically transformed to a description (for instances that have no `Description`) by inserting the article (see <<Articles and Forms>>) and the short form in a default message. In the following example, output of the article is underlined and the short forms are emphasised, the rest is the default message templates.

There is a _little black book_, a _green pearl_ and an _owl_ here.

The interpreter also uses this principle when constructing lists of instances in container content lists (as the result of the execution of an implicit or explicit `List` statement, see <<List Statement>>).

===  Pronouns

In player input, it is often handy and natural to refer to items using (((PRONOUN, clause))) pronouns, such as "`it`", "`them`" or "`her`". Alan provides a means to define with which pronouns each instance can be associated.

[source,ebnf]
--------------------------------------------------------------------------------
pronouns = 'PRONOUN' word { ',' word }
--------------------------------------------------------------------------------

The effect of associating a pronoun with an instance is that the player can refer to that instance explicitly in one command and then in a subsequent command use that pronoun to refer to it again. Assume the player input

[example,role="gametranscript"]
================================================================================
&gt; ask the priest about the bible
================================================================================



If the priest has been associated with the pronoun "`him`" and the bible with the pronoun "`it`", the next command could be

[example,role="gametranscript"]
================================================================================
&gt; give it to him
================================================================================



Pronouns are inherited as any other property, but are overridden as soon as a pronoun clause is present.


[NOTE]
================================================================================
The predefined class `entity` defines the (((PRONOUN, predefined))) pronoun
"`it`" (or equivalent for other supported languages).
================================================================================

=== Attributes

An attribute is a labelled value that instances have. The declarations (((attributes, declaration))) of attributes are placed inside a class definition (in which case it will apply to all instances of that class or instances of any sub-class of it) or inside an instance declaration (in which case only this instance will have it, unless it overrode an already inherited attribute with new values). An attribute declaration, or a set of declarations, is introduced using one of the keywords:

[source,ebnf]
--------------------------------------------------------------------------------
is = 'is'
   | 'are'
   | 'has'
   | 'can'
--------------------------------------------------------------------------------

And the actual of an attribute follows the structure:

[source,ebnf]
--------------------------------------------------------------------------------
attribute_declaration = id
                      | 'NOT' id
                      | id integer
                      | id string
                      | id id
                      | id '{' values '}'
--------------------------------------------------------------------------------

An attribute can be of Boolean (having truth values), numeric, string, event, instance or set type. The type of an attribute is automatically inferred from the type of its initial value.

Combining the keywords with well chosen attribute names can give natural reading to your attributes:

[source,alan]
--------------------------------------------------------------------------------
The rats Are hungry
The cowboy Can shoot
The chest Is heavy
The combination_lock Has numbers {1,2,4,8}
--------------------------------------------------------------------------------

Attributes that you want every instance of a class to have must be declared in that class. E.g. to declare a Boolean attribute that all instances of the class animal will have in common, the following code can be used:

[source,alan]
--------------------------------------------------------------------------------
Every animal ...
  Is
    Not human.
...
--------------------------------------------------------------------------------

The attribute `human` will now be available in all instances of the class, without further declarations, and it will be false. If you want the attribute to have another value in a particular instance, you must declare it specifically in that instance and give it its desired value, which will be effective only for that instance. You can override the value in a subclass, e.g.

[source,alan]
--------------------------------------------------------------------------------
Every person IsA animal ...
  Is
    human.
...
--------------------------------------------------------------------------------




==== Boolean Attributes

A Boolean attribute (((attributes, boolean))) is declared by simply giving the attribute name, or the name proceeded with the keyword `Not` (indicating a *FALSE* initial value):

[source,alan]
--------------------------------------------------------------------------------
thirsty.
Not human.
--------------------------------------------------------------------------------



==== Numeric and String Attributes

Numeric (((attributes, numeric))) and string attributes are declared by simply typing the value after the attribute name:


[source,alan]
--------------------------------------------------------------------------------
weight 42.
message "Enter password:".
--------------------------------------------------------------------------------

Note that string (((attributes, string))) valued attributes are mainly intended for saving string parameters from the player input, like in

[example,role="gametranscript"]
================================================================================
&gt; scribble "Kilroy was here" on the wall
================================================================================


It is not intended for keeping long strings of descriptions, especially not as attributes to classes, as they (in the current implementation) require memory and takes time to initialise when starting the game.


==== Event Attributes

Attributes can refer to (((attributes, event type))) events. Such an attribute is declared by giving the identifier of an event as its initial value.

[source,alan]
--------------------------------------------------------------------------------
Event e1
  "This is e1 running."
  Set e Of l To e2.
End Event.

The l IsA location
  Has e e1.
End The l.
--------------------------------------------------------------------------------

An attribute of the event type can for example be used to dynamically remember which event is scheduled, so that it can be cancelled.

==== Reference Attributes

Reference attributes (((attributes, of reference type))) store references to instances. Such an attribute is of instance type; the class is determined by the class of the initial instance that the attribute is referring. You may for example store a reference to the other side of a door.

[source,alan]
--------------------------------------------------------------------------------
The east_door IsA door.
  Has otherside west_door.
  ...
--------------------------------------------------------------------------------


You must initialize a ((reference attribute)) with a reference to an instance belonging to a class having the required properties. Any subsequent assignment to the attribute will require that the new value is a member of the same class or a subclass of it. This ensures that operations on instances referenced by that attribute will always be possible.

Inside a class declaration, reference attributes may be initialized with a class identifier instead of a reference to an instance. This makes the attribute an ((_abstract_ attribute)), since it is defined but not initialized. Any instances inheriting from this class must then initialize the attribute, either explicitly or indirectly (by initializing it in an intermediate class). E.g.

[source,alan]
--------------------------------------------------------------------------------
Every door IsA object ...
  Has otherside door.
End Every door.

The east_door IsA door.
  Has otherside west_door.
  ...
--------------------------------------------------------------------------------


[NOTE]
================================================================================
If you need to set the initial value to refer to an instance of a sub-class of the actual class you want to allow, you can use an instance of the required class in the declaration and set its correct initial value in the `Start` or `Initialize` sections.
================================================================================



==== Set Type Attributes

(((SET, type, attributes)))(((attributes, of SET type)))
A Set is an unordered set of integers or instance references. Initial members must be listed in the declaration of the Set. See <<Set Type>> for details on the Set type.

The type and class of allowed members is inferred from the values actually in the initial set. If they are instance references, the common ancestor of all members is used as the class of the allowed members. An empty set is only allowed as an initial value if the attribute is an inherited attribute since in this case, the member class is known from the inheritance and need not be indicated in the declaration.

You can also initialize (((initialize empty SET))) a set type attribute with a set consisting only of a single class identifier. This will create an empty set with instance type members restricted to that particular class.


[NOTE]
================================================================================
If you require an initially empty set of another type, e.g. integer, and you cannot give the member class by inheriting it, you can initialize the set with a single value of the correct type and remove that value in the `Start` or `Initialize` sections.
================================================================================


==== Inheriting Attributes


Attributes can be inherited (((inheriting attributes))) like any other property. A declaration of an attribute with the same name as in any of the parents of the instance or class, will inherit the type of the attribute, you cannot change it in subsequent declarations. This means that any declaration of a different initial value than the inherited must follow the rules of type compatibility for assignment. (See <<Type Compatibility>>.)

This also applies to classes of instances in the reference and set types attributes. Both these types allow references to instances. The initial value given at the point where the attribute is introduced determines the required class of the set members or referenced instances. This is retained throughout the complete inheritance of that attribute even if a subsequent initial value would imply a more specialised class. An example:

[source,alan]
--------------------------------------------------------------------------------
Every door IsA object
  Has otherside someDoor.
End Every door.

Every lockable_door IsA door.
  Has otherside someLockableDoor.
End Every lockable_door.

The someDoor IsA door
  Has otherside someLockableDoor.
End The someDoor.

The someLockableDoor IsA lockable_door
  Has otherside someDoor.
End The someLockableDoor.
--------------------------------------------------------------------------------


In this example, the ((reference attribute)) `otherside` is introduced in the class `door`. Its initial value is referring to the class `door`. This makes the attribute refer to doors. In the subclass `lockable_door` the attribute is used with another initial value, here it refers to a subclass of `door`. Despite this, the attribute in the two door instances will allow reference to doors, as indicated by the first declaration (in the class `door`).

As a contrast, the same example can be used with abstract reference attributes (((abstract attribute))) (reference attributes that are defined, but not initialized, in the class declaration).

[source,alan]
--------------------------------------------------------------------------------
Every door IsA object
  Has otherside door.
End Every door.

Every lockable_door IsA door.
  Has otherside lockable_door.
End Every lockable_door.

The someDoor IsA door
  Has otherside someLockableDoor.
End The someDoor.

The someLockableDoor IsA lockable_door
  Has otherside someDoor.
End The someLockableDoor.
--------------------------------------------------------------------------------

Now the class declarations refer to classes instead of instances in their declaration of the `otherside` attribute. This changes the semantics so that the subclass indicated by `lockable_door` actually makes it illegal to use a `door` as the declaration in `someLockableDoor` does, instead a `lockable_door` is required.

Using (((abstract attribute))) abstract reference attribute declarations in class declarations allows you to progressively refine the class of the instances that that attribute may refer to.

=== Initialize

The attributes of an instance can be initialized using values in the attribute declaration. This is usually sufficient for many situations. For more flexibility, the (((INITIALIZE, clause))) `Initialize` clause can be used.


[source,ebnf]
--------------------------------------------------------------------------------
initialize = 'INITIALIZE' statements
--------------------------------------------------------------------------------

The clause makes it possible to execute arbitrary statements before the game is started. The statements are executed before the `Start` clause is executed. This enables calculation of more complex initial attribute values to be located within the instance, or class, that requires it. Of course general statements are also allowed so any prerequisites can be catered for.


[source,alan]
--------------------------------------------------------------------------------
Initialize
  Set first_course of This To Random In first_courses Of menu.
  Set second_course of This To Random In main_courses Of menu.
  Set third_course of This To Random In desserts Of menu.
--------------------------------------------------------------------------------


The current location is set to the start location, and the current actor is the hero during the execution (((execution context, INITIALIZE clause))) (((INITIALIZE, clause, execution context))) of all `Initialize` clauses.

If the `Initialize` clause is inherited it will accumulate all clauses with clauses from base classes executing before the clause from the subclass. This lets the base classes do their initialization before the initialization of the more specialized, class or instance is performed.



=== Description

The statements in the (((DESCRIPTION, clause))) `Description` clause should print a description of the instance. These statements are executed when the hero encounters the instance. Depending on from which base class the instance inherits this can be a location description presented when the hero enters the location or when executing a `Look` statement. Other possibilities are descriptions of objects and actors. See <<Instances>> for descriptions of what inheriting from the predefined base classes means.


[NOTE]
================================================================================
The description should not change any game state since it might not always be executed depending on the settings of the `Visits`. In particular, the description of a location should not move the hero; this might lead to a recursive loop of descriptions. This might instead be managed by the (((ENTERED, clause))) `Entered` clause.
================================================================================



See also <<Special Statements,_Special Statements_>>, concerning the `Visits` statement.

The syntax for simple descriptions is:

[source,ebnf]
--------------------------------------------------------------------------------
description = 'DESCRIPTION' {statement}
--------------------------------------------------------------------------------

If the `Description` clause is missing for an instance (and no description is inherited), the Alan system will supply a default description such as "`There is a round ball here.`". If there is a `Description` clause but it contains no statements, the object will be '`invisible`', i.e. no description of it will be printed, not even a default one. This can be useful for objects already described by the location description, or of objects with particular properties.

Here are some examples of simple description declarations

[source,alan]
--------------------------------------------------------------------------------
The south_of_house IsA location
  Name 'South of House'
  Is outdoors.
  Description
    "You are facing the south side of a white
     house. There is no door here, and all the
     windows are barred."
  ...

The door IsA object
  Description
    "In the north wall there is a large wooden door."
    If door Is closed Then
      "It is closed."
    End If.
  ...
--------------------------------------------------------------------------------

Before executing a description, you can check for various conditions to be met. A common example is the dark room. If there is no light source present, the description should not be printed. The syntax for such a description is


[source,ebnf]
--------------------------------------------------------------------------------
description = 'DESCRIPTION' [checks] [does]
--------------------------------------------------------------------------------

You can guard the description with a check in the same form as with verb bodies (see <<Verb Checks>> for a detailed description of checks). Of course, there are no qualifiers possible here. To be able to separate the checks statement from the actual description statements the keyword `Does` (((DOES, in descriptions))) is required. This is an example of the checks for a dark location:

[source,alan]
--------------------------------------------------------------------------------
Every dark_location IsA location
  Description
    Check Sum Of light_source Here > 1
      Else "It is pitch black. You are likely
            to be eaten by a grue.""
End Every dark_location.
--------------------------------------------------------------------------------


// @NOTE: Here we cross-reference directly the Table of "Inherited Properties"

Note that it does not specify any description statements. This is because the checks and the actual description are inherited separately, as described in <<table-of-properties-inheritance>>. The actual descriptions are left for the instances.

If multiple description checks are available in the inheritance chain, they are all tested and must be met before any description is attempted. So the inheritance of description checks is "`additive`".

If any check fails, the description will not be executed. This particularly also implies that the default listings and description of present objects and actors in location instances will not occur either. Note, however, that any events and actor actions _will_ be shown. See <<Locations,_Locations_>> below for a description of the default description mechanism for locations.

If neither a check nor any description statements occur after the keyword `Description` this _is_ a description, but it is empty.


[NOTE]
================================================================================
You should _not_ put statements that changes game state in the `Description` clause. Descriptions can be executed in various circumstances that the game author has no control over. Consider `Exit` statements and the `Entered` clause instead.
================================================================================




=== Articles and Forms

[source,ebnf]
--------------------------------------------------------------------------------
forms = indefinite | definite | negative

definite = 'DEFINITE' article_or_form

indefinite = [ 'INDEFINITE' ] article_or_form

negative = 'NEGATIVE' article_or_form

article_or_form = 'ARTICLE' {statement}
                | 'FORM' {statement}
--------------------------------------------------------------------------------

The optional definite, indefinite and negative ((articles)) and forms can be used to define how an instance is printed in its indefinite, definite and negative forms. There are two cases for each form, either as an article prepended to the short display form of the instance (its names or `Mentioned` clause), or a complete form replacing the normal name printing.

Indefinite forms are used in e.g. inventory listings and when presenting instances that have no `Description` clause. Definitive forms are usually used in messages of the type:


[example,role="gametranscript"]
================================================================================
The door is locked.
================================================================================


The negative forms are used in standard messages of the type:


[example,role="gametranscript"]
================================================================================
I can't see any door here.
================================================================================




``Article``s and ``Form``s can of course, be inherited.


[NOTE]
================================================================================
The predefined base class `entity` defines the default definite, indefinite and negative article to be "`the`", "a" and "`any`" (if using English). You may override this by using an `Add` statement.
================================================================================




==== Articles

Printing the indefinite (or definite or negative) form of an instance having an indefinite (or definite or negative) article is simply performed by executing the article statements and then the normal printing of the instance, usually the first set of names.

For example

[source,alan]
--------------------------------------------------------------------------------
The owl IsA object
  Indefinite Article "an"
:
--------------------------------------------------------------------------------


This results in output like


[example,role="gametranscript"]
================================================================================
There is an owl here. +
You are carrying an owl.
================================================================================




An article is not used when the instance is displayed when acting on multiple objects, as in:


[example,role="gametranscript"]
================================================================================
&gt; take everything +
(owl) Taken.
================================================================================




For instances that should not have any article at all, like '`some money`', or '`mr Andersson`', an `Indefinite Article` clause containing no statements must be used:

[source,alan]
--------------------------------------------------------------------------------
The money Name some money
  Article
:
--------------------------------------------------------------------------------

Instead of


[example,role="gametranscript"]
================================================================================
There is a some money here.
================================================================================




This will lead to the expected:


[example,role="gametranscript"]
================================================================================
There is some money here.
================================================================================






==== Form

If an instance has a `Definite` (`Indefinite` or `Negative`) `Form`, either through declaration or inheritance, the printing of its definite, indefinite or negative form will be by executing the corresponding statements only; no article declaration is involved. In this way, the author gets complete control over the spelling and inflection of the instance name in definite, indefinite or negative forms. Some human languages will probably require more use of the `Form` form (like Swedish), and some less (like English). The forms are particularly useful if the natural language used, have different forms of the noun itself in definite an indefinite forms. An example is the Nordic languages, which use definite suffixes instead of articles.

The `Article` and `Form` are inherited as one property. That means that an instance may override its inherited form using either of the forms regardless of how its parent defined the form.



==== Printing

You can use various forms of the `Say` statement (see <<Say Statement>>) to choose in which form the instance will be presented. In addition, the embedded parameter references allow selection of the form (<<String Statement>>).



==== Mentioned

The optional (((MENTIONED, clause))) `Mentioned` clause overrides the name for displaying an instance in a short form that will be used when the instance is mentioned e.g. in listings of containers or when the *ALL* (((ALL (player input)))) form of player input is used. A typical use of the `Mentioned` clause is to let some internal state of the instance be reflected in the short form, e.g. if you want the short form of a box to show if it is open or closed you cannot rely on the Names since they are static. Instead, the `Mentioned` clause can print a different short name depending on an attribute.

[source,ebnf]
--------------------------------------------------------------------------------
mentioned = 'MENTIONED' {statement}
--------------------------------------------------------------------------------

For example:

[source,alan]
--------------------------------------------------------------------------------
Mentioned
  If mirror Is broken Then
    "broken"
  End If.
  "mirror"
...
--------------------------------------------------------------------------------



[example,role="gametranscript"]
================================================================================
&gt; take all +
(little black book) OK! +
(green pearl) OK! +
(broken mirror) OK!
================================================================================





[NOTE]
================================================================================
A mention clause declared on a class will override the names of any instance that inherits from it.
================================================================================



=== Container Properties

An instance can also be a container. This is declared by using the (((CONTAINER, property, of objects))) `Container` property clause. The grammar is

[source,ebnf]
--------------------------------------------------------------------------------
container_properties = ['WITH'] ['OPAQUE'] 'CONTAINER'
                           ['TAKING' id]
                           [limits]
                           [header]
                           [empty]
                           [extract]
--------------------------------------------------------------------------------


For example

[source,alan]
--------------------------------------------------------------------------------
The chest IsA object
  With Container
    Limits ...
    Header ...
  Description ...
  :
End The chest.
--------------------------------------------------------------------------------


A (((CONTAINER))) `Container` is something that can contain instances. By default, the instances it can contain must be inheriting from the base class `object`, but by using the `Taking` clause, you can allow any instances.

Instances with the container property, "`inherits`" a special, predefined, Boolean attribute, `opaque`. This attribute can be manipulated in the same way as any other attribute. Its current value indicates if the instances inside the container are visible and accessible or not.

By default, containers expose their content, but by placing the keyword `Opaque` in the container declaration, you indicate that this container declaration will initially prohibit access to the contained instances. A typical use of this is to prohibit access to contents of closed cases, drawers and boxes. Once open such containers usually reveal the content, which then can be accessed. You can implement such behaviour by modifying the built in `opaque` attribute. For example:


[source,alan]
--------------------------------------------------------------------------------
The drawer IsA object
  With Opaque Container
    Header "The drawer contains"
  Verb open
    Does
      Make drawer Not opaque.
      List drawer.
  End Verb.
End The drawer.
--------------------------------------------------------------------------------




[NOTE]
================================================================================
If you want to hide the content of a container, you have to take care so that a `List` statement is not executed while the container is opaque since this will reveal the content. You can check the state of the `opaque` attribute like any other Boolean attribute.
================================================================================


[NOTE]
================================================================================
The predefined `opaque` attribute is only available in instances and classes having the container property.
================================================================================



When an instance with the container property is encountered during game play, it will be described as usual. If the instance has a default description the content of the container will be listed if it is not empty and not opaque.



==== Limits

The (((LIMITS, clause))) `Limits` clause of the container property declaration put limitations on what and how much can be put in the container.

[source,ebnf]
--------------------------------------------------------------------------------
limits = 'LIMITS' {limit}

limit = limiting_attribute 'ELSE' {statement}

limiting_attribute = attribute_definition
                   | 'COUNT' integer
--------------------------------------------------------------------------------



If any of these limits are exceeded when trying to locate anything inside the container, the statements in the corresponding `Else`-part will be executed and the players turn aborted. In fact, these checks are performed because of the execution of a (((locating inside containers))) `Locate` statement (usually as a result of the player issuing a command with the intent of placing something in a container). This means that the execution of a sequence of statements can actually be interrupted in the middle by these limitations.

The specification of an attribute, which must be a numeric attribute on the class the container takes (by default object), implies that the sum of this attribute of all objects in the container cannot exceed the value specified. The special attribute `Count` (((COUNT, in LIMITS))) can be also be used and indicates a limitation on the number of instances allowed.

[source,alan]
--------------------------------------------------------------------------------
Container
  Limits
    weight 50 Else "You can not lift that much."
    Count 2 Else "You only have two hands!"
--------------------------------------------------------------------------------



[NOTE]
================================================================================
The `Count` limit considers all instances in the container. This might differ from the number of instances listed e.g. if the container takes ``Thing``s (which are not 'visible').
================================================================================



Container properties are inherited in its entirety. Locations can't have container properties.



==== Header and Else

[source,ebnf]
--------------------------------------------------------------------------------
header = 'HEADER' {statement}

empty = 'ELSE' {statement}
--------------------------------------------------------------------------------


`Header` is used when the contents of the container is listed. It is intended to produce something like


[example,role="gametranscript"]
================================================================================
"The box contains"
================================================================================



or

[example,role="gametranscript"]
================================================================================
"You are carrying"
================================================================================




It is followed by a list of instances mentioned. <<Mentioned>> describes this listing.

The `Else`-part is used instead of the header if the container is empty.

If `Limits` or `Header` is missing, the Alan system supplies the default of no limits, and the messages output will be equivalent with

[source,alan]
--------------------------------------------------------------------------------
Header
  "The <container> contains"
Empty
  "The <container> is empty."
--------------------------------------------------------------------------------

(<container> is replaced by the actual name of the instance.)



==== Extract

The (((EXTRACT, clause))) `Extract` clause defines what happens when anything is extracted from a container. Any `Locate` statement that moves an instance out of a container is considered an extraction. The extraction will be subject to the restrictions enforced by the `Extract` clause.

[source,ebnf]
--------------------------------------------------------------------------------
extract = 'EXTRACT' [check] [does]
        | 'EXTRACT' {statement}
--------------------------------------------------------------------------------


The extract clause, including optional `Check` and `Does` clauses, allows prohibiting the extraction of the item from the container depending on some condition. If the `Check` is present, it works the same way as for ``Verb``s (see <<Verb Checks>>). I.e. a `Check` without a guard expression will unconditionally prohibit extractions; a `Check` with an expression will evaluate that expression and, if false, execute its `Else` clause, and then abort the move. The `Does` clause will be executed if the optional `Check` passes, or there was no `Check`.

An `Extract` clause without a `Check`, but with a `Does`-clause, executes the Does-clause and then allows the extraction to take place. So, in a way, Checks, if triggered, prevents the extraction, and the `Does`-clause amends to it, being an extensions of the normal case, much like the `Check` and `Does`-clauses for Verbs (see <<Verbs>>). The second form of the clause, with just the statements, is equivalent to an `Extract` with only a `Does`-clause.

An example use of the `Extract` clause is to prohibit, put restrictions on, or modify the behaviour when the hero attempts to take things carried by another actor.

[source,alan]
--------------------------------------------------------------------------------
The waiter IsA actor
  At bar.
  Is Not annoyed.
  Description
    "A slow-moving, traditionally dressed waiter is here."
    List waiter.
    If waiter Is annoyed Then
      "He is rather annoyed."
    End If.
  Container
    Header "The waiter is carrying"
    Else "The waiter is empty-handed."
    Extract Does "The waiter is annoyed by your presupposition."
      Make waiter annoyed.
End The waiter.
--------------------------------------------------------------------------------





=== Verbs

Verbs declared inside an class or instance are inherited in the same way as other properties. See <<Verbs>> for a description on how to declare verbs.

The verbs in a class or instance will only be a candidate for execution if the instance bound to a parameter is of the corresponding class, or is the instance. See <<Verb Execution>> for a detailed explanation.



=== Entered

[source,ebnf]
--------------------------------------------------------------------------------
entered = 'ENTERED' {statement}
--------------------------------------------------------------------------------

The `Entered` clause is only allowed in instances inheriting from the predefined class `location`. This clause will be executed whenever any actor enters the location. Game state changes can be made without restriction.

However, the `Entered` clause is primarily intended for setting up the location in a correct way, not for describing events, actions and states changes. For this the `Description`-clause is recommended.

The `Entered` clause can also be used to restrict the movements of actors other than the `Hero`. (The hero's travels are controlled by exit checks as described in <<Exits,_Exits_>>).

If some of the statements should only apply to a particular actor, it is possible to test for the `Current Actor` with a simple `If` statement.

The actor is located at the location before the clause is executed so `Current Location` will be the location having the clause.

Entered clauses are inherited and locations can be nested (see <<Locations,_Locations_>>). The order of execution is explained by the following table:

// FIXME: CLEANUP TABLE

[cols=",,,",]
|=========================================
| |*Outer Region* |*...* |*Current Location*
|*Base class* |Outermost | |
|*:* | | |
|*Leaf class* | | |
|*Instance* | | |
|=========================================

This means that the first `Entered` clause to be executed is the clause in the base class of the outermost location, if any, then moving down the inheritance of the outermost. After that any parent classes for any intermediate locations are considered in the same way. Finally running any `Entered` clauses in the parents of the new location, ending with the clause in the location itself.


[NOTE]
================================================================================
The `Entered` clause is only executed when the actor is entering the location. This goes for _all_ actors, not only the player/hero. The actor will be at the location when the clause starts to execute.
================================================================================



[NOTE]
================================================================================
If it is the Hero that is moving, the `Description`, including the normal header containing the location name, of the new location will be executed _directly after_ the `Entered` clause.
================================================================================




=== Exits

To build a traversable world of locations, they must be connected. This is done using exits. The syntax for an exit declaration is

[source,ebnf]
--------------------------------------------------------------------------------
exit = 'EXIT' id {',' id} 'TO' id [exit_body] '.'

exit_body = [checks] [does] 'END' 'EXIT' [id]
--------------------------------------------------------------------------------

An (((EXIT))) `Exit` has a list of identifiers, all of which are considered directional words. I.e. when any of those words is input by the player, he will be located at the location identified as the target of the exit. It is possible to customize the exit using a (((CHECK, in exits))) `Check`, that must be satisfied to allow passage through the exit, and statements (`Does`) that will be executed when the player passes through. The checks work as described in <<Verb Checks,_Verb Checks_>>.

If either of the `Check` or `Does` clauses is present, the `End Exit` is required.

Two interconnected locations might be declared like:

[source,alan]
--------------------------------------------------------------------------------
The east_end IsA location Name 'East End of Hall'
  Description
    "This is the east end of a vast hall. Far
     away to the west you can see the west end."
  Exit w To west_end.
End The east_end.

The west_end IsA location Name 'West End of Hall'
  Description
    "From this western end of the large hall it
     is almost impossible to discern the
     opposite end to the east."
  Exit e To east_end.
End The west_end.
--------------------------------------------------------------------------------



[NOTE]
================================================================================
If an exit is declared from one location to another, and you want there to be an exit in the opposite direction, you have to define the reverse passage. It is not created automatically.
================================================================================



Exits are only allowed in classes or instances inheriting from the predefined class `location`.



=== Scripts

The (((SCRIPT))) `Script` is the actor's way of performing things. In a way, it corresponds to what the hero is ordered to do by the player's typed-in commands.

[source,ebnf]
--------------------------------------------------------------------------------
script = 'SCRIPT' id ['.'] [description] {step}
--------------------------------------------------------------------------------

Every script has an identifier (the *id*) to identify it. A script is selected by the (((USE, statement))) `Use` statement. When an actor is started following a script, it will continue with one step after the other, with all the other actors, including the hero, taking turns.

The optional description (((DESCRIPTION, of ACTOR scripts))) allowed in the beginning of a script is used instead of the general description (from the instance declaration) whenever the actor is executing that particular script. If it is not present, the general description is used.

[source,alan]
--------------------------------------------------------------------------------
Actor george
  Name George Formby
  Description "George Formby is here."
  Script cleaning.
    Description
      "George Formby is here cleaning windows."
    Step ...
  Script tuning.
    Description
      "George Formby is tuning his ukelele."
    Step ...
:
--------------------------------------------------------------------------------



An actor continues executing its script until

* it reaches the end
* another `Use` statement is executed for that actor
* the actor is stopped using the `Stop` statement
* something fails


[NOTE]
================================================================================
There are a few things that might fail when an actor executes. One example is an extract, which means that something is removed from a container. As container may define extract checks that action might be prevented. This means of course that that step is aborted, but also that the actor is automatically stopped, so no further steps from the script will be run. The author is responsible for handling this, e.g. by using rules to ensure that the condition is detected and handled correctly.
================================================================================



==== Steps

A script is divided into steps. Each (((STEP))) `Step` contains statements representing what the actor will do in what corresponds to one player move. A step can be defined to be executed immediately next move, to wait a number of moves before it is executed or even to wait for a special situation (condition) to arise.

[source,ebnf]
--------------------------------------------------------------------------------
step = 'STEP' {statement}
     | 'STEP' 'AFTER' expression {statement}
     | 'STEP' 'WAIT' 'UNTIL' expression {statement}
--------------------------------------------------------------------------------


For example

[source,alan]
--------------------------------------------------------------------------------
Step Wait Until hero Here
  Locate waiter Here.
  "From the shadows a waiter emerges: $p
   '-Bonjour, monsieur', he says."
Step After ticksLeft Of train
  "The train driver enters the train, and after a brief
   moment the train starts to move."
--------------------------------------------------------------------------------


When an actor has executed the last step (((STEP, executing the last))) of the current script, it will do nothing more until the next `Use` statement is executed for this actor (the actor will not act, but still present at the location where it was). If this is not what you wanted, you can end each script with a new `Use` statement.



== Additions

In certain circumstances, you need to add properties to a class after it is defined. One simple such example is to add attributes to the predefined classes. To allow this the `Add` construct is available. It follows the grammar

[source,ebnf]
--------------------------------------------------------------------------------
addition = 'ADD' 'TO' 'EVERY' id
               [inheritance]
               {property}
           'END' 'ADD' ['TO'] [id] '.'
--------------------------------------------------------------------------------

Using this construct, you can add any property to a class without having access to its declaration. A standard library would make heavy use of this since it would be structured so that related verbs, their syntax and synonyms are packaged together. If such a package required particular attributes in classes, they could be added using the `Add` construct.



== Syntax Definitions

The (((SYNTAX, construct))) `Syntax` construct is used to specify the allowed structure of the input from the player. Each definition defines the syntax for one `Verb`. The effects triggered by the player input are declared using the `Verb` construct (see <<Verbs>>).

[source,ebnf]
--------------------------------------------------------------------------------
syntaxes = 'SYNTAX' {syntax}

syntax = id '=' {element} syntax_end

element = id
        | '(' id ')' [indicator]

syntax_end = parameter_restrictions
           | '.'
--------------------------------------------------------------------------------




The syntax is defined as a number of _syntax elements_ each being either a player word (a single *id*) or the name of a parameter (an identifier enclosed in parenthesis). Parameters may be in any position, including the first, a syntax with only parameters might be tricky for the interpreter to match to your intentions, as the complete set of allowed input then easily becomes ambiguous.

[source,alan]
--------------------------------------------------------------------------------
Syntax
  quit = 'quit'.
  examine = 'examine' (obj).
  command_north = (act) 'north'.
  unlock_with = 'unlock' (l) 'with' (k).
--------------------------------------------------------------------------------

When the player types a command, it is compared to the set of declared syntaxes. This provides a very flexible way to extend the allowed command set (see also <<Player Input>> for details on general player input).

After the player input has been matched to an allowed syntax, the parameters are bound to the instances referred to by the player. The parameter identifiers in the syntax declaration then refer to those entities. Reference to attributes etc. will be done in the instance referred by the parameter.

[source,alan]
--------------------------------------------------------------------------------
Syntax open = open (obj).
:
  If obj Is open Then ...
:
--------------------------------------------------------------------------------


In the example above, the parameter, `obj`, can be used in the declaration of the `open` verb and will, at execution time, refer to such a bound instance. The following table explains which instances in the game a parameter identifier (l & k, from the `unlock_with` syntax above) will actually refer to.

// FIXME: CLEANUP TABLE
//        1st col should be styled as IF game sessions!

[cols=",,",]
|===========================================================================
|Player input |l |k
|> unlock the door with the key |door |key
|> unlock the bottom drawer with the rusty knife |bottom drawer |rusty knife
|> unlock the skeleton with the tiny blue chair |skeleton |tiny blue chair
|===========================================================================

This, of course, provided that there is an instance that will match the player input, given the adjectives and nouns in the input and in instance declarations.

It is allowed to define multiple syntaxes for the same identifier (verb). See <<Syntax Synonyms,_Syntax Synonyms_>>.



=== Indicators

Following a ((parameter, indicators)) are allowed in syntax declarations.

[source,ebnf]
--------------------------------------------------------------------------------
indicator = '*'' | '!''
--------------------------------------------------------------------------------

There are two indicators available:



* '```+```' -- (((indicator, multiple)))(((multiple indicator)))
  This parameter can reference multiple instances (for example by the player
  using *ALL* (((ALL (player input)))) or concatenating a number of parameters using a conjunction
  like *AND*(((AND (player input)))), see <<Player Input>>).


* '```!```' -- (((indicator, omnipotent)))(((omnipotent indicator)))
  The parameter (the instance the player refers to in this position in the syntax) need not be present at the current location. The default case is that the Alan interpreter requires that a referenced instance must be present at the same location as the hero (if the parameter inherits from `thing`. Note that *entities* are always accessible). For cases when the player must be able to refer to objects and actors that are not present (e.g. in a verb like `talk_about`) this omnipotent indicator can be used to force the interpreter to accept references to any object or actor.

An example

[source,alan]
--------------------------------------------------------------------------------
Syntax
  take = 'take' (obj)*.
  drop = 'drop' (obj).
--------------------------------------------------------------------------------

This shows the syntax definitions for the verbs `take` and `drop`. `take` also allows multiple objects. This would make the following inputs possible


[example,role="gametranscript"]
================================================================================
&gt; take everything except the pillow

&gt; drop the vase
================================================================================




Refer to <<Player Input>> for details on the input of references to multiple parameters (such as objects). The above declarations would force the interpreter to reject player input like


[example,role="gametranscript"]
================================================================================
&gt; drop the shovel and the bucket
================================================================================




This is because the syntax for the verb `drop` does not allow multiple references by not including the multiple-indicator. Another example using the `!` indicator:

[source,alan]
--------------------------------------------------------------------------------
Syntax
  talk_about = 'talk' 'to' (act) 'about' (subj)!.
  find = 'find' (obj)!.
--------------------------------------------------------------------------------

Even if the robber or the key is not present, it will allow the player to say


[example,role="gametranscript"]
================================================================================
&gt; talk to the policeman about the robber

&gt; find the key
================================================================================




For more information on player inputs, refer to <<Player Input>>.

Indicators given in one syntax declaration can affect other syntaxes if they have identical beginnings, like


[example,role="gametranscript"]
================================================================================
&gt; put everything on
================================================================================



and

[example,role="gametranscript"]
================================================================================
&gt; put everything on the table
================================================================================




Even if only one of the syntax declarations indicate that the first parameter should allow multiple instances, both syntaxes will actually allow this because they have the same syntax part before the parameter, in this case the verb "`put`".



=== Parameter Restrictions

To restrict (((restriction, of parameters))) the types of entities the player may refer to in the place of a ((parameter)), its class can be defined by using explicit test in the syntax declaration.


[source,ebnf]
--------------------------------------------------------------------------------
parameter_restrictions = 'WHERE' restriction
                             {'AND' restriction}

restriction = id 'ISA' restriction_class
                  'ELSE' {statement}

restriction_class = id
                  | 'CONTAINER'
--------------------------------------------------------------------------------


[NOTE]
================================================================================
Any predefined or user defined class can be used. Particularly note that integer
and string are predefined classes (see <<The Predefined Classes>>).
================================================================================



The following example describes the syntax for a verb that only allows ``object``s as its parameters (this is however also the default, see below).

[source,alan]
--------------------------------------------------------------------------------
Syntax
  take = 'take' (obj)
    Where obj IsA object
      Else "You can't take that."
--------------------------------------------------------------------------------

Each parameter may be restricted to refer only to instances of particular classes or instances with the container property, or numeric or string literals. The statements following the `Else` will be executed if that restriction is not met, i.e. if the player refers to an instance not in the specified class or classes. The default restriction is `Object`, i.e. if no class restriction is supplied for that parameter identifier the player may only refer to objects at that position in his input.

A more elaborate example of prerequisites for conversation might look like:

[source,alan]
--------------------------------------------------------------------------------
Syntax
  talk_about = 'talk' 'to' (act) 'about' (sub)!
    Where act IsA actor
      Else "Don't you think talking to a person
            might be better?!?!"
    And sub IsA subject
      Else
        Say act. "does not know anything about
                  that."
...
--------------------------------------------------------------------------------


You can combine multiple restrictions, even for the same parameter. If they refer to the same parameter, they must be successively more restricted.

For example:

[source,alan]
--------------------------------------------------------------------------------
Where obj IsA object Else ...
  And obj IsA openable_object Else ...
  And obj IsA door Else ...
--------------------------------------------------------------------------------

References to attributes in the source are only allowed if it can be guaranteed that they exist during run-time. The class restrictions placed on a parameter are used by the compiler to make this guarantee for code executed by player input (verb bodies). The same applies for other semantic restrictions, e.g. you can only use a parameter in a `List` statement if it has been restricted to having the container property.

You can use `IsA Container` to restrict instances to only those entities that are containers (have the container property).

If there is no restriction for a parameter, it is restricted to the class `object`.



=== Syntax Synonyms

It is possible to create multiple syntax declarations for the same verb. The semantics of this is that any of the input formats will be accepted and trigger the same verb action. This is a way to define syntactical synonyms, which are useful to allow multiple forms of input for the same action, increasing chances that the player will find the correct form. For example:

[source,alan]
--------------------------------------------------------------------------------
Syntax give = give (o) to (p) ...
Syntax give = give (p) (o) ...
--------------------------------------------------------------------------------
The syntaxes must be compatible in the sense that the parameters must be named the same. However, the order of the parameters may differ, they will automatically be mapped as appropriate.

Restrictions are only allowed in the first of such syntax declarations. These restrictions will be applied regardless of which syntax was used.



=== Default Syntax

If no `Syntax` is defined for a `Verb` at all, this is handled with one of two default syntaxes (((SYNTAX, default))) according to the two templates below:

[source,alan]
--------------------------------------------------------------------------------
Syntax <1> = <1>.
Syntax <1> = <1> (<2>).
--------------------------------------------------------------------------------

The place-holders represents 1) the name of the verb, and 2) the class in which the verb is first encountered.

The first template is used for verbs that are declared globally, i.e. outside of any class or instance. Since these are only applied when no parameters are used, this will effectively work for simple '`verb-only`' ``Verb``s, such as `quit`, `look`, `save` etc.

Verbs declared in an instance or a class, for which there is no syntax, by default receives a syntax of the common verb/object type corresponding to the second template above. This is a reasonable syntax for many cases and restricts the parameters to instances of the class where the verb was declared. It also implies that the default name for the single parameter is the same as the name of that class, e.g. `object`, `actor`, `thing`, etc. (See <<WHAT Specifications>> for the implications of this.)


[NOTE]
================================================================================
A verb which is declared in a number of classes, or instances of various heritage, can not be handled with the default rules, since that would imply that the parameter should be restricted to multiple classes at the same time. This case must be handled explicitly.
================================================================================



[NOTE]
================================================================================
A verb with no declared syntax, which is declared in a location, will receive a default syntax restricting the parameter to the class `location`, which probably is not what you wanted.
================================================================================



=== Scope

If the player inputs a command following a syntax which requires parameters, the interpreter first determines if the referenced instance is in scope. This is performed even before the restrictions are executed.

There are a number of ways to get an instance into scope:

* Instances of `entity`, and of any user defined subclasses thereof, are always
  in scope.

* An instance of `thing` and its subclasses at the current location, including
  any nested locations, is in scope.

* An instance of any class inside a container that is in scope is in scope,
  unless that container is opaque and closed. See <<Container Properties,
  _Container Properties_>> for details.

* If the syntax indicated a parameter as omni-potent, any instance is in scope
  for that parameter position.

If the interpreter finds multiple instances matching the input (the set of given adjectives and noun), it will try to disambiguate with preference to instances present, i.e. at the location of the hero. If there still are multiple candidates after this, the interpreter will print a message and abort execution of the current command.

When all parameter positions in the syntax have been resolved in this way, the restrictions are executed.



== Verbs

[source,ebnf]
--------------------------------------------------------------------------------
verb = ['META'] 'VERB' id {',' id}
           verb_body
       'END' 'VERB' [id] '.'

verb_body = simple_verb_body
          | {verb_alternative}

simple_verb_body = [check] [does]
--------------------------------------------------------------------------------

A (((VERB, declaration))) `Verb` declaration specifies what to check and the effects of something the player does (i.e. commands using a syntactically legal input).

[source,alan]
--------------------------------------------------------------------------------
Verb take, get
  ...
End Verb take.
--------------------------------------------------------------------------------

Verbs can be declared at two different levels, global (outside any other declaration) or inside a declaration of a class or instance, including inside an `Add` construct.

A global declaration will only be considered when the verb is not applied to any instance (i.e. such as the player referring to an object). In fact, a global verb cannot include any parameters in their syntax declaration.

A verb declaration inside a class definition or an instance will be considered if that instance (or an instance inheriting from that class) is used as a parameter in the input.

The identifiers in the list (`take` and `get` in the example above) will be player words that by default can be used to invoke the verb. But if a `Syntax` is declared for the `Verb` (see <<Syntax Definitions>>), the identifiers in the list will not be accessible to the player, instead the sequence of words and parameters specified in the `Syntax` must be used.

If there is more than one identifier in the list, as in the example above, this can be viewed as a short hand for declaring identical checks and bodies for all the verbs in the list. This will create synonymous actions for different verbs on the level where the verb declaration is. They may differ in implementation at other places, i.e. if they are declared in the same verb declaration on one level in an inheritance tree, they can still have different bodies on another level.

=== Meta Verbs

Any action from the player usually takes one 'tick' in the default simulated game time. Sometimes you want a player command to _not_ take a 'tick', for example administrative commands like 'help', 'score' etc.

You can do this by attaching `Meta` in front of the verb definition:

[source,alan]
--------------------------------------------------------------------------------
Meta Verb 'score'
  Does
    Score.
End Verb.
--------------------------------------------------------------------------------



If your verb has multiple definitions, e.g. for various classes, applying `Meta` to any one of them will make the verb a meta verb, meaning that if the player uses that verb in any context and on any instance, it will take no tick, even if that particular definition did not have the `Meta` property explicitly expressed. A library might decide that 'score' was a meta verb and there is nothing you, as an author, can do to override that short of editing the library source.

A `Meta` verb also does not trigger evaluation of rules and events so they are genuinely "`outside`" the game and should only be used with verbs that are not considered part of the players progression inside the game.


[NOTE]
================================================================================
The meta verb feature only applies to the built in timing mechanism known as 'ticks', where every player command counts as 1 tick. It is possible to implement your own timing mechanism, in which case the `Meta` does not help.
================================================================================





=== Verbs in Locations

A special case is a verb declared in, or inherited by, the location where the player currently is located. If this verb is used, any checks or body of that verb will be considered before the verbs in the parameters. An example might be a location representing walking on a high wire. Anything dropped at the following location will disappear:

[source,alan]
--------------------------------------------------------------------------------
The high_wire IsA location
  Verb drop
    Does Only
      Locate o At limbo. - Instead of "here".
  End Verb.
End The.
--------------------------------------------------------------------------------


=== Verb Checks

[source,ebnf]
--------------------------------------------------------------------------------
check = unconditional_check
      | check_list

unconditional_check = 'CHECK' {statement}

check_list = 'CHECK' expression 'ELSE' {statement}
             {'AND' expression 'ELSE' {statement}
--------------------------------------------------------------------------------


To determine if the action is possible to carry out, the ((CHECK)) ``Check``s are executed. Which checks to run, is determined by the class of the instances bound by the parameters to the verb. All checks in the inheritance tree are tried by starting at the base class. In this way, the most general checks are tried first, then more specific.

A typical use of a check is to verify if the parameter has a particular property:


[source,alan]
--------------------------------------------------------------------------------
Verb take
  Check obj Is moveable
    Else "You can't take that."
  ...
End Verb take.
--------------------------------------------------------------------------------

If no expression is specified for a check, that check will always fail, in effect becoming an (((CHECK, unconditional))) unconditional `Check`. This is useful for preventing certain actions, such as at specific locations, since the checks are always executed first.

[source,alan]
--------------------------------------------------------------------------------
The jumpless IsA Location
  Verb jump
    Check "You can't do that here."
  End Verb jump.
End The jumpless.
--------------------------------------------------------------------------------

If any check should fail, the execution of the current verb is interrupted and the statements following the failing check are executed. The user (player) is then prompted for another command. So in the above example, the verb "`jump`" will always result in "`You can't do that here.`" at the location "`jumpless`".


[NOTE]
================================================================================
``Check``s are intended to take care of any _exceptions_ for executing the normal case. The normal, or positive/affirmative, case should be handled by the `Does`-clause.
================================================================================



With this in mind, ``Check``s are also used when handling the user input *ALL* (((ALL (player input)))) (see <<Player Input>> for details on possible player input). The mechanisms for this involve examining all objects at the current location and evaluating all checks for the verb. Any objects that do not pass the checks are not considered for execution. This limits the handling of *all* to only executing the verb bodies for objects that are reasonable, i.e. that will not fail in the ``Check``s.

For example assuming the above definition of the verb take and a location containing the two objects, `ball` and `box`, of which only the `ball` is `takeable` the player input


[example,role="gametranscript"]
================================================================================
&gt; take all
================================================================================




would result in *all* representing only the ball. See <<Player Input>> for an explanation of the player view of this.



=== Does-clause

[source,ebnf]
--------------------------------------------------------------------------------
does = [qualifier] {statement}

qualifier = 'BEFORE'
          | 'AFTER'
          | 'ONLY'
--------------------------------------------------------------------------------

If all checks succeed, the execution (((DOES, in verbs))) of the verb will be carried out. Multiple verb bodies may be involved. The order is by default to first execute the body of any verb declaration for the current location (including verb bodies inherited by it). Each parameter is then examined to find any declarations of that verb for the instance (including inherited verb bodies). These verb bodies are then executed in the order in which the parameters occurred in the syntax declaration, for each parameter starting with the body in the most basic class. By default, all of the involved verb bodies are executed. This is the most natural order and covers most cases.

In some infrequent situations, another order may be necessary. By using the (((VERB, qualifiers))) qualifiers, `Before`/`After`/`Only`, the author can decide which verb bodies will be executed and in which order (see <<Verb Qualification,_Verb Qualification_>> below for details).

A simple verb example:

[source,alan]
--------------------------------------------------------------------------------
Verb take
  Check obj Not In inventory
    Else "You already have that."
  Does
    Locate obj In inventory.
End Verb take.
--------------------------------------------------------------------------------



=== Verb Alternatives

[source,ebnf]
--------------------------------------------------------------------------------
verb_alternatives = 'WHEN' id simple_verb_body
--------------------------------------------------------------------------------

When a `Verb` (((VERB, alternative))) is declared within an instance declaration, verb alternatives are allowed. These alternatives are used in conjunction with the `Syntax` declaration defined for the verb and allows differentiating between the instances occurring in different places in the input.

When a player inputs a command, each parameter in the syntax (see above) is bound to an actual instance or receives the value of a literal, depending on the specified syntax. To determine the checks to test and verb bodies to execute the parameters are examined in turn according to the algorithm described in the section <<Verb Qualification,_Verb Qualification_>> below. Each instance may have different verb bodies executed depending on at which position it occurred (to which parameter it was bound).

For example, assume the following syntax definition

[source,alan]
--------------------------------------------------------------------------------
Syntax break_with = 'break' (o) 'with' (w).
--------------------------------------------------------------------------------

If used with the `delicate_vase` actions could differ if it occurs as the direct object (o), or if it occurs as the indirect object (w). To implement this the `Verb` body for `break_with` should also differ. For each parameter in the syntax, you may define different actions by supplying a verb alternative for each parameter identifier. The verb declaration could look like

[source,alan]
--------------------------------------------------------------------------------
The feather IsA object
  Verb break_with
    When o Does
      "The feather is even more flat than before."
      Make feather flat.
    When w Does
      "There is not much that you can break with a feather!"
  End Verb break_with.
End The feather.
--------------------------------------------------------------------------------

If no alternative is explicitly specified the verb body will be considered for all positions in the syntax. The compiler will warn for this if the syntax allowed the class of instance to occur in all the parameter positions.



=== Verb Qualification

[source,ebnf]
--------------------------------------------------------------------------------
qualifier = 'BEFORE'
          | 'AFTER'
          | 'ONLY'
--------------------------------------------------------------------------------

The order in which the different verb bodies are executed is normally from the most general to the most specific. But, to allow for local differences, i.e. special handling of the verb at this location, a any possible definition of this verb in the current location (included inherited verb bodies) are considered first. Then, the verb bodies in the parameters (in the order they appeared in the syntax definition) on which the verb was applied are examined to find and execute their verb definitions. For each parameter, its most general definition is executed first, verb bodies down the inheritance tree next, ending with any verb body declared in the specific instance bound to that parameter.

In most circumstances, this is the most logical order, but if another order is required, the `Verb` qualifiers (((VERB, qualifiers))) (((AFTER, qualifier))) `After`, (((BEFORE, qualifier))) `Before` and (((ONLY, qualifier))) `Only` may be used to alter this behaviour. The qualifiers alter the order of execution and a strict definition of this is described below.



=== Verb Execution

(((VERB, execution order)))
First all parameters are evaluated according to the syntax restrictions (see <<Parameter Restrictions,_Parameter Restrictions_>>). Then, if they passed, the checks of all verb declarations are evaluated (see <<Verb Checks>>). Finally the verb bodies are executed in the normal order as explained by the table below.

// FIXME: CLEANUP TABLE

[cols=",,,,,,",]
|===================================================================================
| |*Outer Region* |*...* |*Current Location* |*First parameter* |*...* |*Last parameter*
|*Base class (entity)* |Outermost | | | | |
|*:* | | | | | |
|*Leaf class* | | | | | |
|*Instance* | | | | | |Innermost
|===================================================================================

The table above illustrates the normal order of execution of verb bodies and checks. Starting with any base classes to the outermost region (containing location), continuing to the actual instance of that location, as illustrated by the first column. It then continues with any inner regions (second column) and the current location itself (third column). The execution then proceeds to the parameters of the syntax in order (columns four through six), traversing the inheritance tree from the base class to the instance.


[NOTE]
================================================================================
If you add a verb to the class `entity`, it will be inherited by all instances, including locations and objects. This will result in the execution of that verb body multiple times, since it will be in every column in the table above.
================================================================================



==== Controlling Execution with Qualifiers

There are cases where you don't want all the bodies to be executed, or there is a special need to execute them in a different order. The most common case is to prohibit other bodies to be executed, e.g. a verb body in a location might want to stop the player from throwing any object. This verb body must then ensure that it is the only verb bodies to be executed. This can be done using the `Only` qualifier (see <<Verb Qualification>>).

Qualifiers control the order of execution of verb bodies. How does this work?

First, starting at the "`innermost`" according to the table above, the verb in the last parameter (if any) is investigated and, if any of its (inherited) verb bodies have the `Before` or `Only` qualifier it is executed. If the qualifier was `Only` the execution is also aborted at this stage and no more verb definitions are examined, otherwise the other parameters are examined in the same way.

In the next step, the current location is examined and, if it contains (or inherits) a verb definition with a `Before` or `Only` qualifier, that definition is now executed (and if the qualifier was `Only`, execution is aborted). Since locations can be nested, the surrounding locations are then examined in the same way.

As a result of this behaviour, a `Before` qualifier in the verb definition in an object parameter will supersede an `Only` qualifier in the location.

At this stage, all `Before` and `Only` qualifiers are handled appropriately. This only leaves the definitions without any qualifier or with the `After` qualifier. The outermost verb body (as indicated in the table above) is examined and if it did not have the `After` specification, it is executed (if it had an `Only` qualifier execution is stopped after executing it). Any definition of the verb in the current location is again examined and, if it did not have the `After` qualifier, it is executed. What remains is to execute the verb definition in the parameters if they have not been executed already, and to execute the location definition if they where declared with the `After` qualifier.

So in short (with base class definitions of the outermost location being the outermost and the instance bound to the last syntax parameter the innermost):

* From the outside in, find any `Before` or `Only` definitions and execute them (stop if `Only` found).
* From the inside out, execute any definitions not already executed and not declared with the `After` qualifier.
* Execute the remaining verb definitions (those with an `After` qualifier) from the outside in.

The second item in the above list is equivalent to the normal order of execution.

The qualifiers are a powerful but confusing concept. The normal order of execution is usually appropriate and only in special cases should qualifiers be used. When they are needed, you will find that one qualifier at the correct definition will normally do the trick. The above algorithm is used to get a strict definition of the execution order. It is not expected that all this complex behaviour will be needed in practice.


[NOTE]
================================================================================
All ``Check``s (((CHECK, execution order))) for a `Verb` will always be run in the normal order regardless of any `Before`/`After`/`Only` qualifiers.
================================================================================



An example of the use of qualifiers is to ensure that only the verb body within the object is executed:


[source,alan]
--------------------------------------------------------------------------------
The bomb IsA object
  Verb examine
    Does Only
      "Your curious fingering at the intricate
       mechanism sets it of. BOOOM!"
      Quit.
  End Verb examine.
End The bomb.
--------------------------------------------------------------------------------


This also illustrates the fact that the most commonly used qualifier is the `Only` qualifier since it is used whenever all other behaviour is replaced by some special behaviour.



== Events

An (((EVENT))) `Event` is a sequence of statements executed at a specified time (count of turns). It is also executed at some specific location. An event can e.g. be used to create an explosion where the bomb is three moves from now or to let the ceiling of the cave fall down in five moves.

[source,alan]
--------------------------------------------------------------------------------
Event nearby_explosion
  "Somewhere in the distance there is an explosion."
  Make bomb gone_off.
  Schedule small_avalanche After 2.
End Event.
--------------------------------------------------------------------------------

The body of an event can be any sequence of statements. They can however not refer to any parameters, since no verb is executing, or the `Current Actor`. See <<Run-time Contexts,_Run-time Contexts_>>.

Events may be scheduled and cancelled with the `Schedule` and `Cancel` statements (see <<Event Statements,_Event Statements_>>).



== Rules

[source,ebnf,subs="macros"]
--------------------------------------------------------------------------------
rule = 'WHEN' expression ('THEN' | '=>')(((RULE, syntax for)))
           {statement}
       ['END' 'WHEN' '.' ]
--------------------------------------------------------------------------------


A (((RULE))) `Rule` is an arbitrary expression, which, when true, results in the execution of some given statements. Rules can only be declared on the global level (not inside classes or instances). The main intended use of rules is to detect particular situations and then trigger some action. Typically they can be used to make things happen when certain situations arise, such as starting an actor when the hero enters the cave.

Here is an example that investigates if the hero is in the cave and if so, activates the monster:

[source,alan]
--------------------------------------------------------------------------------
When hero At cave And monster Not active Then
  Use Script hunting For monster.
End When.
--------------------------------------------------------------------------------

The expression that is tested may of course have any level of complexity:

--------------------------------------------------------------------------------
When hero At cave
  And (monster Is hungry Or monster Is angry)
  And sword Not In hero
=>
  Use Script eat_hero For monster.
End When.
--------------------------------------------------------------------------------

Each actor action and event execution is considered atomic (it can't be divided into smaller parts). All rule conditionals are evaluated (((RULE, execution))) after each actor (including the player) has acted (script step and player command respectively) and after each event has executed. In effect this will mean that a change in state will be detected almost immediately, if there is a rule for detecting that change.

The statements within the rule are triggered when the condition _becomes_ true. In the first example, this means that if the monster is not active, the statements will be executed when the hero enters the cave ('hero At cave' becomes true). A rule body can never be executed twice in succession unless the conditional has been evaluated to false in between. In the example above, the triggering of the hunting script for the monster will not happen again unless either the hero has left the cave and entered it again, or the monster has been active and then become not active again.

The use of parameters, `Current Actor`, `Current Location`, `Here` and `Nearby` is not allowed in rules conditionals or bodies.

Rules are executed at no location. Therefore it is not possible to communicate directly with the player in the rule with output statements (since the hero cannot be where the rule is executing, see <<Output Statements>>). Triggering an event that handles the output intended for the player, is the recommended solution to this.

The following is a complete game using a rule:

// FIXME: Render 'Count IsA actor, At kitchen = 1' in different BG color!

[source,alan]
--------------------------------------------------------------------------------
The kitchen IsA location
  Exit x To kitchen.
End The kitchen.

When Count IsA actor, At kitchen = 1
  Then Schedule whee At actor After 0.
End When.

Event whee
  "Whee!"
End Event.

Start At kitchen.
--------------------------------------------------------------------------------


In this example the rule conditional (the text marked with grey) is using an aggregation (`count`, see <<Aggregates>>) over two filters (see <<Filters>>) that will count the number of actors at the kitchen, and when that number becomes one, the rule will trigger and execute the statements, in this case scheduling an event that handles the presentation of the output to the player.

Again, remember that rules are checked after each actor has moved. What happens if there are more actors in play and they move in and out of the kitchen, is left as an exercise to the reader.



== Synonyms

[source,ebnf]
--------------------------------------------------------------------------------
synonyms = 'SYNONYMS' {synonym_declaration}

synonym_declaration = word {',' word} '=' word '.'
--------------------------------------------------------------------------------

A (((SYNONYMS, declaration))) `Synonyms` declaration declare words that, when used in player input, are always interchangeable. For example

[source,alan]
--------------------------------------------------------------------------------
Synonyms
  'i', 'invent' = 'inventory'.
  'q' = 'quit'.
--------------------------------------------------------------------------------

The word on the right hand side of the equal sign must be a word defined elsewhere in the adventure source, such as (part of) an instance name (a noun or adjective), a direction or a verb. The list of words on the left-hand side contains new words (_not_ defined elsewhere) that always will be interpreted as being replaced by the word on the right in the player input.

Synonyms are player words that can be interchanged. Defining synonyms for verb names will not always give you the result that you expect. The following example is incorrect.

[source,alan]
--------------------------------------------------------------------------------
Synonyms
  'examine' = look_at.
Syntax
  look_at = 'look' 'at' (obj).
Verb look_at ...
--------------------------------------------------------------------------------

This will result in an error message indicating that the synonym word `look_at` is not defined. This is because the `Syntax` (see <<Additions>>) defined the verb `look_at` to have the specified syntax (including the player words '`look`' and '`at`'), the player word `look_at` is not defined, which is as well as the player would not be able to input a word with an underscore (see <<Player Input>>).

You can achieve the desired effect by instead giving multiple verb identifiers in the verb declarations; this will give the same verb bodies (checks and actions) to multiple verbs. See <<Verbs,the section on _Verbs_>> for details on verb declarations.

It is also possible to define multiple names for an instance to achieve other effects similar to synonyms. See <<Names>> for a description of this.



== Messages

The Alan system has a number of standard messages built in. These messages are presented to the player in various situations, both normal and otherwise. An example is the following:


[example,role="gametranscript"]
================================================================================
&gt; go north +
You can't go that way.
================================================================================




The response "You can't go that way." is a typical example of such system messages (for details see <<Input Response Messages>>).

To make the user dialogue more adapted to the settings you select, Alan allows you to define your own version of these messages. The grammar for this is

[source,ebnf]
--------------------------------------------------------------------------------
messages = 'MESSAGE' {message}

message = id ':' {statement}
--------------------------------------------------------------------------------


An example would be:

[source,alan]
--------------------------------------------------------------------------------
Message
  NOWAY: "There is no exit in that direction."
--------------------------------------------------------------------------------

If the above where used in the source for the same game as the previous example, it would instead look like:


[example,role="gametranscript"]
================================================================================
&gt; go north +
There is no exit in that direction.
================================================================================




The `Message` constructs allows general statements following the message identifier:

[source,alan]
--------------------------------------------------------------------------------
Message NOWAY:
  If Random 1 To 2 = 1 Then
    "There is no way in that direction."
  Else
    "You can't go there."
  End If.
--------------------------------------------------------------------------------


The standard message for `Noway` is replaced by the output from the statements in the definition. For a complete list of all the identifiers of messages and their use, see <<Run-time Messages>>.



=== Message parameters

Message sections must be declared at the global level, but to make it possible to create high-quality messages the message sections have parameters available. Which parameters are available vary depending on the message, the details for each message is available in <<Input Response Messages>>.

The parameters can be used in the same way as in verb bodies. The names of the parameters are "`parameter1`", "`parameter2`", etc. The type of the parameters will also vary.

For some messages, a parameter is an instance. In these cases, the instance is always of the predefined `entity` class. Any attribute available for this class will be available in message sections with instance parameters.


[NOTE]
================================================================================
If the message must be modified according to the case of the noun, which is the case with adjectives and negative forms in many languages, an attribute available on all instances can be used to select the correct form.
================================================================================




== Prompt Section

The (((PROMPT, section))) `Prompt` section allows you to customize the way players are prompted for their input.

[source,ebnf]
--------------------------------------------------------------------------------
prompt = 'PROMPT' {statement}
--------------------------------------------------------------------------------

The default prompt for player input, which will be used if no `Prompt` section is declared, looks like


[example,role="gametranscript"]
================================================================================
&gt;
================================================================================



Using the following `Prompt` section it can be set to something else:

[source,alan]
--------------------------------------------------------------------------------
Prompt "What now?""
--------------------------------------------------------------------------------

Then the player will of course see


[example,role="gametranscript"]
================================================================================
What now?
================================================================================




In fact, the `Prompt` section allows any statements, not just strings. So you can have the prompt change during the game.

[source,alan]
--------------------------------------------------------------------------------
Prompt
  "Hello" Say hero. "!$n"
  "Where do you want to go from"
  Say Current Location. "?"
--------------------------------------------------------------------------------

This will give the following output:


[example,role="gametranscript"]
================================================================================
*Pirates Bay Harbor* +
You can see the town of Pirates Bay to the north, and your ship is at the docks, to the south. +
Hello Jack Sparrow! +
Where do you want to go from Pirates Bay Harbor?
================================================================================




[NOTE]
================================================================================
The prompt section is global and applies to the whole game. There is currently no way to dynamically customize the prompt except by using the statements inside the Prompt section itself.
================================================================================




== Start Section

The (((START, section))) `Start` section defines where the player (the hero) will be at the start of the game. This must be a location. Optionally this may be followed by statements to be executed at the beginning of the game, such as hello-messages or short instructions as well as starting any actors and scheduling events.

[source,ebnf]
--------------------------------------------------------------------------------
start_section = 'START' where '.' {statement}
--------------------------------------------------------------------------------

An example would be

[source,alan]
--------------------------------------------------------------------------------
Start At outside_house.
  Schedule bird_chirp After 5.
--------------------------------------------------------------------------------

Only the `At What` form of the `Where` construct (see <<WHERE Specifications>>) is allowed in the `Start` section. Any statements are allowed in the start section but they cannot refer to any parameters.

The start section must be the last declaration in an Alan source.



== Statements



=== Output Statements

There are various ways to present output (((output statements))) to the player, string output, descriptions, printing expressions, listing container content and showing pictures.

The interpreter intersperses your output with spaces whenever needed. This might for example occur between two output strings:

[source,alan]
--------------------------------------------------------------------------------
"There is a door into the kitchen."
If kitchenDoor Is open Then
  "It is open."
End If.
--------------------------------------------------------------------------------

If handled simple-mindedly the two texts would be adjoined and you as an author would need to cater for this. Instead Alan realizes that a space is required between them. This space is automatically inserted by the interpreter during game play. This is also the case if the output from a `Say` statement is followed by an output string.

[source,alan]
--------------------------------------------------------------------------------
"Your wristwatch shows" Say hours Of watch.
". Time to go."
--------------------------------------------------------------------------------

However, as in this example, this is not always the intended output. Particularly, if the `Say` statement terminated the previous sentence, as in the example, we want the full stop to be placed immediately after the output. So, the Alan interpreter will leave out the space between two outputs if the second starts with a period (full stop) followed by a space, or is the single character in the string. This special handling also applies to strings starting with a comma.

Whenever an output statement is executed, the result will be printed on the players terminal with the following important exception: if an output statement is executed at a location in the game where the hero not presently is, the output will not be shown. This important feature will relieve the author from the burden of constantly considering what the player will see. It can be used in the following way:

[source,alan]
--------------------------------------------------------------------------------
"Charlie Chaplin leaves the house through the front door."
Locate charlie_chaplin At outside_house.
"Charlie Chaplin comes out from the nearest house."
--------------------------------------------------------------------------------

If the hero is inside the house or out in the street, he will get different views of the situation. This feature ensures that the player only sees what is going on at the current location, and allows for easy adaptation to various viewpoints on the events without the need for any special tests. But see <<Distant Events,_Distant Events_>> for a solution in the case the hero need to be informed about things happening where he isn't.



==== String Statement

[source,ebnf]
--------------------------------------------------------------------------------
output_statement = STRING
--------------------------------------------------------------------------------

The simplest case of output is just a ((string)), i.e. any text, possibly stretching over multiple lines, surrounded by double quotes. See also <<Strings>> for some detailed descriptions on the definition of strings.

Some character combinations (((character combinations, in strings))) have special meaning for the printout:

// FIXME: Find a way to make chars on the left bold styled!
................................................................................
$p    New paragraph (usually one empty line)
$n    New line
$i    Indent on a new line
$t    Insert a tabulation
$$    Escape from automatic space insertion and capitalization
$a    The name of the actor that is executing
$l    The name of the current location
$v    The verb the player used (the first word)
$_    Print this as a '$' if in conflict with other symbols
................................................................................


// @NOTE: I've substituted the underscore symbol with its XML Entity because it
//        was breaking syntax highlighting in Sublime Text's AsciiDoctor package!
//        The problem is only in ST, and the original compiled well, but it broke
//        up the whole document syntax from this point on, making it impossible
//        to work on it using Sublime text.

[NOTE]
================================================================================
You might want to output "`$400`" but "`$4`" will be interpreted as the indefinite form of the fourth parameter, as described below. So you need to use the '`&#95;`' to make that happen ("`$&#95;400`").
================================================================================




The following can be used to refer to parameters while executing a verb, but the `Say` statement (see below) is safer and preferred whenever possible:

// FIXME: Find a way to make chars on the left bold styled!
................................................................................
$<n>     The parameter <n> (<n> is a digit > 0, e.g. "$1")
$+<n>    Definite form of parameter <n>
$0<n>    Indefinite form of parameter <n>
$-<n>    Negative form of parameter <n>
$!<n>    Pronoun for the parameter <n>
$o       The current object (first parameter)
................................................................................


[NOTE]
================================================================================
The `$<n>` formats must be used with care as they are not checked at compile time, e.g. you can use "```$+1```" in a context where no parameter is defined which would lead to a run-time error. To avoid the risk of any run-time problems use the `Say` statement with the parameter name wherever possible. See <<Say Statement,_Say Statement_>> below.
================================================================================



[NOTE]
================================================================================
The use of `$o` is deprecated. The `<n>` variants are better, but the recommended use is to refer to the parameters using their parameter names in a `Say` statement instead. This will ensure full reference analysis by the compiler protecting against any runtime error.
================================================================================


==== Style Statement

[source,ebnf]
--------------------------------------------------------------------------------
style_statement = 'STYLE' style '.'

style = 'NORMAL'
      | 'EMPHASIZED'
      | 'PREFORMATTED'
      | 'ALERT'
      | 'QUOTE'
--------------------------------------------------------------------------------



The style of the text output can be controlled using the `Style` statement. With the exception of the `Emphasized` style, the styles are intended to be applied to whole paragraphs. The style indicated in the statement applies until another `Style` statement is executed.


[NOTE]
================================================================================
The exact visual appearance of the styles is implementation dependent. In fact, there is no guarantee that the styles will actually differ.
================================================================================



==== Describe Statement

[source,ebnf]
--------------------------------------------------------------------------------
output_statement = 'DESCRIBE' what '.'
--------------------------------------------------------------------------------

The (((DESCRIBE, statement))) `Describe` statement executes the description part for an instance, such as an actor, an object or a location. If no such description exists a default description, such as

[source,alan]
--------------------------------------------------------------------------------
"There is a coin here."
--------------------------------------------------------------------------------

is used instead. In this case, if the instance has the container property, a `List` statement is also executed for that object automatically (see below).

If a `Describe` statement is executed for another instance during the execution of the description clause, the system will recognise this and make sure that the second instance is not described more than once. This makes it possible to use instances as parts of a location and embedding their description at the correct place in the longer description of the location.

[source,alan]
--------------------------------------------------------------------------------
"This office is dusty and probably hasn't been used for
 many years."
DESCRIBE desk.
"To the west is an open door, and to the east you can see the
 staircase.""
--------------------------------------------------------------------------------




==== Say Statement

[source,ebnf]
--------------------------------------------------------------------------------
output_statement = 'SAY' [form] expression '.'

form = 'THE' | 'AN' | 'IT' | 'NO'
--------------------------------------------------------------------------------


The (((SAY, statement))) `Say` statement will output a short description of what is referred to by the expression. If it refers to an instance, it will print the name of it or execute its `Mentioned` clause if one is available. If it refers to an attribute, it will print its value, such as an integer or a string. Parameter names are also allowed in the `Say` statement, which, of course will result in a short description of the instance to which it is bound, or a printing of the literal (if the parameter was a *String* or *Integer* parameter).

[source,alan]
--------------------------------------------------------------------------------
If contents Of bottle > 0 Then
  "In the bottle there are still"
  Say contents OF bottle.
  "litres of water left."
Else
  "The bottle is empty."
End If.
--------------------------------------------------------------------------------


If the *what* part refers to an instance, the optional `form` may be used to control in which form the instance will be output.

If `THE` is used the form used will be the definite form, usually the short form preceded by a definite article. Correspondingly, the use of `AN` indicates an indefinite form. A third form, using `NO`, is available. It indicates that the negative form as defined by the negative article or form should be output. Refer to <<Articles and Forms>> for a description of the definite/indefinite articles and forms. Finally, the `IT` form will print the pronoun associated with the instance.



==== List Statement

[source,ebnf]
--------------------------------------------------------------------------------
output_statement = 'LIST' expression '.'
--------------------------------------------------------------------------------

The (((LIST, statement))) `List` statement lists all objects in a container together with the header as specified for the container. If the container is empty, the statements in the empty clause of the container are executed instead.

[source,alan]
--------------------------------------------------------------------------------
"The chest is heavy."
If chest Is open Then
  List chest.
End If.
--------------------------------------------------------------------------------

Of course, the instance being listed must be an instance that has the container property, which may be inherited. This instance can be referred to by being bound to a parameter or a ((reference attribute)) for example.

=== Multi-media Statements

Alan has some multimedia provisions, although they may not be available on every platform and implementation. The `Show` statement, presents an image in the output window, and the `Play` statement plays a sound.

The Alan compiler will always support the multi-media statements, but a particular interpreter might not do so. Most GLK-based interpreters will support it but others might also. The game will still play fine, but the multi-media resources will silently be ignored. There is also no way to check for this in your source code. So, don't rely on them for your story, particularly do not give the player necessary information only through pictures.

Image and sound files are analyzed by the compiler and copied into an Alan v3 resource file (file extension *.a3r*) that must be distributed with your game file, otherwise they will not be available during game play. The original file will be left untouched.

The format of the resource file follows the standard Interactive Fiction resource file format "`blorb`" and supports images of JPEG and PNG types, and sounds of MOD and AIFF formats.

If a resource file is referenced from multiple statements, it will only be copied once. The Alan compiler uses the file extension to determine the media type of the file. The following extensions are recognized: *.jpg*, *.jpeg*, *.png*, *.mod*, *.aif* and *.aiff*.



==== Show Statement

[source,ebnf]
--------------------------------------------------------------------------------
output_statement = 'SHOW' id '.'
--------------------------------------------------------------------------------

The *id* should be the name of an image file. Since filenames may contain various special characters, a quoted identifier (see <<Filenames,_Filenames_>>) is usually required.

Alan currently supports the PNG and JPEG formats only.

==== Play Statement

[source,ebnf]
--------------------------------------------------------------------------------
output_statement = 'PLAY' id '.'
--------------------------------------------------------------------------------

The *id* should be the name of a sound file. Since filenames may contain various special characters, a quoted identifier (see <<Filenames,_Filenames_>>) is usually required.

Alan currently supports the MOD and AIFF formats only.[[X30946]]

=== Manipulation Statements



==== Locate Statement

[source,ebnf]
--------------------------------------------------------------------------------
locate_statement = 'LOCATE' what where '.'
--------------------------------------------------------------------------------

The (((LOCATE, statement))) `Locate` statement is a way of transferring instances to new locations. When executed, the indicated instance will be placed at the location given. For a description on how to specify where, see <<WHERE Specifications>>. When an actor is located at a new location the `DOES` clause of that location is always executed.

One special case of the `Locate` statement is when the predefined actor `hero` is located somewhere. This is analogous to the player typing a direction, i.e. the hero will be located at the appropriate location. Under particular circumstances, you may want to locate the player at a different location as a side effect of another action. For example:

[source,alan]
--------------------------------------------------------------------------------
Event explosion
  "Suddenly the door seems to bulge outwards, it bursts
   open throwing rocks and splinters everywhere. The
   impact of the explosion literally throws you back
   out in the hallway."
  Locate hero At hallway.
End Event explosion.
--------------------------------------------------------------------------------

In this case, the new location will be described and the `Does` clause of that location executed.

Another special case is when locating (((locating inside containers))) something inside a container. The `Locate` statement will then cause the execution of the limits of that container, and if any of the limits are exceeded the complete player turn is aborted immediately, resulting in no more statements being executed. So, if a player command should result in the location of an object inside a container, a good thing is to place the `Locate` statement as early as possible, as this enforces the limit checks in the beginning of this player turn.

A very special third case is locating a location at another location. Locations can in this way be (((nested locations))) nested, resulting in an outer location working as a region or surrounding for the inner location. The effect of this is that any instances present in the outer location are reachable from the inner.



==== Empty Statement

[source,ebnf]
--------------------------------------------------------------------------------
empty_statement = 'EMPTY' what [where] '.'
--------------------------------------------------------------------------------

The (((EMPTY, statement))) `Empty` statement locates all instances currently located inside the given container (instance with the `Container` property) at a certain location. The meaning of the `where` part, is the same as in the `Locate` statement. If it is not specified the instances will be placed at the current location.

[source,alan]
--------------------------------------------------------------------------------
Empty inventory Here.
"You seem to have lost most of your possessions. Well,
 you can't have everything."
Locate hero At restart_point.
--------------------------------------------------------------------------------



==== Strip Statement

[source,ebnf]
--------------------------------------------------------------------------------
strip_statement = 'STRIP' [direction] [count] [size]
                    from_clause [into_clause] '.'

direction = 'FIRST' | 'LAST'

count = expression

size = 'WORDS' | 'CHARACTERS'

from_clause = 'FROM' expression

into_clause = 'INTO' expression
--------------------------------------------------------------------------------

// @NOTE: Here I'd change:
// 				the optional *into clause*.
// 		  ...into:
// 				the optional `into` clause.

The (((STRIP, statement))) `Strip` statement is used to manipulate the contents of (((string, functions))) strings. You can use it to remove words or characters from a string, starting from the beginning or the end. The words or characters that are removed may be placed in an attribute as specified by the optional *into clause*. If the statement is used to manipulate words, blanks and separators are used to separate the words. In this case, any resulting string is also free of leading and trailing blanks.

A short example

[source,alan]
--------------------------------------------------------------------------------
The eliza IsA actor
  Has topic "".
  Verb talk_to
    Does
      Set topic Of eliza To "sailing music cooking reading".
      Strip Random 0 To 2 Words From topic Of eliza.
      Strip First Word From topic Into topic.
      "And how do you feel about" Say topic Of eliza. "?"
  End Verb.
End The eliza.
--------------------------------------------------------------------------------


=== Event Statements


==== Schedule Statement

`Schedule` (((SCHEDULE, statement))) will queue an event to occur at a specified location after the number of player turns specified by the expression.

[source,ebnf]
--------------------------------------------------------------------------------
event_statement = 'SCHEDULE' what [where]
                    'AFTER' expression '.'
--------------------------------------------------------------------------------

For example

[source,alan]
--------------------------------------------------------------------------------
Schedule ringing At clock After 60 - minutes Of clock.
--------------------------------------------------------------------------------

The number of moves can be zero, i.e. `After 0` means that the event will occur now (during this player turn, probably last, though). If no location is specified, `Here` is assumed, i.e. it will be executed at the current location, the location where the statement itself was executed.

An important case is when a `Schedule` statement without a `where`-clause is executed inside a `Rule`. Since rules are executed at nowhere so will the event. This means that any printout will be done nowhere and thus will be invisible to the player.

If the `where`-expression has the form `At id`, and the identifier represents an instance not inheriting from `location`, the event will occur wherever that instance is when the event occurs. The event will '`follow`' the instance.

Executing a second `Schedule` statement for the same event before it has occurred will reschedule the event to the new time. An event can only be scheduled for one execution at a time.


[NOTE]
================================================================================
The event can be specified by giving an event identifier or referring to an attribute of Event type.
================================================================================




==== Cancel Statement

[source,ebnf]
--------------------------------------------------------------------------------
cancel_statement = 'CANCEL' what '.'
--------------------------------------------------------------------------------

`Cancel` (((CANCEL, statement))) will remove the event referenced from the queue of scheduled events. It is not an error to remove an Event, which is not currently scheduled.

[source,alan]
--------------------------------------------------------------------------------
Event ticking
  "Tick..."
  If timer Of bomb = 0 Then
    Schedule explosion After 1.
  Else
    Decrease timer Of bomb.
    Schedule ticking After 1.
  End If.
End Event ticking.

Verb defuse
  Does
    Cancel ticking.
    Cancel explosion.
    "Phuuui! That was close."
End Verb defuse.

Start At office.
  "The bomb is ticking..."
  Schedule ticking After 1.
--------------------------------------------------------------------------------


The event can be referenced using any expression of Event type, e.g. an attribute.



=== Assignment Statements

There are a number of statements for changing values of attributes.



==== Make Statement

[source,ebnf]
--------------------------------------------------------------------------------
make_statement = 'MAKE' what something '.'

something = ['NOT'] id
--------------------------------------------------------------------------------


The (((MAKE, statement))) `Make` statement is used to set or reset Boolean attributes.

[source,alan]
--------------------------------------------------------------------------------
Make door open.
Make door Not open.
--------------------------------------------------------------------------------




==== Increase and Decrease Statements

[source,ebnf]
--------------------------------------------------------------------------------
increase_statement = 'INCREASE' what [by] '.'

decrease_statement = 'DECREASE' what [by] '.'

by = 'BY' expression
--------------------------------------------------------------------------------


The `Increase` (((INCREASE, statement))) and `Decrease` (((DECREASE, statement))) statements modifies the values of numeric attributes by increasing or decreasing them by the value of the expression given in the optional `By` clause. If no `By` clause is specified the attributes are changed by one.

[source,alan]
--------------------------------------------------------------------------------
Increase level Of bottle By contents Of mug.
Decrease lives Of hero.
--------------------------------------------------------------------------------





==== Set Statement

[source,ebnf]
--------------------------------------------------------------------------------
set_statement = 'SET' what 'TO' expression '.'
--------------------------------------------------------------------------------


The (((SET, statement))) `Set` statement is used when assigning values to numeric, string, reference of set valued attributes.

[source,alan]
--------------------------------------------------------------------------------
Set mood Of king_tut To 3.
Set hour Of clock To hour Of clock + 1.
--------------------------------------------------------------------------------

Setting attributes of reference or set type requires that the expression follow the type and subclass compatibility rules. For example, you can only assign

* integer type expressions to an integer attribute

[source,alan]
--------------------------------------------------------------------------------
Set intAttr To 4. -- Correct if intAttr is of Integer type
Set intAttr To "hi". -- Incorrect
--------------------------------------------------------------------------------

* an expression that refers to an instance if the attribute being assigned to is a ((reference attribute)) which has a class of which the class of the expression is a subclass

[source,alan]
--------------------------------------------------------------------------------
Has suspect butler.
Set suspect Of detective To someLocation. -- Incorrect
--------------------------------------------------------------------------------

* a set valued expression to a set type attribute if all members are instances of some subclass of the member class of the target attribute. Here are some examples, given the natural types of the instances

[source,alan]
--------------------------------------------------------------------------------
Has friends {monica, ross, chandler, rachel, phoebe, joey}. -- persons
Set friends Of mine To {book}. -- Incorrect, probably not a person
Set friends Of mine To {}. -- Correct, empty set is always OK
Set friends Of mine To {suspect Of detective}. -- Correct maybe
--------------------------------------------------------------------------------



==== Include Statement

[source,ebnf]
--------------------------------------------------------------------------------
include_statement = 'INCLUDE' expression 'IN' set '.'
--------------------------------------------------------------------------------

The (((INCLUDE, statement))) `Include` statement is used to include a new member in a Set. Typically, this is used to an instance or value to a collection of such. See <<Set Type>> for an explanation of the `Set` type. A member already in the `Set` will silently be accepted but not generate duplicate entries.

The set may be identified using an expression involving (((reference attribute))) reference attributes:


[source,alan]
--------------------------------------------------------------------------------
Include hitchhiker In friends Of driver Of car.
--------------------------------------------------------------------------------


And vice versa:

[source,alan]
--------------------------------------------------------------------------------
Include driver Of car In friends Of hitchhiker.
--------------------------------------------------------------------------------



==== Exclude Statement

[source,ebnf]
--------------------------------------------------------------------------------
exclude_statement = 'EXCLUDE' expression 'FROM' set '.'
--------------------------------------------------------------------------------

The `Exclude` statement is the reverse of the `Include` statement. It removes a member from a Set. An attempt to remove something not included in the Set will be silently ignored, so that after the execution of the statement it is guaranteed that the member is not in the Set.


[NOTE]
================================================================================
The inclusion or exclusion of an instance will not affect its location. A member may be included in multiple Sets.
================================================================================



=== Conditional Statements

In Alan there are two conditional statements, the common `If` statement and the `Depending On` statement.



==== If Statement

[source,ebnf]
--------------------------------------------------------------------------------
if statement = 'IF' expression 'THEN' statements
                   { elsif_part }
                   [ else_part ]
               'END' 'IF' '.'

elsif_part = 'ELSIF' expression 'THEN' statements

else_part = 'ELSE' expression 'THEN' statements
--------------------------------------------------------------------------------

The (((IF, statement))) `If` statement is essential for varying output and otherwise change the activities in the game. The expression is evaluated (see <<Expressions>> for details and examples of expression) and if it evaluates to true, the statements following the `Then` are executed. Otherwise, the expressions in any following `ElsIf` clauses are evaluated (in order) and the statements following the first expression that results in a true value is executed. If none of the expressions in the `ElsIf` clauses evaluated to true, or there are no `ElsIf` clauses, the statements following the `Else` are executed. The `Else` clause is optional.

[source,alan]
--------------------------------------------------------------------------------
If minute Of clock = 59 Then
  Set minute Of clock To 0.
  Increase hour Of clock.
Else
  Increase minute OF clock.
End If.
If level Of bottle = 0 Then
  "You have no water."
ElsIf level Of bottle < 5 Then
  "You have almost no water left."
Else
  "You have plenty of water."
End If.
--------------------------------------------------------------------------------

`If` statements which have an `IsA`-expression (see <<Class Expressions>>) are particularly important. As an `IsA`-expression test for the class of an instance, an `If` statement like

[source,alan]
--------------------------------------------------------------------------------
If i IsA actor Then ...
--------------------------------------------------------------------------------

will quarantee that for any statement inside the `Then`-part of that statement, the `i` will be of the class `actor`. This means that references to attributes, container properties and actor scripts etc. as if `i` belongs to the class `actor`, even if that was not known outside of the `If` statement.

A typical example where this is helpful is inside verbs where parameters can be restricted to more general classes by the syntax and the actual action can still perform specific actions only allowed on more specialized classes. Another would be in a loop over some unknown set of instances.

[source,alan]
--------------------------------------------------------------------------------
For Each e IsA entity, Here Do
  If e IsA actor Then ...
  If e IsA object Then ...
  If e IsA container_object Then ...
End For.
--------------------------------------------------------------------------------





==== Depending On Statement

[source,ebnf]
--------------------------------------------------------------------------------
depend_statement = 'DEPENDING' 'ON' expression
                       {case}
                   'END' 'DEPEND' '.'

case = right_hand_side 'THEN' statements
     | 'ELSE' statements
--------------------------------------------------------------------------------

The (((DEPENDING ON, statement))) `Depending On` statement is a provided to select one of a number of possible conditional cases depending on an expression. The expression can be any expression. The right-hand side is the right hand side of any valid expression. When combined with expression (as the left hand side of the expression) they will be a complete expression, that is evaluated.

A simple example of the `Depending On` statement is:

[source,alan]
--------------------------------------------------------------------------------
Depending On weight Of obj
  = 1 Then "light as a feather"
  Between 2 And 10 Then "carryable"
  Between 10 And 20 Then "heavy"
  > 20 Then "immobile"
  Else "weightless"
End Depend.
--------------------------------------------------------------------------------


The meaning of this example is to test the `weight Of obj` and select one of the cases depending on the value of it. If it is equal to one the first case will be executed. If none of the cases match, the optional `Else` case will be executed (in this case it will only be executed for weights of zero or less).

The cases are tested in the order specified. At most, one case will be executed. In the example, a weight of ten will render as "carryable".

The tests are thus equivalent to

[source,alan]
--------------------------------------------------------------------------------
If weight Of object = 1 Then "light as a feather"
ElsIf weight Of object Between 2 And 10 Then "carryable"
ElsIf weight Of object Between 10 And 20 Then "heavy"
ElsIf weight Of object > 20 Then "immobile"
Else "weightless"
End If.
--------------------------------------------------------------------------------


A `Depending On` statement is preferable to a chain of `If` statements when the same expression will be tested for multiple matches.



=== Actor Statements

Actor statements are statements that are used to control actors.



==== Use Statement

[source,ebnf]
--------------------------------------------------------------------------------
use_statement = 'USE' script ['FOR' actor] '.'
--------------------------------------------------------------------------------

// @FIXME: Not sure how this should be formatted:
// 				The *For* *actor* clause

The (((USE, statement))) `Use` statement starts execution of a given script for a given actor. The `For actor` clause is optional when writing code within a certain actor; in this case that the statement applies to the actor that the code is in.

[source,alan]
--------------------------------------------------------------------------------
Use Script playing For george.
--------------------------------------------------------------------------------



[NOTE]
================================================================================
You can use an expression such as a simple identifier, a parameter reference or
a ((reference attribute)) as the actor clause.
================================================================================



==== Stop Statement

[source,ebnf]
--------------------------------------------------------------------------------
stop_statement = 'STOP' actor '.'

actor = expression
--------------------------------------------------------------------------------


The (((STOP, statement))) `Stop` statement stops an actor from proceeding with any script it may be executing. In effect, it will abort it and put the actor in an idle state. The most common case is the direct reference to an actor using its identifier. More complex expressions resulting in an actor type value, such as a parameter reference or a ((reference attribute)), can be used as the actor clause.



==== Repetition Statements

The Alan language provides one compound statement for repetition, the `For Each` statement.

[source,ebnf]
--------------------------------------------------------------------------------
repetition_statement = 'FOR' 'EACH' id [filters] 'DO'
                           statements
                       'END' 'FOR' 'EACH' '.'

filters = filter { ',' filter }
        | 'BETWEEN' expression 'AND' expression
--------------------------------------------------------------------------------



You can optionally leave out either `For` or `Each` but not both.

The identifier is called the loop variable and will have similar semantics as a syntax parameter. It will dynamically be bound to instances, one for each repetition. In the body of the loop, the statements, this variable can be referenced in the same way as a syntax parameter.

The optional filters can be used to restrict the values in the loop. If the `Between` form is used, the loop becomes an integer loop, resulting in the loop variable having integer type and range from the two expressions inclusive. Otherwise, the loop variable will be of instance type and will consecutively assume the value of each instance fulfilling the filters. See <<Filters>> for an explanation of filters.

Any references to the loop variable within the repetition will refer to the instance bound, or integer value, in this repetition.

You can use any statements inside the repetition, e.g. to check for further conditions before operating on the instance. For example

[source,alan]
--------------------------------------------------------------------------------
For Each creature IsA actor Do
  If creature Here Then
    ...
  End If.
End For.
--------------------------------------------------------------------------------




=== Special Statements



==== Quit Statement

`Quit` (((QUIT, statement))) prints a question giving the player the choice of restarting the game, reloading a previously saved game or to quit. Any scoring or other printouts have to be made explicitly before executing the `Quit` statement.



==== Look Statement

`Look` (((LOOK, statement))) describes the current location (the current location is dependent on in which context it is executed) and what it contains to the player. First the location name is output, then the `Description` part for the location is executed. If you do not want the name of the location to be included you can use a `Describe` statement instead.

Then all object and actors at the location will automatically be executed by means of an implicit `Describe` for each of them. Any objects or actors that were explicitly described using a `Describe` statements, will be excluded from this automatic `Describe`.

The equivalent of a `Look` is automatically performed when the hero enters a new location.


[NOTE]
================================================================================
As the player will only see output generated at the same location as the hero, a
`Look` executed by another actor at some other location will not be seen by the
player. See <<Output Statements>> for more details on this important
consideration.
================================================================================



==== Save and Restore Statements

`Save` (((SAVE, statement))) saves the game on a file for later use with (((RESTORE, statement))) `Restore`. Both `save` and `restore` asks the player for a file name to use for storing and restoring. This allows the player to use unlimited number of save files.

If the player should be shown the current surroundings after a `Restore`, you will have to implement a player verb like

[source,alan]
--------------------------------------------------------------------------------
Verb restore
  Does
    Restore.
    Look.
End Verb restore.
--------------------------------------------------------------------------------



==== Score Statement

`Score` (((SCORE, statement))) is a way of rewarding the player by giving points for certain actions. This is done using the statement

[source,ebnf]
--------------------------------------------------------------------------------
score_statement = 'SCORE' integer '.'
--------------------------------------------------------------------------------

For example

[source,alan]
--------------------------------------------------------------------------------
Score 25.
--------------------------------------------------------------------------------



The first time every such statement is executed the points given are added to the player's current score. `Score` without any arguments prints a message indicating the current accumulated score.


[NOTE]
================================================================================
The `Score` statements assume a simple model of scoring; a number of actions are necessary to complete the game and all those are necessary to achieve the maximum number of points. Negative scores are not allowed and once a score is awarded it cannot be revoked, neither will it be awarded twice. For adventures having a more complex and varied scoring system (particularly if the game can be successfully finished without performing all scoring actions or in multiple ways), manual scoring should instead be implemented using attributes (e.g. on the hero) and suitable manipulation and test statements.
================================================================================





==== Visits Statement

The (((VISITS, statement))) `Visits` statement changes the number of times a location can be visited before the long description is presented again:

[source,ebnf]
--------------------------------------------------------------------------------
visits_statement = 'VISITS' count '.'
--------------------------------------------------------------------------------

The value of the argument (*count,* which must be an integer number) controls the number of visits to a particular location between full descriptions. The initial setting of 0 (zero) indicates that every time a particular location is visited its full description will be shown (which can also be expressed as: the full description will _not_ be shown 0 times in between). Thus, a setting of 1 (one) would give a full description every second time the same location is visited. So

[source,alan]
--------------------------------------------------------------------------------
Visits 0.
--------------------------------------------------------------------------------


will always show full descriptions (which is also the initial setting).


[NOTE]
================================================================================
The classic and familiar commands *verbose*, *brief* etc. can be imitated using different values in the `Visits` statement.
================================================================================



[NOTE]
================================================================================
The handling of descriptions is rather conservative in that it also takes modified attributes into account. If the visits calculation would indicate no full description, a modified attribute of the location will cause the full description to be shown the next time. That attribute might have caused the description of the location to change. So the visits handling ensures that the player will "`see`" all changes to the location. If you set attributes of the location every time they are visited, the built-in visits handling will not work as you expect.
================================================================================



Associated with this is a predefined attribute, `visits`, that exists for all instances inheriting from `location`. It will count how many times the player have visited the location. For example

[source,alan]
--------------------------------------------------------------------------------
The secret_cave IsA location
  Description
    "This is the secret cave. You have visited it"
    Say visits Of This.
    "times before."
End The secret_cave.
--------------------------------------------------------------------------------




==== Transcript Statement


[source,ebnf]
--------------------------------------------------------------------------------
transcript_statement = 'TRANSCRIPT' ('ON' | 'OFF') '.'
--------------------------------------------------------------------------------

Using the (((TRANSCRIPT, statement))) `Transcript` statement you can turn transcripting on or off. When transcripting is turned on all player input and game output is recorded in a file (or similar) which can be studied afterwards. Example uses are

* reading the game output as a novel (player)
* comparing the output to output from previous versions of the game (author)
* comparing output to the output of a v2 game (porting from v2)

To enable player access to the transcripting function you need to implement global verbs:


[source,alan]
--------------------------------------------------------------------------------
Syntax script_on = 'script' 'on'.
Verb script_on
  Does
    Transcript On.
    "Transcript turned on."
End Verb.

Syntax script_off = 'script' 'off'.
Verb script_off
  Does
    Transcript Off.
    "Transcript turned off."
End Verb.
--------------------------------------------------------------------------------


== WHERE Specifications

Many constructs in the Alan language require a specification of where the construct should operate. The general intention of such a (((WHERE, specification))) `Where` specification is to specify a location.

[source,ebnf]
--------------------------------------------------------------------------------
where = 'HERE'
      | 'NEARBY'
      | 'NEAR' what
      | 'AT' what
      | 'IN' what
--------------------------------------------------------------------------------

The meaning of the different constructs is as follows

* (((HERE))) `Here` is the location where the current activity is performed. Often this means where the hero is, but if the expression is evaluated in another run-time context this context is used. See <<Run-time Contexts,_Run-time Contexts_>> for a detailed discussion, but examples include an event scheduled at a particular location, in which case that location is `Here`. Note that `Here` is equivalent to `At Current Location`.
* (((NEARBY))) `Nearby` means at any adjacent location. An adjacent location means that there exists an exit from the other location to `Here` (note that the direction is from `Nearby` to `Here`). It is allowed to refer to any instance using an identifier or expression. In particular, instances inheriting from `location` are allowed, which can be used to see if someone at that location can use an exit to get here.
* `Near what` has a similar meaning to `Nearby` except that it refers to some other instance (the what) instead of the current location. The results is a truth value indicating if that other instance is at a location which is nearby (has an exit to) that of the location of the first instance.
* `At what` means at the location of the instance referenced by the `what` specification (see <<WHAT Specifications>>). Note that an instance is always `At` itself, i.e. `x At x` is always true. This can come as a surprise, especially if you try to aggregate or loop over instances. (See <<Aggregates,_Aggregates_>> and <<Repetition Statements,_Repetition Statements_>>.)
* `In what` must refer to a container and the expression refers to inside of that container.

These forms can be used in `Locate` statements and in some expressions for example. When used in their basic form in expressions they all look inside containers (and container in containers) to evaluate the expression. See <<The Whereabouts of an Entity,_The Whereabouts of an Entity_>> for more information about `Where` expressions.


[NOTE]
================================================================================
Not all kinds of `Where` specifications are meaningful in all constructs. Examples are `Nearby` and `Near`. They cannot be used in a `Locate` statement, as it requires a specific location to locate to.
================================================================================




== WHAT Specifications

Constructs in the grammar for the Alan language often refer to some class or instance defined in the Alan source. This is generally called a (((WHAT, specification))) `What` specification, as it specifies what the construct refers to. An example is the `Locate` statement that must refer to something that should be relocated.

[source,ebnf]
--------------------------------------------------------------------------------
what = 'CURRENT' 'ACTOR'
     | 'CURRENT' 'LOCATION'
     | 'THIS'
     | id
     | attribute_reference
--------------------------------------------------------------------------------


The meaning of the different forms of the `what` specification are:

* `Current Actor` (((ACTOR, in WHAT specifications))) is always set to the actor currently active, e.g. when a non-player actor is running a script this refers to the actor instance that is running.
* `Current Location` (((LOCATION, in WHAT specifications))) is the current location, i.e. the location where the current activity is performed. Normally this is the location where the hero is, but may also be where an event is executed or the location where a scripted actor currently is executing. See <<Run-time Contexts,_Run-time Contexts_>> for more details.
* `This` refers to the instance in which code, such as a verb body or a script, is run. This can for example be used to test or set attributes in inherited code, thus testing or setting attributes in the instance while the code is defined in a class that the instance inherits from. It cannot be used in events or global verbs.
* An identifier, *id*, refers to the class or instance with that name, a syntax parameter, script or loop variable with that name. A syntax parameter may have the same name as an class or instance declared elsewhere in the source in which case the parameter has precedence.
* A reference to an attribute, as described in <<Attribute References>>, might be used depending on its type and the context of the usage of the `what`-expression.


[NOTE]
================================================================================
Not all kinds of `What` specifications are meaningful in all contexts. For example it is not possible to use `Current Location` (nor an identifier referring to an instance inheriting from location) as the `what`-part of a `Locate In` statement. (Since it is illogical to locate locations in containers.)
================================================================================




== Expressions

The grammar for Alan refers to ((expression)). This is a generic name for a number of constructs yielding a value. The following sections describe the different kinds of expressions available in the Alan language.



=== Types of Expressions

(((types of expressions)))
Expressions are used e.g. in `If` and `Set` statements. The `If` statement requires a Boolean expression, i.e. an expression yielding a true or false value, while the `Set` statement can handle all other types of values. See <<Types>> for details on types.



=== Literal Values

(((literals)))
A single integer (e.g. 42) is a numeric expression. A string is an expression and represents a string value, e.g.

[source,alan]
--------------------------------------------------------------------------------
Set password Of terminal To "xyzzy".
--------------------------------------------------------------------------------

A value of the set type can be constructed directly as an expression. This can be used in a `Set` statement or another expression. E.g.

[source,alan]
--------------------------------------------------------------------------------
Set suspectedWeapons Of detective To {gun, bat, axe}.
--------------------------------------------------------------------------------

Each member in the set expression can be an expression of integer or reference type in itself.



=== Attribute References

[source,ebnf]
--------------------------------------------------------------------------------
attribute_reference = id 'OF' expression
                    | expression ':' id
--------------------------------------------------------------------------------


A references to an attribute can be used as part of any expression provided its type matches the semantics of the context. The type of the expression is the type of the attribute.

There are two formats available, of which the first resembles plain English.

[source,alan]
--------------------------------------------------------------------------------
Set password Of terminal To password Of manual.
--------------------------------------------------------------------------------

The second format is more compact, which might be preferable when referring to chains of attributes referring to other attributes. See <<Reference Attributes,_Reference Attributes_>> for an explanation on how this works.

[source,alan]
--------------------------------------------------------------------------------
Say detective:suspect:weapon.
--------------------------------------------------------------------------------

It might help to read the ':' as a replacement for *s*. In this example the detective must be known to have a ((reference attribute)), 'suspect', which can only refer to instances of a class that have an attribute named 'weapon'. It would be the same as

[source,alan]
--------------------------------------------------------------------------------
Say weapon Of suspect Of detective.
--------------------------------------------------------------------------------

You can test Boolean attributes of an instance by following the pattern

[source,ebnf]
--------------------------------------------------------------------------------
expression = expression 'IS' something
--------------------------------------------------------------------------------

For example

[source,alan]
--------------------------------------------------------------------------------
If bottle Is empty Then ...
--------------------------------------------------------------------------------

The test can be reversed by adding a `Not`:

[source,alan]
--------------------------------------------------------------------------------
If hero Is Not hungry Then ...
--------------------------------------------------------------------------------



==== Location Of

There is a particularly useful predefined pseudo-attribute, `location`, that can be used to query an instance of which location it is currently at.

[source,alan]
--------------------------------------------------------------------------------
Make location Of magic_lantern lit.
--------------------------------------------------------------------------------


This attribute is predefined on all instances and is guaranteed to return an instance of the class location, and it will be the innermost location of the instance (bearing in mind that locations may be nested).



=== Random Values

There are three types of random expressions. The first is the traditional random integer expression.

[source,ebnf]
--------------------------------------------------------------------------------
expression = 'RANDOM' expression 'TO' expression
--------------------------------------------------------------------------------

The random integer expression returns a numeric value that is randomly selected between and including the values of the two expressions. Arbitrary expressions yielding an integer value can be used as the boundary expressions.

[source,alan]
--------------------------------------------------------------------------------
Set eyes Of first_die To Random 1 To 6.
Decrease temp Of room By Random 0 To temp Of Room.
--------------------------------------------------------------------------------


The second and third types return a random member in a set or in a container respectively.

[source,ebnf]
--------------------------------------------------------------------------------
expression = 'RANDOM' ['DIRECTLY'] 'IN' expression
--------------------------------------------------------------------------------


If the expression refers to a container, the expression returns one of the instances currently in that container. The type of the entire expression is instances of the class accepted by the container. See <<Container Properties>> for details on how to determine the class of instances allowed inside a container.

If the expression refers to a set, the result is one of the members in the set. The type and class of the entire expression is determined by the allowed members in the set. See <<Set Type Attributes>>.

The optional keyword `Directly` is only allowed if the expression refers to a container. The semantics is the same as for the `Where` expression, see <<The Whereabouts of an Entity>>.


[NOTE]
================================================================================
Attempting to apply a random selection from an empty set or container is one of
the very few situations that could lead to a runtime error. It is the
responsibility of the author to ensure that this is not attempted. You should
always surround a random member expression with an `If` statement that ensures
that the set or container is not empty to guard against such runtime errors. See
<<Aggregates,_Aggregates_>> for descriptions on how to count members in a set or
container.
================================================================================



[NOTE]
================================================================================
A `thing` or `entity` inside a container, which normally do not exhibit themselves, will be candidates for being selected by a `Random In` statement, as any other instance.
================================================================================




=== Logical Expressions

[source,ebnf]
--------------------------------------------------------------------------------
expression = expression ('AND' | 'OR'] expression
--------------------------------------------------------------------------------

(((logical expressions)))
The `And` and `Or` operators are standard binary Boolean (((operators, logical))) operators, meaning that the result of an expression is true or false depending on the right and left expressions, which must also be boolean values or expressions. For `And` both expressions need to be true for the expression to be true. If using `Or` either of them need to true. Otherwise the expression will be evaluated to false.

`And` has higher priority, but parenthesis may be used to change the order of evaluation.

[source,alan]
--------------------------------------------------------------------------------
If kalif Here And mood Of sultan Is 0 Then ...
If o IsA treasure And (size Of o > capacity Of c
  Or thief Is greedy) Then ...
--------------------------------------------------------------------------------





=== Class Expressions

[source,ebnf]
--------------------------------------------------------------------------------
expression = something 'ISA' class_id
--------------------------------------------------------------------------------

(((class expressions)))
It is possible to check if an instance belongs to, or inherits from, a particular class. The resulting value is a Boolean type value.

[source,alan]
--------------------------------------------------------------------------------
If p IsA object Then ...
If opponent IsA enemy Then ...
--------------------------------------------------------------------------------


There is a subtle but very important side effect of checking for an instance class in an `If` statement like the above. Doing that will ensure that the instance or parameter that is checked has all the properties. This holds true for all statements in the `Then`-part of the `If` statement.

This is used by the compiler to allow references to attributes, scripts, container properties etc. that otherwise would not be allowed.

A very common use of this is to restrict parameters in a `Syntax` to a more general class, like thing or entity, and then doing "`manual`" restrictions using `If` statements to ensure that usage does not conflict with the actual properties of the instance. Also see <<If Statement,the section on _If Statement_>>.



=== Binary Operators

All binary operators (((operators, binary))) (plus, minus, multiplication, division) may be used on integer expressions. The result is another integer expression. The exact set of available operators is


................................................................................
+, -, *, /
................................................................................



For example

[source,alan]
--------------------------------------------------------------------------------
age Of golden_child + 4
--------------------------------------------------------------------------------

The plus operator (`+`) may also be used on strings for (((concatenation, of strings))) concatenation. The meaning of such an expression is that the two strings are concatenated into a resulting string. For example

[source,alan]
--------------------------------------------------------------------------------
string1 + " " + anotherString
--------------------------------------------------------------------------------



=== Relational and Equality Operators

Equality (`=`, meaning equals) and relational operators (((operators, relational))) (`<`, `>`, `+<=+`, `>=`, meaning: less than, greater than, less than or equal, greater than or equal respectively) are used to compare expressions. The result is true or false and may be negated by using an optional `Not`.

[source,alan]
--------------------------------------------------------------------------------
If temperature Of oven Not > 100 Then ...
If weather Of world Not < protection Of hero Then ...
--------------------------------------------------------------------------------

Comparing (((comparisons, equality))) two string expressions (((string, comparisons))) using the binary equality operator `=` will make a case insensitive comparison, i.e. it will give a true value if the strings are the same without considering the case of the characters. The special identity operator, `==`, only works on strings and compares the strings for an exact match (i.e. considering character case).

Two values of instance type may be compared with the `=` and `<>` operators, and may e.g. be used to test if a parameter refers to a particular instance or is the same as another parameter. For example

[source,alan]
--------------------------------------------------------------------------------
Syntax put_in = 'put' (o) 'in' (c)
  Where c IsA Container
    Else "You can't put anything in the" Say c.
Verb put_in
  Check o <> c
    Else "That would be a good trick if you could do it!!"
  Does
...
--------------------------------------------------------------------------------


Relational operations (((operators, relational))) are not allowed on entities or strings, nor is it possible to compare values of different types.

A special relational operator is the (((BETWEEN))) `Between` operator which makes it possible to test if a numeric expression is within a range of values. The range is inclusive, i.e. the values are included in the accepted range. For example

[source,alan]
--------------------------------------------------------------------------------
If level Of water Between 2 And capacity Of bottle Then ...
--------------------------------------------------------------------------------



=== String Containment

There is a string (((string, containment operator))) ((containment operator)), (((CONTAINS))) `Contains`, which can be used to test if a string contains another string. The test ignores any differences in character case. An example of an expression that is true is

[source,alan]
--------------------------------------------------------------------------------
"A string" Contains "a S"
--------------------------------------------------------------------------------

An optional `Not` (before `Contains`) can be used to reverse the test.

[source,alan]
--------------------------------------------------------------------------------
"A string" Not Contains "a S"
--------------------------------------------------------------------------------

The expression yields a Boolean value.



=== Current Entities

There are two particularly interesting entities that you might want to know something about or which they are. They are

* (((CURRENT ACTOR))) `Current Actor`
* (((CURRENT LOCATION))) `Current Location`

These two expressions can be used wherever a reference to an instance can be used. They will refer to the currently executing actor and the current location respectively. Details about execution contexts can be found in <<Run-time Contexts,_Run-time Contexts_>>.



=== This Instance

You can also refer to the instance that is actually executing the code containing the expression. This is particularly useful when using inheritance since the class defining the code have no way of knowing which instance will actually execute it. (((THIS, expression))) This expression is `This`.

An example is the code for objects that can be opened:

[source,alan]
--------------------------------------------------------------------------------
Every openable IsA object
  Is Not open.
  Verb open
    Check ...
    Does
      Make This open.
  End Verb.
End Every openable.

The door IsA openable
End The door.
--------------------------------------------------------------------------------




[example,role="gametranscript"]
================================================================================
&gt; *open the door*
================================================================================




Given these two declarations and some syntax declarations the door will inherit the `open` attribute. When the verb body, also inherited from `openable`, is executed, it will set the attribute on _the door_, because this instance is running the code.



=== The Whereabouts of an Entity

[source,ebnf]
--------------------------------------------------------------------------------
expression = what ['NOT'] [transitivity] where
--------------------------------------------------------------------------------

An expression following the above pattern can be used to test if a particular instance, as specified by the `what`, is (or is `Not`), at the place indicated by the `where`, as in

[source,alan]
--------------------------------------------------------------------------------
If bottle In inventory Then ...
--------------------------------------------------------------------------------

or

[source,alan]
--------------------------------------------------------------------------------
If hero Not Nearby Then ...
--------------------------------------------------------------------------------

The forms available for the `Where` expression are described in detail in <<WHERE Specifications>>.

The default behaviour of a `Where` expression is to evaluate recursively through containers, e.g. if the bottle was inside a bag which was in the inventory, the first expression above would still be true. This implicitly transitive evaluation can also be made explicit through the use of the keyword `Indirectly`. This would result in exactly the same semantics, but it is explicitly expressed, which can be useful.

[source,ebnf]
--------------------------------------------------------------------------------
transitivity =
             | 'DIRECTLY'
             | 'INDIRECTLY'
             | 'TRANSITIVELY'
--------------------------------------------------------------------------------


In addition, another qualifying keyword, `Directly`, can be used to indicate that the expression should _not_ evaluate recursively into containers. To test if an instance is at a particular location but not in a container at that location you can use:

[source,alan]
--------------------------------------------------------------------------------
If key Directly At treasury Then ...
--------------------------------------------------------------------------------

// @NOTE: Used auto generated ID for x-ref: <<_containment_classes_and_transitivity>>
//        instead of <<Containment, Classes and Transitivity>>

The qualifying keyword `Directly` works in the same way with all `Where` expressions. Adding a `Directly` qualifier to the first example above would change the expression to only be true if the bottle was in the container but not inside any other container even if that container was in the inventory. See <<_containment_classes_and_transitivity,_Containment, Classes and Transitivity_>> for some background information.


[NOTE]
================================================================================
If the transitivity is not Directly, the compiler analyses the container to see which classes of instances might be contained transitively. This includes all existing instances of the class that the container takes, and if any of those are containers, those containers and all instances of the classes they take and so on.
================================================================================




=== Aggregates

[source,ebnf]
--------------------------------------------------------------------------------
aggregate_expression = aggregate filters

aggregate = 'COUNT' | 'SUM' | 'MAX' | 'MIN'
--------------------------------------------------------------------------------

Aggregates are functions to calculate values from sets of instances. There are four aggregates available, `Count`, `Sum`, `Min` and `Max`. Aggregates work by inspecting all instances available, applying the filters, which may remove some, or even all, from the set of instances, and then calculate the value from the remaining instances.

You can use filters to filter out instances belonging to a particular class, at a particular location or having a particular Boolean attribute. See <<Filters>> for an explanation of filters.

(((COUNT))) `Count` counts the number of instances in the set, e.g.

[source,alan]
--------------------------------------------------------------------------------
"You are carrying"
Say Count IsA object, In inventory, Is big.
"big objects."
--------------------------------------------------------------------------------


In this example there are three filters applied, `IsA object`, `In inventory` and `Is big`. All of these filters must pass before an instance is counted. The result of that count is an integer, which is then printed using the `Say` statement.

The (((SUM, aggregate))) `Sum`, (((MIN, aggregate))) `Min` and (((MAX, aggregate))) `Max` aggregates return the sum, minimum and maximum value respectively, of an attribute of all instances in the filtered set.

Any attribute referred to either in the aggregation itself or in the filters, must be an attribute of some class in order to ensure that the attribute is available for all instances. You must ensure this by filtering out only instances of the relevant class, e.g. objects, using a class filter.

Some examples:

[source,alan]
--------------------------------------------------------------------------------
If Sum Of weight At bridge > 500 Then ...
If Max Of size In inventory > size Of small_door Then ...
If Count IsA lightsource, Is lit, Here > 0 Then
  "Let there be light...""
End If.
--------------------------------------------------------------------------------


These examples could be used to create various restrictions in the possible travels of the hero.



== Filters

[source,ebnf]
--------------------------------------------------------------------------------
filters = filter { ',' filter }

filter = 'ISA' class
       | is attribute
       | where
--------------------------------------------------------------------------------



Filters can be used to filter out only particular instances to loop or aggregate over. If one of the filters is a *IsA <class>*, only instances of that class will be bound to the loop variable or considered in the aggregation. In particular this is required if any of the other filters refer to attributes, which is only allowed if the class is known and that class is guaranteed to have that attribute. Other ways to restrict the filtered instances is to use a `Where` filter which implicitly restricts to instances available at or in that location, container or set. See <<The Whereabouts of an Entity>> for details on the various forms of the `Where` expression.

Multiple filters can be listed separated with a comma. Each filter must enumerate the set of values to a compatible set, e.g. using two `IsA` filters for actors and locations respectively is not allowed since those two sets can never be compatible.

