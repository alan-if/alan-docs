= Hints and Tips

This chapter will give you some ideas about how the various features of Alan may be used to implement common features in an adventure game.
These are only suggestions and you are, of course, welcome to invent your own, but these are probably some ideas that can get you started.

Using the `Import` mechanism of the Alan language (see <<IMPORT>>) you can reuse snippets that you invent in multiple games or works.
By building such a library you don't have to reinvent the same thing every time.

A very easy way to get a lot of functionality, and learn about using the language, is to use the Alan Standard Library.
You you can download it from the Alan website.
The library implements many of the things described below, and loads of other handy things for you to use directly.
For details on how to use that library, refer to its documentation.



[NOTE]
================================================================================
The following examples, hints and tips do _not_ use any library, only plain vanilla Alan code.
================================================================================



== Use of Attributes

(((attributes)))
Attributes are primarily used for holding status information about the instance to which they belong.
This allows, for example, a water bottle to contain three levels of water:

[source,alan]
--------------------------------------------------------------------------------
The bottle IsA object
  Has level 3.
  Verb drink
    Does
    If level Of bottle > 0 Then
      "You take sip from the bottle."
      Decrease level Of bottle.
    Else
      "There is no more water in the bottle."
    End If.
  End Verb drink.
End The bottle.
--------------------------------------------------------------------------------

Another example is a breakable mirror:

[source,alan]
--------------------------------------------------------------------------------
The mirror IsA object
  Is Not broken.
  Verb break
    Does
      Make mirror broken.
  End Verb break.
End The mirror.
--------------------------------------------------------------------------------

The appropriate verbs defined in the instances may then modify the attributes and thus update the status information.

Attributes defined for a whole class of instances also allow an extra dimension of classification of the instances.
If the following declaration is made:


[source,alan]
--------------------------------------------------------------------------------
Add To Every object
 Is Not takeable.
--------------------------------------------------------------------------------

then all objects receive the attribute `takeable` and unless the attribute is specifically redeclared for a particular instance they will not be takeable.
Note however that the semantic meaning of '`takeable`' (i.e. what actually happens, such as preventing the '`taking`' action) must be implemented e.g. in the verb '`take`':

[source,alan]
--------------------------------------------------------------------------------
Verb take
  Check Object Is takeable
    Else "You can't take the $o."
  Does
    Locate Object In inventory.
End Verb take.
--------------------------------------------------------------------------------

Similarly, restrictions concerning what is possible to eat, drink, open, etc. may also be implemented.
This use of attributes to classify instances is "`action-oriented`", i.e. they imply that a particular action (verb) is applicable to the instance.

An alternative approach is to use attributes to classify instances according to their characteristics.
Consider:

[source,alan]
--------------------------------------------------------------------------------
Verb take
  Check o Is Not heavy
    Else "That is too heavy."
  And o Is Not animal
    Else "$+1 moves quickly away, just far enough
          for you not to reach it."
  Does
    Locate o In hero.
    "You take" Say The o. "."
End Verb take.
--------------------------------------------------------------------------------


With this approach you need to keep track of which properties a particular verb will accept or require.
This could be extended one step further, having verbs check actual dimensions, such as weight or size, instead.

And while we are talking about classification, the Alan 3 class concept can help.
Often a classification can be made, clearly and succinctly, by defining a sub-class, for which every property pertaining to that type of instances can be collected.
Often, the need for an attribute disappears.

Further more, you don't need to define a syntax for a single parameter verb if it only accepts instances from a particular class.
Consider the following definitions:

[source,alan]
--------------------------------------------------------------------------------
Every vehicle IsA object
End Every vehicle.

Every car IsA vehicle
  Verb drive
    Does "Yoooohooooo!"
  End Verb.
End Every car.

Every bus IsA vehicle
End Every bus.

The car1 IsA car At l
End The car1.

The bus1 IsA bus At l
End The bus1.
--------------------------------------------------------------------------------


Without any `Syntax` definition whatsoever, Alan will supply a default syntax for the `drive` verb which restricts its use to car instances only:


[example,role="gametranscript"]
================================================================================
&gt; _look_

There is a car1 and a bus1 here.

&gt; _drive bus1_ +
You can't do that.

&gt; _drive car1_ +
Yoooohooooo!
================================================================================


So the class mechanism not only allows for another way to classify your instances, but also makes it much easier to handle player input correctly.



== Descriptions

Attributes come in handy when presenting information about instances to the player.
The attributes can be tested in (((IF, statement))) `If` statements to modify the ``Description``s and possibly even the short description in the `Mentioned` sections.

For example:

[source,alan]
--------------------------------------------------------------------------------
The mirror IsA object
  Is Not broken.
  Description
    "On the wall there is a beautiful mirror with an
     elaborate golden frame."
    If mirror Is broken Then
      "Some moron has broken the glass in it."
    End If.
  Verb break
    Does
      Make mirror broken.
  End Verb break.
End The mirror.
--------------------------------------------------------------------------------


If you also use this feature with the short descriptions will make the adventure feel a bit more consistent.

[source,alan]
--------------------------------------------------------------------------------
The bottle IsA object
  Has level 3.
  Article ""
  Mentioned
    If level Of bottle > 0 Then
      "a bottle of water"
    Else
      "an empty bottle"
    End IF.
End The bottle.
--------------------------------------------------------------------------------


If the bottle had `level` 0 and was in the hero container, this would result in:


[example,role="gametranscript"]
================================================================================
&gt; _inventory_ +
You are carrying an empty bottle.
================================================================================



== Common Verbs

As your adventures library grows, you will find that (((VERB, reusing common verbs))) some verbs are needed often, and always function the same way.
Examples are '`take`', '`drop`', '`inventory`', '`look`', '`quit`' and so on.
It is advisable to put them in a file which may then be (((IMPORT, importing files in adventure))) (((including files))) (((file, importing files in adventure))) imported into your games.
See <<IMPORT>> about the `Import` mechanism.
The files may then contain these common verbs as well as their syntax definitions and any synonyms.
Attributes needed for these particular verbs could also be placed in a (((default, attributes))) default attribute declaration in this file.

All your adventures may then import this file (or files), making these features immediately accessible when you start a new adventure.
All it takes is some thought on what names to use for the attributes, as discussed in <<Use of Attributes>>.

And of course there is already an extensive library available from the Alan website, {alan-www}.
It also includes a lot of other features common to most adventure games.



== Distant Events

(((events, hints about)))
(((EVENT, distant events)))
An effect of the feature that output is not visible unless the hero is present is that the description of an `Event` might not always be presented to the player.

[source,alan]
--------------------------------------------------------------------------------
Event explosion
  "A gigantic explosion fills the whole room with smoke
   and dust. Your ears ring from the loud noise. After
   a while cracks start to show in the ceiling,
   widening fast, stones and debris falling in
   increasing size and numbers until finally the
   complete roof falls down from the heavy explosion."
  Make Location destroyed.
End Event.
--------------------------------------------------------------------------------

If the hero isn't at the location where the event is executed, he will never know anything about what happened.
The solution is to create an `Event` that goes off where the hero is.

[source,alan]
--------------------------------------------------------------------------------
Event distant_explosion
  "Somewhere far away you can hear an explosion."
End Event.
...
If Hero Nearby Then
  Schedule distant_explosion At Hero After 0.
...
--------------------------------------------------------------------------------



== Doors

(((doors, hints about)))
A common feature in adventure games is the closed door.
Here's one way implement it:

[source,alan]
--------------------------------------------------------------------------------
The treasury_door IsA object At hallway
  Name treasury door
  Is Not open.
  Verb open
    Does
      Make treasury_door open.
      Make hallway_door open.
  End Verb open.
End The treasury_door.

The hallway IsA location
  Exit east To treasury
    Check treasury_door Is open
      Else "The door to the treasury is closed."
  End Exit.
End The hallway.

The hallway_door IsA object At treasury
  Name hallway door
  Is Not open.
  Verb open
    Does
      Make treasury_door open.
      Make hallway_door open.
  End Verb open.
End The hallway_door.

The treasury IsA location
  Exit west To hallway
    Check hallway_door Is open
      Else "The door to the hallway is closed."
  End Exit.
End The treasury.
--------------------------------------------------------------------------------


Note that we need two doors, one at each location, but they are synchronised by always making them both opened or closed at the same time.
The check in the ``Exit``s makes sure that the hero cannot pass through a closed door.



== Questions and Answers

Sometimes it may be necessary to ask the player for an answer to some question.
One example is if you want to confirm an action.
The following example delineates one simple way to do this, which could be adopted for various circumstances.

[source,alan]
--------------------------------------------------------------------------------
The hero IsA actor
  Is Not quitting.
End The hero.

Syntax
  'quit' = 'quit'.
  yes = yes.

Synonyms
  y = yes.
  q = 'quit'.

Verb 'quit'
  Does "Do you really want to give up?
        Type 'yes' to quit, or to carry on just
        type your next command."
  Make hero quitting.
  Schedule unquit After 1.
End Verb 'quit'.

Verb yes
  Check hero Is quitting
    Else "That does not seem to answer any question."
  Does Quit.
End Verb yes.

Event unquit
  Make hero Not quitting.
End Event unquit.
--------------------------------------------------------------------------------




== Actors

(((actors, hints about)))
Actors are vital components to make a story dynamic.
They move around and act according to their ``Script``s.
To make the player aware of the actions of other actors they need to be described.
This must be done so that the player always gets the correct perspective on the actors' actions.

A way to ensure this is to rely on the fact that output statements are not shown unless the hero is at the location where the output is taking place.
This means that for every actor action, especially movement, you need to first describe the actions, then let the actor perform them and, finally, possibly describe the effects.

An example is the movement of an actor from one location to another.
In this case the step could look something like:

[source,alan]
--------------------------------------------------------------------------------
"Charlie Chaplin goes down the stairs to the hallway."
Locate charlie_chaplin At hallway.
"Charlie Chaplin comes down the stairs and
 leaves the house through the front door."
Locate charlie_chaplin At outside_house.
"Charlie Chaplin comes out from the nearest house."
--------------------------------------------------------------------------------

An actor is described, for example, when a location is entered or as the result of a *look* command, in the same way as objects are.
This means that a good idea is to include the description of an actor's activities in its `Description`.
One way to do this would be to use attributes to keep track of the actor's state and test these in the `Description` clause.

[source,alan]
--------------------------------------------------------------------------------
The george IsA actor
  Name George Formby
  Is
    Not cleaning_windows.
    Not tuning.
  Description
    If george Is cleaning_windows Then
      "George Formby is here cleaning windows."
    ElsIf george Is tuning Then
      "George Formby is tuning his ukelele."
    Else
      "George Formby is here."
    End If.
...
--------------------------------------------------------------------------------

Although quite feasible, this is a bit tedious.
Since the actor's state is partlyt indicated by the script the actor is executing, this could be used to avoid the potentially large `If` chain.
The optional (((DESCRIPTION, of actor scripts))) descriptions tied to each script will be executed instead of the main description when the actor is following that script.
So this would allow us to simplify to:

[source,alan]
--------------------------------------------------------------------------------
The george IsA actor
  Name George Formby
  Description
    "George Formby is here."
  Script cleaning.
    Description
      "George Formby is here cleaning windows."
    Step
      ...
  Script tuning.
    Description
      "George Formby is tuning his ukelele."
    Step
      ...
...
--------------------------------------------------------------------------------

This makes it easier to keep track of what an actor is doing.
Another hint here is to describe the change in an actor's activities at the same time as executing the `Use` statement, like

[source,alan]
--------------------------------------------------------------------------------
Event start_cleaning
  Use Script cleaning For george.
  "All of a sudden, George starts to clean the windows."
End Event.
--------------------------------------------------------------------------------

This makes the descriptions of changes to be shown when they take place, and the description of the actor is always consistent.
You can, of course, still have attributes describing the actor's state to customize the description of the actor on an even more detailed level, but it generally suffices to describe an actor in terms of what script he is executing.



== Vehicles

The current version of Alan does not support actors being inside containers or inside other actors, which could be a straight forward way to implement vehicles.
However, since the reader/player does not need to know how the output is generated, we can use a location and a chain of events to substitute for the vehicle.

Let's start with the geography:

[source,alan]
--------------------------------------------------------------------------------
The garage IsA location
End The garage.

The parking_lot IsA location Name 'Large Parking Lot'
End The parking_lot.
--------------------------------------------------------------------------------

Then we implement the actual car:

[source,alan]
--------------------------------------------------------------------------------
The car IsA object Name little red sporty ferrari Name car
  At garage
  Is Not running.
  Has position 0.

  Verb enter
    Does
      Locate hero At inside_car.
  End Verb enter.

End The car.
--------------------------------------------------------------------------------

We also need a description for the inside of the car.
We will use another location for this:

[source,alan]
--------------------------------------------------------------------------------
The inside_car IsA location Name 'Inside the Ferrari'
  Description
    "This sporty little red vehicle can really take you
     places..."
  Exit out To inside_car
    Check car Is Not running
      Else "I think you should stop the car before getting
            out..."
    Does
      Depending On position Of car
        = 0 Then Locate hero At garage.
        = 1 Then Locate hero At parking_lot.
        --- Etc.
    End Depend.
  End Exit.

  Verb drive
    Check car Is Not running
      Else "You are already driving it!"
    Does
      Make car running.
      If car At garage Then Schedule drive_to_parking After 0.
      Else Schedule drive_to_garage After 0.
      End If.
  End Verb drive.

  Verb park
    Check car Is running
      Else "You are not driving it!"
    Does
      "You slow to a stop and turn the engine off."
      Make car Not running.
      Cancel drive_to_parking. Cancel drive_to_garage.
  End Verb park.

End The inside_car.
--------------------------------------------------------------------------------


We must ensure that the player can say just "`drive`" and "`park`" by defining the `Syntax` for those single word commands:

[source,alan]
--------------------------------------------------------------------------------
Syntax drive = drive.
Syntax park = park.
--------------------------------------------------------------------------------

You can also see from the above code that there are (at least) two events that need to be defined too.
They handle the movement of the car from one place to another:

[source,alan]
--------------------------------------------------------------------------------
Event drive_to_parking
  "You drive out from your garage and approach
   a large parking lot."
  Set position Of car To 1.
  Locate car At parking_lot.
  Schedule drive_to_garage After 1.
End Event drive_to_parking.

Event drive_to_garage
  "You drive out from the parking lot and approach
   your own garage."
  Set position Of car To 0.
  Locate car At garage.
  Schedule drive_to_parking After 1.
End Event drive_to_garage.
--------------------------------------------------------------------------------

The main idea is that the player/reader is inside the car, and the events are executed at this location, thus emulating movement.

There are a multitude of different solutions to this problem.
One possibility is to exchange the car object for an actor and the events for script steps.
However, in this solution the car object is not where the hero is (`inside_car`) so the output from the scripts for the car will not automatically be shown to the player.
There are (at least) two different ways to deal with this (one involving attributes, the other involving an extra object), but the solutions are left as an exercise to the reader!

As Alan allows nesting locations (locating a location at another as if it was an object or actor), yet another solution would be to actually move the car location between the garage and the parking lot.

Sincere thanks go to Walt (sandsquish@aol.com) for inspiring communication that brought this example to life.



== Floating Objects

Floating objects is a term used for objects that are available everywhere, or at least at many places.
Usually they are available wherever the hero is, and we want to avoid creating duplicate objects, so in a way we make them "`float`" along with the hero, or some other actor, instead.



=== Body Parts

One example of floating objects is the various parts of the hero's body.

To create floating objects you can use a particular feature of entities, namely the fact that they are always located where the hero is.
Such an entity can of course have the container property to allow it to contain a number of other instances.

So to have the hero's body parts available wherever the hero goes you can use:

[source,alan]
--------------------------------------------------------------------------------
The body_parts IsA entity
  Container
End The body_parts.

The right_arm IsA object Name right arm In body_parts ...
The head IsA object Name head In body_parts ...
--------------------------------------------------------------------------------


Using entity containers is also a simple way to create other compartments on the hero, such as a belt:

[source,alan]
--------------------------------------------------------------------------------
The belt IsA entity
  Container
    Header
      If Count In hero > 0 Then "and"
      Else "but" End If.
        "in your belt you have"
      Else
        ""
End The belt.
--------------------------------------------------------------------------------

You can combine that with the following definitions of the hero and the *inventory* verb:

[source,alan]
--------------------------------------------------------------------------------
The hero IsA actor
  Container
    Header "You are carrying"
    Else "You are empty-handed"
      If Count In belt = 0 Then "." End If.
End The hero.

Verb inventory
  Does
    List hero.
    List belt.
End Verb inventory.
--------------------------------------------------------------------------------

And the following output could result:

[example,role="gametranscript"]
================================================================================
&gt; _inventory_ +
You are empty-handed but in your belt you have a knife.
================================================================================



[NOTE]
================================================================================
The example uses the `Count` aggregate to see if the other container is empty or not, and select the appropriate output accordingly.
================================================================================



=== Outdoors and Indoors

Another example of floating objects are semi-abstract objects like air, ground and walls.
Some of these add some extra complexity for they should be available only under certain conditions.

Of course, you would not want outdoor things to be available when you are indoors.
To solve this, simply create yet another container object where we can store the outdoor things when they should not be accessible and place it where the hero can never be.
Now we only need to make sure that the objects are transferred between the two storages:

[source,alan]
--------------------------------------------------------------------------------
The outdoor_things IsA entity
  Container
End The outdoor_things.

The outdoor_things_storage IsA object At limbo
  Container
End The outdoor_things_storage.

The air IsA object In outdoor_things_storage ...
The sky IsA object In outdoor_things_storage ...

When location Of hero Is outdoors =>
  Empty outdoor_things_storage In outdoor_things.
When location Of hero Is Not outdoors =>
  Empty outdoor_things In outdoor_things_storage.
--------------------------------------------------------------------------------


You need to add the boolean attribute `outdoors` to every location to the make the rules work, of course.

And, _voilà_, every time the hero arrives at an outdoor location he will find the air and the sky.
And every time he enters a location that has the attribute `outdoors` set to false he will not find them available.

Well, perhaps he would like to have the air available indoors too, but that is left as an exercise for the reader!


[TIP]
================================================================================
An alternative to the location attribute is to use classes.
Define an `outdoor_location` class and an `indoor_location` class.
Then inherit as appropriate, and the rules could instead look like:

[source,alan]
--------------------------------------------------------------------------------
When location Of hero IsA outdoors_location => ...
When location Of hero IsA indoors_location => ...
--------------------------------------------------------------------------------
================================================================================


=== Nested Locations as a Solution

Yet another option would be to make use of the ((nested locations)) feature.
Put all your outdoor locations in a outdoor location where the `outdoor_storage` entity is also present (this is just a hint):

[source,alan]
--------------------------------------------------------------------------------
The outdoor_region IsA location
End The outdoor_region.

The park IsA location At outdoor_region
End The park.
--------------------------------------------------------------------------------


Then the outdoor items can stay at this "`region`" location, no need for rules or extra containers.



== Darkness and Light Sources

A very common puzzle in old time adventures (so much so that it has possibly been exploited beyond its potential) is the problem of dark locations and finding a source of light.

Darkness and light sources can be implemented in Alan in different ways.
Again, we basically have the choice between attributes and classes.
The solutions are both general and rather similar, so we will have a look at the solution using attributes and leave the other solution to the reader. (A good exercise to really understand the Alan class concept, so please take a stab at it.
If you want to have a look at one solution, you can study the Alan Standard Library, which uses classes to implement light sources.)

First we need an attribute owned by all objects.
We know we only need to consider objects because light sources need to be transported by the player, so they can not just be anywhere, like entities.

[source,alan]
--------------------------------------------------------------------------------
Add To Every object
  Is Not lightsource.
End Add To.
--------------------------------------------------------------------------------


This ensures that all objects have the boolean (true/false valued) attribute `lightsource` with the default not being a light source.
Any objects that provide light need to explicitly state that they are instead.
For some instances this attribute might change value dynamically, e.g. when the lamp is lit and extinguished.

Locations then must declare themselves as lit or not:

[source,alan]
--------------------------------------------------------------------------------
Add To Every location
  Is lit.
End Add To.
--------------------------------------------------------------------------------

Here we assume most locations are lit, dark locations need to declare themselves `Not lit`.

We can now count the number of instances at the current location having the attribute `lightsource` set, and if there are one or more there is some light provided.
So, the *look* verb could be reworked to:

[source,alan]
--------------------------------------------------------------------------------
Verb 'look'
  Check Current Location Is lit
    Or Count IsA object, Is lightsource, Here > 0
  Else
    "You cannot see anything without any light."
  Does
    Look.
End Verb.
--------------------------------------------------------------------------------


The `Check` of the `'look'` verb now checks the current locations need for light and then counts instances of object which are both light sources and present, to see if there is light.

Of course, we must also modify the dark locations so that they don't display their descriptions upon entrance.
This is easy to do using another addition to every location, a description check, similar to the check in the `'look'` verb:

[source,alan]
--------------------------------------------------------------------------------
Add To Every location
  Description
    Check Current Location Is lit
      Or Count IsA object, Is lightsource, Here > 0
    Else
      "You cannot see anything without any light."
End Add To.
--------------------------------------------------------------------------------





== Distant and Imaginary Objects

Sometimes you need to make it possible for the player to refer to things either far away, that are not really objects or that may be at many places at once.
Examples of these are a distant mountain that may be examined through a set of binoculars, the melody in "`whistle the melody`", and water or walls.
One way of handling this is to use entities, since they are "`everywhere`".
But sometimes you need better control over when they are available and when not.



=== A Mountain

For objects that need to be visible from a distance, the easiest method is to introduce a (((object, shadow objects))) (((shadow objects))) "`shadow object`".
This is a second object acting on behalf of, or representing, the distant object at the locations where it should be possible to refer to it.
For example:

[source,alan]
--------------------------------------------------------------------------------
The hills IsA location
  :
End The hills.

The mountain IsA object At hills
  :
End The mountain.

The scenic_vista IsA location Name Scenic Vista
End The scenic_vista.

The shadow_mountain IsA object AT scenic_vista
  Name distant mountain
  Description
    "Far in the distance you can see the Pebbly
     Mountain raising towards the sky."
End The shadow_mountain.
--------------------------------------------------------------------------------


This would allow for example at `scenic_vista`:


[example,role="gametranscript"]
================================================================================
*Scenic Vista.* +
Far in the distance you can see the Pebbly Mountain raising towards the sky. +

&gt; _look at mountain through the binoculars_ +
...
================================================================================



If the mountain must be visible and possible to manipulate from a number of locations, you might implement one shadow object for each location, but this might become a bit tedious if they are many.
If they are identical you can use a simple rule like the following:

[source,alan]
--------------------------------------------------------------------------------
When hero At scenic_vista Or hero At hill_road =>
  Locate shadow_mountain At hero.
--------------------------------------------------------------------------------

This will ensure that whenever the hero moves to any of the places from where the mountain is visible, the `shadow_mountain` will surely follow.
However, as the rules are executed _after_ the hero has already moved, a better strategy might be to make the `shadow_mountain` '`silent`', i.e. to have no description.
Instead, its description should be embedded in the description of the adjacent locations.
Yet, another possibility would be to move the pseudo-object around using statements in the ``Exit``s, like:

[source,alan]
--------------------------------------------------------------------------------
The scenic_vista IsA location Name Scenic Vista
  Exit east To path
    Does
      Locate shadow_mountain At path.
  End Exit east.
End The scenic_vista.
--------------------------------------------------------------------------------

Regardless of which of these strategies you chose, you need to take care that the shadow object is not present when the real object is.
In this particular case, it should not be moved to the `hills`.



=== The Melody

To allow the player to '`whistle the melody`' for example, there are two different tactics that can be employed.
One choice is to make the melody an `entity` (or some subclass thereof that you have defined), because, as we have seen, those can be manipulated from everywhere:

[source,alan]
--------------------------------------------------------------------------------
The melody IsA entity ...
Syntax whistle = whistle (m) ...
--------------------------------------------------------------------------------


The other route would be to make it an actual `object`.
In this case the `Syntax` for the `whistle` verb would need to indicate omnipotence -- i.e. that the player can refer in the parameter to instances which are far away, including istances inheriting from `object`. (See <<Indicators>> for more details on the _omnipotent indicator_.)

[source,alan]
--------------------------------------------------------------------------------
The melody IsA object ...
Syntax whistle = whistle (m)! ...
--------------------------------------------------------------------------------

The melody then does not have to be reachable, near or even be at any location at all, for the player to be able to refer to it.

In both cases you would most likely need to restrict the parameters for the syntax so that the player can't '`whistle the chair`'.
Which of the two strategies you would chose depends mainly on things like:

* are there many things that this applies to (many '`melodies`', perhaps)?
* should the player be able to manipulate this instance in other ways?
* do you need many different entities for various purposes?


== Using Events as Functions

[WARNING]
================================================================================
TBD.
================================================================================


== Structure


A good thing to do when designing an interactive fiction story is to separate the geography from the story.
In Alan, you can use the `Import` facility to structure your Alan source.
One approach could be to place the description of each location in a separate file along with any objects that could be considered part of the scenery and other related items.
These files can then all be included in a '`map`' file, which in turn is included by the top-level file.

The story line can be divided into files too, one for each '`scene`' -- a scene being comments describing the important things that are suppose to happen, any prerequisites and objects, events, rules, etc. which are specific for this part of the story.

This strategy will both give you a better structure of your adventure as well as help you design a better story, much like the storyboarding technique used in making movies or plays.



== Debugging

Occasionally your Alan code is flawed and you really can't understand what is actually happening.
To aid in discovering which part of your code is run when, the interpreter ((Arun)) incorporates some ((debugging)) features.
There are a few (((debugging, switches))) debugging switches available when starting the interpreter from the command line:


[literal, role="plaintext", subs="normal"]
................................................................................
*-c*       Log the commands input by the player
*-l*       Log a complete transcript of the game
*-t<n>*    Enable trace mode (<n> = level 1,2,3 or 4)
*-d*       Enter the debugger when the game starts
................................................................................

[IMPORTANT]
================================================================================
The `-t` and `-d` switches cannot be used unless the adventure has been compiled with the `Debug` option set (see <<Options>>).
================================================================================



=== Command Logs and Game Transcripts

For various purposes, such as debugging, a log of the game play can be handy.

There are two such options available.
One is a command input log and it is created when the option `-c` is given to the interpreter when starting a game.
Such a file is also sometimes called a "solution file" since it can be used to show the solution to a game.

A command input log can sometimes be used as input to the interpreter, and thus automate the execution of the exact player experience.

The other options is to create a complete transcript of the game play and is created when the option `-l` is used.
Such a log file contains both player input and the game output.

Both kinds of log files are created in the directory which was current when the interpreter was started, the name of the log file will begin with the game name.
They will have the extension *.a3s*, for "Alan v3 Solution", or *.a3t*, for "Alan v3 Transcript", respectively.



=== Interpreter and Instruction Trace

(((interpreter)))
Trace mode can also be helpful when debugging.
Level 1 of tracing will show each section, verb, exit, description etc., the interpreter is invoked on, making it easier to see which parts of the code are executed.

Trace level 2, instruction trace, will in addition also trace the execution of each operation in the generated code.
Level 3 shows the execution of all steps, also those only pushing to or popping from stack.
Level 4 dumps the content of the stack between each instruction.
So higher numbers gives more information but is probably also less and less useful for normal debugging.



=== Debug Mode

Finally, and usually most useful, there is the debug mode.
If the interpreter is started with this option, it will execute the start up sequence and then prompt for a debug command with:


[example,role="gametranscript"]
================================================================================
adbg&gt;
================================================================================



=== Using the Debugger

((Abug)) may also be entered during the execution of an adventure.
To do this you simply give the following player command (type it at the game prompt):


[example,role="gametranscript"]
================================================================================
&gt; _debug_
================================================================================


The game must have been compiled with the debug option or the command will be sent to the game which probably does not recognize it.

Typing a question mark or *help* in response to the debug prompt will give a brief listing of the commands available in Abug:


................................................................................
break [[file]:[n]]   -- set breakpoint at source line [n] in [file]
delete [[file]:[n]]  -- delete breakpoint at source line [n] in [file]
files                -- list source files
events               -- show events
classes              -- show class hierarchy
instances [n]        -- show instance(s)
objects [n]          -- show instance(s) that are objects
actors [n]           -- show instance(s) that are actors
locations [n]        -- show instances that are locations
trace ('source'|'section'|'instruction'|'push'|'stack')
                     -- toggle various traces
next                 -- execute to next source line
go                   -- go another player turn
exit                 -- exit debug mode and return to game, enter again using 'debug' as input
x                    -- d:o
quit                 -- quit game
................................................................................


[TIP]
================================================================================
Any command may be abbreviated as long as it is unambiguous.
Typing *b* for *break* will work, for example.
================================================================================



The display commands, *actors*, *locations*, *objects* and *events*, may optionally be followed by a number.
Abug will then display detailed information about the entity requested, such as values of attributes, its present location, etc.
Currently there is no way to modify anything using Abug.

You can run the adventure to the next source line by using the *next* command.
If the source file is available, the interpreter will also show the source line.

Breakpoints can be set on a source line.
Enter the *break* command followed by the number of the source line.
Alan allows the source to be separated into multiple files, so the interpreter always indicate which file the source line is in, e.g. when hitting a breakpoint or stepping to the next source line.
When setting a breakpoint, the current file is always assumed.
You can currently set a breakpoint in another source file by preceding the line number with the file name delimited by a colon.

Breakpoints can be deleted.
The *delete* command without a line number will remove any breakpoint at the current line.
You can specify which breakpoint to delete by giving the line number (and optionally the file name).


[NOTE]
================================================================================
The debugger knows on which source lines it is possible to place a breakpoint.
If you attempt to put a breakpoint at some line where it is not possible, it will attempt to place one at a line which is numerically higher but as close a possible.
This will sometimes cause a breakpoint to be placed in a context that will not be what you expected.
================================================================================


The *trace* command and its options correspond to the types of traces described in the section on <<Command Logs and Game Transcripts,_Command Logs and Game Transcripts_>> above.

Wherever different output styles are available, e.g. in GLK based interpreters like WinArun, the Alan debugger tries to use them to distinguish the debugger output from the output of your game by using the pre-formatted style (see the section on styles in <<Output Statements>>).

// @NOTE STYLES:
//    For the following transcript session I've dropped the "gametranscript"
//    style (role) in favour of a verbatim block (with role="shell") because
//    the "gametranscript" style was meant to mimick Gargoyle, and it was
//    difficoult to preserve the monospaced debugging style along with the
//    serif fonts.

// @CHANGED STYLES: Dropped bold.
//    Also, I've only kept the italic for player input, and dropped the bold
//    for output -- which was mentioned in the text but not actually present
//    in the PDF document either!

The following is a short excerpt from a command line debugging session (user input in
italics):

// @TODO RISK FOR OBSOLETE DEBUG TRANSCRIPT:
//   This should really be generated from a real game using a commands script,
//   and then imported in the document. But since there are some abbreviated passages
//   and the styling that would take some effort. It is possible that this does
//   not actually change significantly often enough to warrant the effort of
//   automating it.

[literal, role="shell", subs="+quotes"]
................................................................................
<Arun - Adventure Language Interpreter version 3.0beta8 (2021-04-05 21:19:57)>
<Version of 'saviour.a3c' is 3.0beta8!>
<Hmm, this is a little-endian machine, fixing byte ordering....OK.>
<'saviour' contains the following IFIDs:
  IFID:	UUID://c065a752-a476-a252-731f-e9fe96fcdc6d//
>
adbg> _n_

adbg:  Stepping to saviour.alan:1346
<01346>:     "$pWelcome to the game of SAVIOUR!$pIn this game your mission
adbg> _n_

Welcome to the game of SAVIOUR!

<<Game output deleted for breivity>>

adbg:  Stepping to saviour.alan:1354
<01354>:     Show 'logo.png'.
adbg> _n_

adbg:  Stepping to saviour.alan:1355
<01355>:     "$iVisit the Alan Home Pages at:"

adbg> _break 1357_
Line 1357 not available, breakpoint instead set at saviour.alan:1358
<01358>:     Visits 2.

adbg> _g_

    Visit the Alan Home Pages at:


    http://www.alanif.se

adbg:  Breakpoint hit at saviour.alan:1358
<01358>:     Visits 2.
adbg> _n_

Outside The Tall Building

adbg:  Stepping to saviour.alan:318
<00318>:         "To the north is a tall ancient building with a large entrance.
adbg> _n_
To the north is a tall ancient building with a large entrance. On
the top there is a clock tower. Most of the windows in the building are
broken, and a sign with three oval objects are hanging lose from the wall.

> _north_
adbg:  Stepping to saviour.alan:325
<00325>:             Score 5.

adbg> _?_
Alan 3.0beta8 -- Adventure Language System (2021-04-05 21:19)
ADBG Commands (can be abbreviated):
    help               -- this help
    ?                  -- d:o
    break [[file:]n]   -- set breakpoint at source line [n] (optionally in [file])
    delete [[file:]n]  -- delete breakpoint at source line [n] (optionally in [file])
    files              -- list source files
    events             -- list events
    classes            -- list class hierarchy
    instances [n]      -- list instance(s), all, wildcard, number or name
    objects [n]        -- list instance(s) that are objects
    actors [n]         -- list instance(s) that are actors
    locations [n]      -- list instances that are locations
    trace ('source'|'section'|'instruction'|'push'|'stack')
                       -- toggle various traces
    next               -- continue game and stop at next source line
    go                 -- go another player turn
    exit               -- exit to game, enter 'debug' to get back
    x                  -- d:o
    quit               -- quit game

adbg> _trace section_
Section trace on.
adbg> _n_

<EXIT north[1] from Outside The Tall Building[4], Moving:>
<ENTERED in class entity[1] is empty>
<ENTERED in class location[2] is empty>
<ENTERED in instance Hall[5] is empty>

Hall

adbg:  Stepping to saviour.alan:332
<00332>:         "Inside the entrance is a hallway full of dust and pieces of
adbg> instances
Instances:
    [1] #nowhere ("#nowhere")
    [2] pseudowords ("pseudowords") (container), at [1] #nowhere ("#nowhere")
    [3] nowhere ("nowhere")
    [4] outside ("Outside The Tall Building")
    [5] Hall ("Hall")
    [6] door ("door"), at [5] Hall ("Hall")
    [7] stairs ("Stairs")
    [8] cellar ("cellar")
    [9] rats ("rats"), at [8] cellar ("cellar")
    [10] store ("store")
    [11] tape ("spool of computer tape"), at [10] store ("store")
    [12] first_floor ("First Floor")
    [13] book ("old book"), at [12] first_floor ("First Floor")
<<list abbreviated>>

adbg> instance 13
The [13] book ("old book") Isa object[4]
    Location: at [12] first_floor ("First Floor")
    Attributes:
        Takeable[2] = 1
        Readable[3] = 1
        openable[4] = 0
        startable[5] = 0
        examinable[6] = 1

adbg> _g_
Inside the entrance is a hallway full of dust and pieces of the
ceiling has fallen to the floor. At the west end is a staircase, and to
the south is the exit. To the east is a folding door. It is closed.

> _west_

<EXIT west[3] from Hall[5], Moving:>
<ENTERED in class entity[1] is empty>
<ENTERED in class location[2] is empty>
<ENTERED in instance Stairs[7] is empty>

Stairs
You are at the landing of an old staircase. It seem steady enough to walk
in, but be careful if you are going to use it. There is a passage leading
up, and another leading down into a dark cellar. To the east is the
hallway. A strange smell emerges from below.

> _up_

<EXIT up[5] from Stairs[7], Moving:>
<ENTERED in class entity[1] is empty>
<ENTERED in class location[2] is empty>
<ENTERED in instance First Floor[12] is empty>

First Floor
The landing on the first floor is as dirty as all the others. Meters and
meters of old cables are laying around, leading into a room to the east.
The stairs leads up and down. They still seem alright. Through the dirty
windows the barren field outside the building can be seen. Almost
completely covered by dust, there is an old book laying on the floor here.

> _take book and read it_

<VERB 21, in parameter str(#1)=old book[13], inherited from object[4], CHECK:>
<VERB 21, in parameter str(#1)=old book[13], inherited from object[4], DOES:>
Taken.

<VERB 5, in parameter object(#1)=old book[13], inherited from object[4], CHECK:>
<VERB 5, in parameter object(#1)=old book[13], DOES:>
As you carefully try to open the book it falls apart into dust and falls
to the floor through your fingers.

> _debug_

adbg> _instance 13_
The [13] book ("old book") Isa object[4]
    Location: at [3] nowhere ("nowhere")
    Attributes:
        Takeable[2] = 1
        Readable[3] = 1
        openable[4] = 0
        startable[5] = 0
        examinable[6] = 1

adbg> _trace instruction_
Instruction trace on.
adbg> _n
> _north_

++++++++++++++++++++++++++++++++++++++++++++++++++
1f85: PRINT        10048,     22                  "You can't go that way."
1f86: RETURN
--------------------------------------------------

> _west_

++++++++++++++++++++++++++++++++++++++++++++++++++
1f85: PRINT        10048,     22                  "You can't go that way."
1f86: RETURN
--------------------------------------------------

> _east_

<EXIT east[2] from First Floor[12], Moving:>
<ENTERED in class entity[1] is empty>
<ENTERED in class location[2] is empty>
<ENTERED in instance office[14] is empty>

++++++++++++++++++++++++++++++++++++++++++++++++++
 fcb: LINE             0,      0
 fce: PRINT         3479,      6                  "Office"
 fcf: RETURN
--------------------------------------------------

++++++++++++++++++++++++++++++++++++++++++++++++++
 fd2: LINE             0,    598
adbg:  Stepping to saviour.alan:598
<00598>:         "In front of you is a deserted office area. Desks and chairs

adbg> _g_

 fd5: PRINT         3485,    404                  "In front of you is a deserted
office area. Desks and chairs are piled up in one corner. The ventilation
system has partly fallen to the floor, tearing part of the ceiling down
with it. Under the twisted tubing a couple of old coffee makers are
crushed to pieces. One shelf, having some kind of lettering, no longer
readable, is thrown to one side, and another is still standing in a
corner, full of dust."
 fd6: RETURN
--------------------------------------------------

++++++++++++++++++++++++++++++++++++++++++++++++++
100c: LINE             0,    616
100f: ATTRIBUTE       15,     17                 =0
1010: NOT           FALSE                        =TRUE
1011: IF             TRUE
1014: LINE             0,    617
1017: PRINT         3711,     43                  " There is a ladder laying on the
floor here."
1018: ELSE
    :
1029: RETURN
--------------------------------------------------

> _look_

<VERB 19, GLOBAL, DOES:>

++++++++++++++++++++++++++++++++++++++++++++++++++
 7dc: LINE             0,    199
 7dd: LOOK
++++++++++++++++++++++++++++++++++++++++++++++++++
 fcb: LINE             0,      0
 fce: PRINT         3479,      6                  "Office"
 fcf: RETURN
--------------------------------------------------

++++++++++++++++++++++++++++++++++++++++++++++++++
 fd2: LINE             0,    598
 fd5: PRINT         3485,    404                  "In front of you is a deserted
office area. Desks and chairs are piled up in one corner. The ventilation
system has partly fallen to the floor, tearing part of the ceiling down
with it. Under the twisted tubing a couple of old coffee makers are
crushed to pieces. One shelf, having some kind of lettering, no longer
readable, is thrown to one side, and another is still standing in a
corner, full of dust."
 fd6: RETURN
--------------------------------------------------

++++++++++++++++++++++++++++++++++++++++++++++++++
100c: LINE             0,    616
100f: ATTRIBUTE       15,     17                 =0
1010: NOT           FALSE                        =TRUE
1011: IF             TRUE
1014: LINE             0,    617
1017: PRINT         3711,     43                  " There is a ladder
laying on the floor here."
1018: ELSE
    :
1029: RETURN
--------------------------------------------------
 7de: RETURN
--------------------------------------------------

> _q_
................................................................................


In the instruction trace, lines of `+` characters indicates the start of interpretation, thus they can be present inside other single step traces (like the `Look` in the example above).
Lines of dashes, indicates the return from one such level of interpretation.


// EOF //
